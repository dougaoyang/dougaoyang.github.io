<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>字符串朴素匹配算法和KMP算法</title>
      <link href="/2020/05/24/tech/python/structure/str-search-and-kmp.html"/>
      <url>/2020/05/24/tech/python/structure/str-search-and-kmp.html</url>
      
        <content type="html"><![CDATA[<p>字符串的匹配在平常的编码过程中非常常用，在编程语言中通常是调用一个内置函数就可以实现字符串的匹配，当不让使用内置的函数，而是自己编写一个函数来实现匹配的功能，应该如何来写呢？</p><p>今天介绍两个算法，朴素匹配算法，和无回溯匹配算法中的KMP算法。</p><h2 id="朴素匹配算法"><a href="#朴素匹配算法" class="headerlink" title="朴素匹配算法"></a>朴素匹配算法</h2><p>朴素匹配算法就是按照常识来，最容易理解的逐个字符匹配。<br>从待匹配字符串中的某个下标<code>i</code>开始，匹配字符串从<code>0</code>开始，逐个匹配。当有不匹配的字符时，重新从<code>i+1</code>下标开始重复上次的匹配过程。</p><img width="50%" src="/images/struct/5.jpg" alt="图(1) 朴素匹配算法"><p>下面用代码实现一下：<br><code>t</code>表示待匹配字符串，<code>p</code>表示用来匹配的字符串。</p><p><strong>$p_i$ 表示p字符串的第i个下标的字符。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">naive_match</span><span class="params">(t, p)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    t 目标字符串</span></span><br><span class="line"><span class="string">    p 匹配字符串</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    m, n = len(p), len(t)</span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> j &lt; n:</span><br><span class="line">        <span class="keyword">if</span> p[i] == t[j]: <span class="comment"># 字符相同，考虑下一字符</span></span><br><span class="line">            i, j = i + <span class="number">1</span>, j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i, j = <span class="number">0</span>, j - i + <span class="number">1</span>  <span class="comment"># 字符不同，查找字符串重置，目标字符串回溯</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i == m:</span><br><span class="line">        <span class="keyword">return</span> j - i</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>朴素匹配算法非常简单，容易理解。当然，它的效率也是很低的，造成效率低的原因是在执行过程中会有回溯。当遇到<code>p[i] != t[j]</code>时，匹配字符串下标置0，待匹配字符串的下标回到上一次检查的下一个位置，往回退了<code>j - i + 1</code>个位置。</p><p>这种操作造成的效率很低。最坏的情况是，每次匹配都是到最后一个字符的时候不匹配。例如：<br>&nbsp;&nbsp;待匹配字符串： 0000000000001<br>&nbsp;&nbsp;匹配字符串：   00001<br>这样需要 <code>n-m+1</code>次比较，总的比较次数就是<code>(n-m+1) * m</code>，这样它的复杂度就是：O(n*m)</p><h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>朴素算法的效率低，根源上是把每次匹配都看成的单独的事件，没有利用到之前的匹配信息。而其他改进算法就是利用了之前的匹配信息。</p><p>KMP算法的基本思想就是在匹配中不回溯。</p><img width="60%" src="/images/struct/7.jpg" alt="图(2) KMP算法图解"><p>描述KMP算法，需要借助上图。<br>待匹配字符串<code>t</code>，和匹配字符串<code>p</code>。<br>在匹配过程中，<code>p</code>的第i个字符在和<code>t</code>的第j个字符比较，这时，$t_{j-i}$～$t_{j-1}$和$p_0$～$p_{i-1}$相等，匹配完成。下面要做的步骤可以分为两个：</p><ul><li>当$t_j = p_i$ 时，继续进行下一个字符的比较。</li><li>当$t_j \neq p_i$ 时，这是不需要重置<code>p</code>，而是找到一个位置<code>k</code>($0\leq k &lt; i$)，使得$t_{j-k}$～$t_{j-1}$ 等于 $p_0$～$p_{k-1}$，继续匹配$t_{j}$和$p_{k}$，重复上面的步骤。这样待匹配字符串也不需要回溯到前面去重新匹配。</li></ul><p>KMP算法中的关键认识是：在$p_i$匹配失败时，所有的$p_k$($0\leq k &lt; i$)都已经匹配成功。也就是说，待匹配字符串中的$t_j$之前的i个字符，与匹配字符串中的前i个字符$p_0,p_1,…,p_{i-1}$。<br>通过上面的分析，要找到k，完全可以先不管待匹配字符串，而是研究一下匹配字符串<code>p</code>，通过<code>p</code>找到它前移的位置<code>k</code>。</p><p>得出一个结论：在<code>p</code>中，其中的每一个字符的<code>i</code>都会有其对应的下标<code>k</code>，与待匹配的字符串无关。</p><p>因此，我们可以为匹配字符串设计一个列表来存储每一个<code>i</code>的下标<code>k</code>。假设p的长度为m，用一个长度为m的列表pnext来存储，用表元素<code>pnext[i]</code>来表示i个元素的下标k值。<br>有一种特殊情况：$p_i$匹配失败后，之前所做的匹配都没有用，需要从头开始匹配，用$p_0$与$t_{j+1}$比较。在这种特殊情况下可以在<code>pnext[i]</code>中存入-1来表示。显然，$p_0$一直为-1。</p><h3 id="KMP主算法"><a href="#KMP主算法" class="headerlink" title="KMP主算法"></a>KMP主算法</h3><p>当假设pnext已经获得了，KMP的算法实现为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmp_match</span><span class="params">(t, p, pnext)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    KMP匹配，主函数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    m, n = len(p), len(t)</span><br><span class="line">    <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> j &lt; n:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">-1</span>: <span class="comment"># -1 匹配下一队字符</span></span><br><span class="line">            i, j = i + <span class="number">1</span>, j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> p[i] == t[j]: <span class="comment"># 相等，匹配下一对字符</span></span><br><span class="line">            i, j = i + <span class="number">1</span>, j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i = pnext[i] <span class="comment"># 从pnext中拿出下一个字符应该的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i == m:</span><br><span class="line">        <span class="keyword">return</span> j - i</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><p>该算法的时间复杂度为O(n)，因为j的循环次数不会超过n，<code>i = pnext[i]</code>的次数不会超过m。</p><h3 id="pnext的实现"><a href="#pnext的实现" class="headerlink" title="pnext的实现"></a>pnext的实现</h3><p>最长相等前后缀</p><p>已知pnext[0]=-1，并且pnext[0]到pnext[i-1]已知的情况下，求解pnext[i]:</p><ol><li>假设<code>pnext[i-1]=k-1</code>，如果$p_i=p_k$，则$p_0,p_1,…,p_i$的最长的匹配相等长度为k，记下<code>pnext[i]=k</code>。</li><li>如果$p_i \neq p_k$，就将k的值设为pnext[k]，即考虑前一个保证匹配的字符串，且更短。</li><li>假如k的值为-1（由第二步造成，一直到不到可以匹配的字符串），那么就将pnext[i]设置为0，将i递增后继续检查。</li></ol><p>构造方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_pnext</span><span class="params">(p)</span>:</span></span><br><span class="line">    i, k, m = <span class="number">0</span>, <span class="number">-1</span>, len(p)</span><br><span class="line"></span><br><span class="line">    pnext = [<span class="number">-1</span>] * m</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i &lt; m - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">-1</span> <span class="keyword">or</span> p[i] == p[k]:</span><br><span class="line">            i, k = i + <span class="number">1</span>, k + <span class="number">1</span></span><br><span class="line">            pnext[i] = k</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = pnext[k]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pnext</span><br></pre></td></tr></table></figure><p>举例：匹配字符串为 <code>abbcabcaabbcaa</code>，得到的pnext为：<br><code>[-1, 0, 0, 0, 0, 1, 2, 0, 1, 1, 2, 3, 4, 5]</code></p><h4 id="pnext生成算法的改进"><a href="#pnext生成算法的改进" class="headerlink" title="pnext生成算法的改进"></a>pnext生成算法的改进</h4><p>在pnext的生成中，对pnext[i]的设置可以有些优化。<br>在图(2)中，$p_i \neq t_j$匹配失败，假设pnext[i]=k，如果发现$p_i=p_k$，那么也一定有$p_k \neq t_j$，所以，这种情况下pnext[i]的位置移动到pnext[k]，这一修改减少了一个比较步骤，有可能提高效率。修改后：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_pnext</span><span class="params">(p)</span>:</span></span><br><span class="line">    i, k, m = <span class="number">0</span>, <span class="number">-1</span>, len(p)</span><br><span class="line"></span><br><span class="line">    pnext = [<span class="number">-1</span>] * m</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i &lt; m - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">-1</span> <span class="keyword">or</span> p[i] == p[k]:</span><br><span class="line">            i, k = i + <span class="number">1</span>, k + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> p[i] == p[k]:</span><br><span class="line">                pnext[i] = pnext[k]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pnext[i] = k</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = pnext[k]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pnext</span><br></pre></td></tr></table></figure><p>举例：匹配字符串为 <code>abbcabcaabbcaa</code>，得到的pnext为：<br><code>[-1, 0, 0, 0, -1, 0, 2, -1, 1, 0, 0, 0, -1, 5]</code></p><p>pnext的复杂度为O(m)，所以整个KMP算法的复杂度O(m+n)，由于m小于n，可以认为复杂度为O(n)，优于朴素算法。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>约瑟夫（Josephos）问题以及解法</title>
      <link href="/2020/04/03/tech/python/structure/josephus-solve.html"/>
      <url>/2020/04/03/tech/python/structure/josephus-solve.html</url>
      
        <content type="html"><![CDATA[<h2 id="Josephos问题"><a href="#Josephos问题" class="headerlink" title="Josephos问题"></a>Josephos问题</h2><p>假设n个人围坐一圈，现在要求从第k个人开始报数，报到第m个人退出，然后从下一个人开始继续报数并按照同样规则退出，直至所有人退出。要求按照顺序输出退出人的编号。</p><h2 id="基于顺序表的解法"><a href="#基于顺序表的解法" class="headerlink" title="基于顺序表的解法"></a>基于顺序表的解法</h2><p>当确定退出的人后，就将其编号的元素从列表中删除，这样列表就会越来越短，直至0结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">josephos_l</span><span class="params">(n, k, m)</span>:</span></span><br><span class="line">    people = list(range(<span class="number">1</span>, n+<span class="number">1</span>))</span><br><span class="line">    i = k<span class="number">-1</span> <span class="comment"># 假设最开始的是k-1下标的退出</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> range(n, <span class="number">0</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="comment"># num表示现有的人数，会随着进行减少；i表示开退出的编号</span></span><br><span class="line">        i = (i + m<span class="number">-1</span>) % num</span><br><span class="line">        print(people.pop(i))</span><br><span class="line"></span><br><span class="line">josephos_l(<span class="number">10</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>得出结果为：<code>6 1 7 3 10 9 2 5 8 4</code></p><p>该算法的复杂度是 $O(n^2)$。外出循环体执行n次；内层的pop操作也是需要线性的时间，它的复杂度是n。</p><h2 id="基于循环单链表的解法"><a href="#基于循环单链表的解法" class="headerlink" title="基于循环单链表的解法"></a>基于循环单链表的解法</h2><p>采用循环单链表来实现，顺序报数，可以认为是沿着结点的next引用一直向后，退出后，就删除该结点。</p><p>实现步骤：</p><ol><li>创建一个长度为n的链表，</li><li>循环链表，并删除确定的结点。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Josephos</span><span class="params">(SingleCycleLinkList)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="comment"># 重写一下尾部添加的方法</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">            node.next = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            node.next = self._head</span><br><span class="line">            self._rear.next = node</span><br><span class="line">        self._rear = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">turn</span><span class="params">(self, m)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(m):</span><br><span class="line">            self._rear = self._rear.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span>:</span></span><br><span class="line">        node = self._rear.next</span><br><span class="line">        <span class="keyword">if</span> self._rear.next == self._rear:</span><br><span class="line">            self._rear = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self._rear.next = self._rear.next.next</span><br><span class="line">        <span class="keyword">return</span> node.elem</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, n, k, m)</span>:</span></span><br><span class="line">        <span class="comment"># 创建长度为n的链表</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">            self.append(i)</span><br><span class="line"></span><br><span class="line">        self.turn(k<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">while</span> self._rear:</span><br><span class="line">            self.turn(m<span class="number">-1</span>)</span><br><span class="line">            print(self.pop())</span><br></pre></td></tr></table></figure><p>执行后返回的结果为：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">josephos_link = Josephos()</span><br><span class="line">josephos_link.run(<span class="number">10</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>结果为：<code>6 1 7 3 10 9 2 5 8 4</code></p><p>它的复杂度可以分为两部分，创建链表的复杂度是$O(n)$，遍历解决问题的复杂度是$O(n*m)$。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表介绍及python的实现</title>
      <link href="/2020/03/31/tech/python/structure/link-intro.html"/>
      <url>/2020/03/31/tech/python/structure/link-intro.html</url>
      
        <content type="html"><![CDATA[<p>链表是线性表的一种实现方式，它的基本想法是：</p><ul><li>将表中的元素分别存放在各个独立的存储区内，存储区又称为结点；</li><li>在表中，可以通过任意结点找到与之相关的下一个结点；</li><li>在前一个结点上，通过链接的方式记录与下一个结点的关联。</li></ul><p>当找到组成表结构的第一个结点时，就能按照顺序找到属于这个表的其它结点。</p><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><img width="80%" src="/images/struct/1.jpg" alt="单链表"><p>如上图(a)所示，单链表的结点是一个二元组，elem保存元素的数据，next表示下一个结点的标识。</p><p>为了掌握一个单链表，需要用一个变量来保存这个表的首结点的引用（或标识），该变量可以称之为<em>表头变量<em>或</em>表头指针</em></p><h3 id="基本链表操作"><a href="#基本链表操作" class="headerlink" title="基本链表操作"></a>基本链表操作</h3><ul><li>创建空链表</li><li>删除链表</li><li>判断链表是否为空</li><li>加入元素<ul><li>首端加入</li><li>尾端加入</li><li>中间加入</li></ul></li><li>删除元素<ul><li>首端删除</li><li>尾端删除</li><li>中间删除</li></ul></li><li>遍历链表</li><li>查找元素</li></ul><p>代码实现，里面实现几个典型方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">    <span class="string">"""结点"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, elem)</span>:</span></span><br><span class="line">        self.elem = elem</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleLinkList</span>:</span></span><br><span class="line">    <span class="string">"""单链表"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_empty</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""链表是否为空"""</span></span><br><span class="line">        <span class="keyword">return</span> self._head == <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">length</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""链表长度"""</span></span><br><span class="line">        <span class="comment"># cur游标，用来移动遍历结点</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="comment"># count记录数量</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> count</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">travel</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""遍历整个链表"""</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            print(cur.elem, end=<span class="string">" "</span>)</span><br><span class="line">            cur = cur.next</span><br><span class="line">        print(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""链表头部添加元素，头插法"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        node.next = self._head</span><br><span class="line">        self._head = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""链表尾部添加元素, 尾插法"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.next != <span class="literal">None</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            cur.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, pos, item)</span>:</span></span><br><span class="line">        <span class="string">"""指定位置添加元素</span></span><br><span class="line"><span class="string">        :param  pos 从0开始</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length()<span class="number">-1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = self._head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; (pos<span class="number">-1</span>):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                pre = pre.next</span><br><span class="line">            <span class="comment"># 当循环退出后，pre指向pos-1位置</span></span><br><span class="line">            node = Node(item)</span><br><span class="line">            node.next = pre.next</span><br><span class="line">            pre.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""删除结点"""</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">                <span class="comment"># 先判断此结点是否是头结点</span></span><br><span class="line">                <span class="comment"># 头结点</span></span><br><span class="line">                <span class="keyword">if</span> cur == self._head:</span><br><span class="line">                    self._head = cur.next</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    pre.next = cur.next</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.next</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""查找结点是否存在"""</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>通过上面的代码，可以说明一下单链表的操作复杂度：</p><ul><li>创建空链表：O(1)</li><li>判断链表是否为空：O(1)</li><li>链表长度：O(n)</li><li>加入元素：<ul><li>首端加入：O(1)</li><li>尾端加入：O(n)</li><li>中间加入：O(n)</li></ul></li><li>删除元素：<ul><li>首端删除：O(1)</li><li>尾端删除：O(n)</li><li>中间删除：O(n)</li></ul></li><li>遍历，查找：O(n)</li></ul><p>上面的单链表实现有个缺点，在尾端操作元素的效率低，只能从表头开始遍历到尾部。<br>在实际中，会添加一个尾部结点的引用，这样在尾部添加，删除元素测复杂度就降为O(1)。</p><h2 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h2><img width="80%" src="/images/struct/2.jpg" alt="循环单链表"><p>单链表的一种变形是循环单链表，它的最后一个结点的next不指向None，而是指向首结点的位置，如上图所示。</p><p>代码实现，部分和单链表类似</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SingleCycleLinkList</span>:</span></span><br><span class="line">    <span class="string">"""单向循环链表"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""链表头部添加元素，头插法"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">            node.next = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.next != self._head:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="comment"># 退出循环，cur指向尾结点</span></span><br><span class="line">            node.next = self._head</span><br><span class="line">            self._head = node</span><br><span class="line">            <span class="comment"># cur.next = node</span></span><br><span class="line">            cur.next = self._head</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""链表尾部添加元素, 尾插法"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">            node.next = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.next != self._head:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="comment"># node.next = cur.next</span></span><br><span class="line">            node.next = self._head</span><br><span class="line">            cur.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, pos, item)</span>:</span></span><br><span class="line">        <span class="string">"""指定位置添加元素</span></span><br><span class="line"><span class="string">        :param  pos 从0开始</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length()<span class="number">-1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pre = self._head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; (pos<span class="number">-1</span>):</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                pre = pre.next</span><br><span class="line">            <span class="comment"># 当循环退出后，pre指向pos-1位置</span></span><br><span class="line">            node = Node(item)</span><br><span class="line">            node.next = pre.next</span><br><span class="line">            pre.next = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""删除结点"""</span></span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        cur = self._head</span><br><span class="line">        pre = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> cur.next != self._head:</span><br><span class="line">            <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">                <span class="comment"># 先判断此结点是否是头结点</span></span><br><span class="line">                <span class="keyword">if</span> cur == self._head:</span><br><span class="line">                    <span class="comment"># 头结点的情况</span></span><br><span class="line">                    <span class="comment"># 找尾结点</span></span><br><span class="line">                    rear = self._head</span><br><span class="line">                    <span class="keyword">while</span> rear.next != self._head:</span><br><span class="line">                        rear = rear.next</span><br><span class="line">                    self._head = cur.next</span><br><span class="line">                    rear.next = self._head</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 中间结点</span></span><br><span class="line">                    pre.next = cur.next</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pre = cur</span><br><span class="line">                cur = cur.next</span><br><span class="line">        <span class="comment"># 退出循环，cur指向尾结点</span></span><br><span class="line">        <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">            <span class="keyword">if</span> cur == self._head:</span><br><span class="line">                <span class="comment"># 链表只有一个结点</span></span><br><span class="line">                self._head = <span class="literal">None</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># pre.next = cur.next</span></span><br><span class="line">                pre.next = self._head</span><br></pre></td></tr></table></figure><p>其它的方法和单链表一样。</p><p>同样的，可以添加一个尾部结点的引用，使得运算量下降。</p><h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><img width="50%" src="/images/struct/3.jpg" alt="带有尾结点引用的双向链表"><p>单链表只有一个方向的链接，从一个方向进行链表的遍历。为了是从两端的插入和删除操作都能高效完成，可以加入另一个方向的链接。如上图所示，就形成了<em>双向链表<em>，或</em>双链表</em></p><p>双向链表的结点除了next引用，还需要一个prev引用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""结点"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        self.elem = item</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line">        self.prev = <span class="literal">None</span></span><br></pre></td></tr></table></figure><p>双向链表的一些操作要做一些修改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkList</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""双链表"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self._head = <span class="literal">None</span></span><br><span class="line">        self._rear = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""链表头部添加元素，头插法"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._rear = node</span><br><span class="line"></span><br><span class="line">        node.next = self._head</span><br><span class="line">        self._head = node</span><br><span class="line">        node.next.prev = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">append</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""链表尾部添加元素, 尾插法"""</span></span><br><span class="line">        node = Node(item)</span><br><span class="line">        <span class="keyword">if</span> self.is_empty():</span><br><span class="line">            self._head = node</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head</span><br><span class="line">            <span class="keyword">while</span> cur.next != <span class="literal">None</span>:</span><br><span class="line">                cur = cur.next</span><br><span class="line">            cur.next = node</span><br><span class="line">            node.prev = cur</span><br><span class="line">        self._rear = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, pos, item)</span>:</span></span><br><span class="line">        <span class="string">"""指定位置添加元素</span></span><br><span class="line"><span class="string">        :param  pos 从0开始</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> pos &lt;= <span class="number">0</span>:</span><br><span class="line">            self.add(item)</span><br><span class="line">        <span class="keyword">elif</span> pos &gt; (self.length()<span class="number">-1</span>):</span><br><span class="line">            self.append(item)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            cur = self._head</span><br><span class="line">            count = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> count &lt; pos:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">                cur = cur.next</span><br><span class="line">            <span class="comment"># 当循环退出后，cur指向pos位置</span></span><br><span class="line">            node = Node(item)</span><br><span class="line">            node.next = cur</span><br><span class="line">            node.prev = cur.prev</span><br><span class="line">            cur.prev.next = node</span><br><span class="line">            cur.prev = node</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">remove</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="string">"""删除节点"""</span></span><br><span class="line">        cur = self._head</span><br><span class="line">        <span class="keyword">while</span> cur != <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">if</span> cur.elem == item:</span><br><span class="line">                <span class="comment"># 先判断此结点是否是头节点</span></span><br><span class="line">                <span class="comment"># 头节点</span></span><br><span class="line">                <span class="keyword">if</span> cur == self._head:</span><br><span class="line">                    self._head = cur.next</span><br><span class="line">                    <span class="keyword">if</span> cur.next:</span><br><span class="line">                        <span class="comment"># 判断链表是否只有一个结点</span></span><br><span class="line">                        cur.next.prev = <span class="literal">None</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        self._rear = <span class="literal">None</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    cur.prev.next = cur.next</span><br><span class="line">                    <span class="keyword">if</span> cur.next:</span><br><span class="line">                        cur.next.prev = cur.prev</span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        self._rear = cur.prev</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                cur = cur.next</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>链接表的优点：</p><ul><li>由于表结构是由链接起来的结点形成，表结构很容易修改；</li><li>整个表由一些小的存储块构成，比较容易安排和管理，不需要连续的内存块。</li></ul><p>缺点：</p><ul><li>链表元素的定位需要线性的时间，比列表效率底；</li><li>链表的存储代价会比列表高。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在大数据下应用机器学习算法</title>
      <link href="/2020/02/09/tech/machine_learning/learn_large_datasets.html"/>
      <url>/2020/02/09/tech/machine_learning/learn_large_datasets.html</url>
      
        <content type="html"><![CDATA[<p>大量的数据对机器学习算法的研究很有帮助，当我们直到算法有较高的方差（variance）时，增加m会有助于改善算法。<br>但是当m很大时，比如m=100,000,000时，在这种情况下，在计算时就会消耗更多的成本。</p><h3 id="使用随机梯度下降或小批量梯度下降"><a href="#使用随机梯度下降或小批量梯度下降" class="headerlink" title="使用随机梯度下降或小批量梯度下降"></a>使用随机梯度下降或小批量梯度下降</h3><p>在使用批量梯度下降时，假设有1亿的样本，就要对1亿的样本求和，这样的成本太高了，使用随机梯度下降，每次对一个样本，或者小批量梯度下降，对几十个样本求和，可以大大减小计算，加快速度。</p><h3 id="映射约减（Map-Reduce），并行化处理"><a href="#映射约减（Map-Reduce），并行化处理" class="headerlink" title="映射约减（Map Reduce），并行化处理"></a>映射约减（Map Reduce），并行化处理</h3><p>在设计网站时，当用户量增加时，一台服务器不足以承载这么多用户，我们会增加服务器，用负载均衡来解决。<br>同样的在解决大量数据的机器学习问题上，一台机器有时也不足以完成任务。</p><p>以线性回归为例，假设有400个样本，它的批量梯度下降的内部迭代为：<br>$$ \theta_j:=\theta_j−\alpha \left( \frac{1}{400} \sum_{i=1}^{400}(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)} \right) $$</p><p>同时有四台机器，将样本分为四份：<br>机器1： $x^{(1)},x^{(2)},…,x^{(100)}$；<br>机器2： $x^{(101)},x^{(102)},…,x^{(200)}$；<br>机器3： $x^{(201)},x^{(202)},…,x^{(300)}$；<br>机器4： $x^{(301)},x^{(302)},…,x^{(400)}$。</p><p>分别将梯度下降大括号里的求和分成4在四个机器上运算：<br>机器1：$temp_j^{(1)}=\sum_{i=1}^{100}(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}$<br>机器2：$temp_j^{(2)}=\sum_{i=1}^{200}(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}$<br>机器3：$temp_j^{(3)}=\sum_{i=1}^{300}(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}$<br>机器4：$temp_j^{(4)}=\sum_{i=1}^{400}(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}$</p><p>然后将4份数据汇总到另一台机器上做求和运算。<br>$$\theta_j := \theta_j - \alpha \dfrac{1}{400}(temp_j^{(1)} + temp_j^{(2)} + temp_j^{(3)} + temp_j^{(4)})$$<br>这样能将原来的速度提升解决4倍，这是一个很大的提升。</p><p>将类似的求和运算分摊到多个机器上，它就是映射约减。<br>在线性回归和逻辑回归问题上很容易实现，而在神经网络上，也可以在多台机器上运行正向传播和反向传播，然后将结果汇总到主服务器上，加快运行速度。</p><p>处理使用多台计算机实现并行化，一台多核处理器的计算机也能实现类似的效果。</p><h3 id="在线学习（Online-Learning）"><a href="#在线学习（Online-Learning）" class="headerlink" title="在线学习（Online Learning）"></a>在线学习（Online Learning）</h3><p>在一个大型网站中，有不断的用户访问，数据源保持不断，这时就可以使用在线学习系统在解决一些问题。</p><p>与通常的机器学习问题使用固定的数据集来训练算法不同，在线学习每次处理单独的样本，在利用单独的样本更新完参数$\theta$，改善算法性能后就丢弃该样本。这与随机梯度下降的处理方式有类似之处，区别就是在线学习不会使用一个固定的数据集。</p><p>算法过程：<br>一直迭代下去 {<br>　　获取单独的数据$(x,y)$;<br>　　通过该样本更新$\theta$ {<br>　　　　$ \theta_j:=\theta_j−\alpha (h_\theta(x)-y)x_j $<br>　　}<br>}</p><p>这种做法的优点在于可以减少数据的存储空间和计算速度，在大型网站中，数据是海量的，要集中处理时占用的硬盘和内存空间非常大，也非常耗时。而当有连续的数据时，就可以使用在线学习来处理。<br>另一个优点是可以适应业务不同发展的需求和不同时段用户的需求，因为参数$\theta$会随着输入样本的不同而改变。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小批量梯度下降算法</title>
      <link href="/2020/02/08/tech/machine_learning/mini_batch_gradient_descent.html"/>
      <url>/2020/02/08/tech/machine_learning/mini_batch_gradient_descent.html</url>
      
        <content type="html"><![CDATA[<p>批量梯度下降是每一次迭代中对所有样本求和后求梯度项，随机梯度下降是对每一个样本求梯度项，小批量梯度下降介于两者之间。</p><p>小批量梯度下降取的样本数一般在2-100之间：<br>例如样本总数m=1000，每次取样本b=10:</p><p>重复 {<br> 　　for i = 1,11,21,…,991 {<br>　　　　$ \theta_j:=\theta_j−\alpha \frac{1}{10}\sum_{k=i}^{i+9}(h_\theta(x^{(k)})-y^{(k)})x_j^{(k)} $<br>　　}<br>}</p><p>一次计算多个样本的优点是，多个样本能够以矢量化的方式进行，能够多个样本并行化处理，又不至于对所有样本求和那个耗费计算成本。<br>在某些情况下，小批量梯度下降的速度会优于随机梯度下降，但是在选择小批量样本数量b时会耗费一些时间。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>随机梯度下降算法</title>
      <link href="/2020/02/08/tech/machine_learning/stochastic_gradient_descent.html"/>
      <url>/2020/02/08/tech/machine_learning/stochastic_gradient_descent.html</url>
      
        <content type="html"><![CDATA[<p>以线性回归为例：<br>预测函数为：<br>$$ h_\theta(x) = \theta^Tx $$<br>代价函数：<br>$$ J_{train}(\theta) = \frac{1}{2m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})^2 $$</p><p>重复：{<br>　　$ \theta_j:=\theta_j−\alpha \left( \frac{1}{m}\sum_{i=1}^m(h_\theta(x^{(i)})-y^{(i)})x_j^{(i)} \right) $<br>}</p><p>当数据量过大时，梯度下降的算法会变得很慢，因为要对所有的数据进行求和。因为每次重复梯度下降都是所有数据全部求和，所以梯度下降算法又称之为<strong>批量梯度下降（Batch Gradient Descent）</strong></p><h2 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h2><p>随机梯度下降在每一次迭代中，不用考虑全部的样本，只需要考虑一个训练样本。</p><p>针对一个样本，它的代价函数：<br>$$ cost(\theta, (x^{(i)},y^{(i)})) = \frac{1}{2}(h_\theta(x^{(i)})-y^{(i)})^2 $$<br>而针对所有样本的代价函数可以看作是对每个样本代价函数的平均：<br>$$ J_{train}(\theta) = \frac{1}{m}\sum_{i=1}^m cost(\theta, (x^{(i)},y^{(i)})) $$</p><p>随机梯度下降算法如下：<br>第一步，先随机打乱训练集样本。<br>第二步，进行梯度下降：<br>重复 {<br>　　循环所有样本 for i=1,2,3,…,m {<br>　　　　$ \theta_j:=\theta_j−\alpha (h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}  $<br>　　}<br>}</p><p>一开始随机打乱数据是为了对样本集的访问是随机的，会让梯度下降的速度快一点。</p><p>该算法一次训练一个样本，对它的代价函数进行一小步梯度下降，修改参数$\theta$，使得它对该样本的拟合会好一点；然后再对下一个样本进行运算，直到扫描完所有的训练样本，最后外部在迭代这个过程。</p><p>跟批量梯度下降算法不同的是，随机梯度下降不需要等到所有样本求和来得到梯度项，而是在对每个样本就可以求出梯度项，在对每个样本扫描的过程中就已经在优化参数了。</p><p>在梯度下降过程中，批量梯度下降的过程趋向于一条直线，直接收敛到全局最小值；而随机梯度下降不太可能收敛到全局最小值，而是随机地在其周围震荡，但通常会很接近最小值。</p><p>随机梯度下降通常需要经过1-10次外部循环才能接近全局最小值。</p><h2 id="判断收敛"><a href="#判断收敛" class="headerlink" title="判断收敛"></a>判断收敛</h2><p>在批量梯度下降中，要判断是否收敛，需要在每一次迭代算法后计算$J_{train}$的值，根据值的变化来判断收敛。<br>在执行随机梯度下降时，不需要计算所有的样本的代价函数，只用在对某个样本进行梯度下降前计算该样本的代价函数$cost(\theta, (x^{(i)},y^{(i)})) $，为了判断是否收敛，可以计算多次迭代后$cost(\theta, (x^{(i)},y^{(i)})) $的平均值，例如1000次迭代，在每次更新$\theta$前，计算最后1000次的的cost的平均值。</p><p>选择每隔多少次计算成本函数对梯度下降的过程也有影响：<br><img width="40%" src="/images/ml44.png" alt=""><br>上图中蓝色曲线是每1000次迭代，红色的是每隔5000次迭代。<br>因为随机梯度下降时会出现震荡，当迭代次数少时发现下降的曲线起伏很多，而迭代次数变大时，曲线就会变得平滑许多。缺点是每隔5000个计算，会增加计算成本。</p><p>增加迭代次数可以判断算法是否正确：<br><img width="40%" src="/images/ml45.png" alt=""><br>上图蓝色的是1000个迭代次数，通过这条曲线，不能很好的判断成本函数是否在下降，这时就需要添加迭代次数，当增加到5000次，则可以通过平滑的曲线判断，当下滑曲线是红色的时，说明算法是有效的，代价函数值在下降；当是紫色的曲线时，可以看到是一个平坦的线，这时判断算法可能出现问题了。</p><p>在随机梯度下降中，学习率$\alpha$也会影响算法，当学习率减小时，下降曲线的震荡就会变小，而且会收敛到一个更好的解：<br><img width="40%" src="/images/ml46.png" alt=""><br>图中红色的曲线时学习率更小的一个，可以看到震荡变小，且下降到一个更小的值。</p><p>当看到曲线是上升的时候，可以尝试减小学习率看看效果。</p><p>在随机梯度下降中，如果想要收敛到全剧最小值，需要随着时间的变化减小学习率$\alpha$的值：<br>$$ \alpha = \frac{const1}{iterNumber + const2} $$<br>学习率等于一个常数除以迭代次数加另一个常数，随着迭代次数增大，学习率会减小；但这会造成常数1和常数2的选择问题。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>推荐系统和协同过滤算法</title>
      <link href="/2020/02/08/tech/machine_learning/recommender_system.html"/>
      <url>/2020/02/08/tech/machine_learning/recommender_system.html</url>
      
        <content type="html"><![CDATA[<p>推荐系统是目前非常流行的机器学习应用。<br>特征值对机器学习是非常重要的，而对特征值的选择会直接影响到算法的好坏，推荐系统能够自动帮助学习一些优良的特征值，帮助更好的实现算法。</p><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>以电影评分和推荐电影为例</p><p>先定义几个变量：<br>$n_u$=用户人数<br>$n_m$=电影数量<br>$r(i,j)=1$ 表示用户$j$评价了电影$i$<br>$y(i,j)$= 用户$j$对电影$i$的评分，只有在$r(i,j)=1$的时候才会有</p><p>首先电影评分分为0-5星。我们有4个用户和5部电影：</p><table><thead><tr><th align="left">电影</th><th align="left">Alice(1)</th><th align="left">Bob(2)</th><th align="left">Carol(3)</th><th align="left">Dave(4)</th></tr></thead><tbody><tr><td align="left">Love at last(1)</td><td align="left">5</td><td align="left">5</td><td align="left">0</td><td align="left">0</td></tr><tr><td align="left">Romance forever(2)</td><td align="left">5</td><td align="left">?</td><td align="left">?</td><td align="left">0</td></tr><tr><td align="left">Cute puppies of love(3)</td><td align="left">?</td><td align="left">4</td><td align="left">0</td><td align="left">?</td></tr><tr><td align="left">Nonstop car chases(4)</td><td align="left">0</td><td align="left">0</td><td align="left">5</td><td align="left">4</td></tr><tr><td align="left">Swords vs. karate(5)</td><td align="left">0</td><td align="left">0</td><td align="left">5</td><td align="left">?</td></tr></tbody></table><p>上表中$n_u=4,n_m=5$，电影$i=1,2,3$为爱情片，$i=4,5$为动作片，打问号的表示没有评分。</p><p>上面的表格中可以看到Alice和Bob对爱情电影评分很高，对动作片评分很低，Carol和Dave则相反。</p><p>现在给每部电影添加两个特征值：$x_1$表示浪漫指数，$x_2$表示动作指数：</p><table><thead><tr><th>电影</th><th>Alice(1)</th><th>Bob(2)</th><th>Carol(3)</th><th>Dave(4)</th><th>$x_1$(浪漫)</th><th>$x_2$(动作)</th></tr></thead><tbody><tr><td>Love at last(1)</td><td>5</td><td>5</td><td>0</td><td>0</td><td>0.9</td><td>0</td></tr><tr><td>Romance forever(2)</td><td>5</td><td>?</td><td>?</td><td>0</td><td>1</td><td>0.01</td></tr><tr><td>Cute puppies of love(3)</td><td>?</td><td>4</td><td>0</td><td>?</td><td>0.99</td><td>0</td></tr><tr><td>Nonstop car chases(4)</td><td>0</td><td>0</td><td>5</td><td>4</td><td>0.1</td><td>1</td></tr><tr><td>Swords vs. karate(5)</td><td>0</td><td>0</td><td>5</td><td>?</td><td>0</td><td>1</td></tr></tbody></table><p>用矩阵的形式来表示每个电影的特征值:<br>$ x^{(1)}=\left[ \begin{matrix} 0 \\ 0.9 \\ 0  \end{matrix} \right],<br>  x^{(2)}=\left[ \begin{matrix} 0 \\ 1 \\ 0.01  \end{matrix} \right],<br>  x^{(3)}=\left[ \begin{matrix} 0 \\ 0.99 \\ 0  \end{matrix} \right],<br>  x^{(4)}=\left[ \begin{matrix} 0 \\ 0.1 \\ 1  \end{matrix} \right],<br>  x^{(5)}=\left[ \begin{matrix} 0 \\ 0 \\ 1  \end{matrix} \right] $</p><p>想要预测问号的值，这是一个线性回归的问题。<br>对于用户$j$来说，要预测他对电影$i$的评分值，应用线性回归的模型，当通过算法获得来一个参数$\theta^{(j)}$，通过这个参数，计算$(\theta^{(j)})^T \cdot x^{(i)}$，即可预测出评分值。</p><p>假设要预测用户1对电影3的评分：用户1的参数$\theta^{(1)} = \left[ \begin{matrix} 0 \\ 5 \\ 0  \end{matrix} \right]$，计算他对电影3的评分：$(\theta^{(1)})^T \cdot x^{(3)} = 4.95$，即可预测他的评分为5星。</p><p>下面就是对每个用户，应用线性回归模型即可预测出他们对电影的评分。</p><p>用公式来表示一下：<br>对一个用户$j$，他的线性回归公式：<br>$$ min_{\theta^{(j)}} = \frac{1}{2m^{(j)}} \sum_{i:r(i,j)=1}((\theta^{(j)})^Tx^{(i)} - y^{(i,j)})^2 + \frac{\lambda}{2m^{(j)}}\sum_{k=1}^n(\theta_k^{(j)})^2 $$<br>这就是常用的线性回归模型。</p><p>下面在公式上约去常数$m^{(j)}$项，这并不影响最小化代价函数：<br>$$ min_{\theta^{(j)}} = \frac{1}{2} \sum_{i:r(i,j)=1}((\theta^{(j)})^Tx^{(i)} - y^{(i,j)})^2 + \frac{\lambda}{2}\sum_{k=1}^n(\theta_k^{(j)})^2 $$</p><p>然后计算所有用户加在一起的代价函数公式：<br>$$ min_{\theta^{(1)},…,\theta^{(n_u)}} = \frac{1}{2} \sum_{j=1}^{n_u} \sum_{i:r(i,j)=1}((\theta^{(j)})^Tx^{(i)} - y^{(i,j)})^2 + \frac{\lambda}{2}\sum_{j=1}^{n_u}\sum_{k=1}^n(\theta_k^{(j)})^2 $$</p><p>对该公式应用梯度下降求最小值：<br>当$k=0$：<br>$$ \theta_k^{(j)} := \theta_k^{(j)} - \alpha \left(  \sum_{i:r(i,j)=1}((\theta^{(j)})^Tx^{(i)} - y^{(i,j)})x_k^{(i)} \right) $$</p><p>当$k \not= 0$：<br>$$ \theta_k^{(j)} := \theta_k^{(j)} - \alpha \left(  \sum_{i:r(i,j)=1}((\theta^{(j)})^Tx^{(i)} - y^{(i,j)})x_k^{(i)} + \lambda\theta_k^{(j)} \right) $$</p><h2 id="协同过滤（Collaborative-Filtering）"><a href="#协同过滤（Collaborative-Filtering）" class="headerlink" title="协同过滤（Collaborative Filtering）"></a>协同过滤（Collaborative Filtering）</h2><p>在一个电影网站中，很难去获得一部电影的浪漫指数和动作指数是多少，这个参数很难人为的去判断。为了解决这个问题，可以使用特征寻找器（<em>feature finders.</em>）</p><p>现在我们不知道电影的特征值是多少,$ x^{(i)}=\left[ \begin{matrix} 0 \\ ? \\ ?  \end{matrix} \right]$，但是我们通过某种途径得知用户对各种类型电影的喜爱程度，是喜欢动作电影还是喜欢爱情电影。$\theta_1$表示喜欢爱情电影的参数，$\theta_2$表示喜欢动作电影的参数</p><table><thead><tr><th>电影</th><th>Alice(1)</th><th>Bob(2)</th><th>Carol(3)</th><th>Dave(4)</th></tr></thead><tbody><tr><td>Love at last(1)</td><td>5</td><td>5</td><td>0</td><td>0</td></tr><tr><td>Romance forever(2)</td><td>5</td><td>?</td><td>?</td><td>0</td></tr><tr><td>Cute puppies of love(3)</td><td>?</td><td>4</td><td>0</td><td>?</td></tr><tr><td>Nonstop car chases(4)</td><td>0</td><td>0</td><td>5</td><td>4</td></tr><tr><td>Swords vs. karate(5)</td><td>0</td><td>0</td><td>5</td><td>?</td></tr><tr><td>$\theta_1$(浪漫)</td><td>5</td><td>5</td><td>0</td><td>0</td></tr><tr><td>$\theta_2$(动作)</td><td>0</td><td>0</td><td>5</td><td>5</td></tr></tbody></table><p>用矩阵的形式来表示每个用户的关于电影特征的参数值:<br>$ \theta^{(1)}=\left[ \begin{matrix} 0 \\ 5 \\ 0  \end{matrix} \right],<br>  \theta^{(2)}=\left[ \begin{matrix} 0 \\ 5 \\ 0  \end{matrix} \right],<br>  \theta^{(3)}=\left[ \begin{matrix} 0 \\ 0 \\ 5  \end{matrix} \right],<br>  \theta^{(4)}=\left[ \begin{matrix} 0 \\ 0 \\ 5  \end{matrix} \right]$</p><p>对一个电影$i$，要获得它的特征值$ x^{(i)}=\left[ \begin{matrix} ? \\ ? \\ ?  \end{matrix} \right]$，也可以看作一个线性回归问题。<br>同样的预测函数可以写作：$h = (\theta^{(j)})^T \cdot x^{(i)} = (x^{(i)})^T \cdot \theta^{(j)} $</p><p>那么对一个电影$i$，它的代价函数则是：<br>$$ min_{x^{(i)}} = \frac{1}{2} \sum_{j:r(i,j)=1}((\theta^{(j)})^Tx^{(i)} - y^{(i,j)})^2 + \frac{\lambda}{2}\sum_{k=1}^n(x_k^{(i)})^2 $$</p><p>然后计算所有电影加在一起的代价函数公式：<br>$$ min_{x^{(1)},…,x^{(n_m)}} = \frac{1}{2}  \sum_{i=1}^{n_m} \sum_{j:r(i,j)=1}((\theta^{(j)})^Tx^{(i)} - y^{(i,j)})^2 + \frac{\lambda}{2}\sum_{i=1}^{n_m}\sum_{k=1}^n(x_k^{(i)})^2 $$</p><p>同样的应用梯度下降来最小化代价函数。</p><p>通过上面的说明：<br>当我们有电影的特征值$x$时，可以预测出用户的属性$\theta$；当有用户的属性$\theta$可以预测出电影的特征值$x$，这样交替运行，就可以使系统更加完善。这就是基本的协同过滤算法。</p><h2 id="算法公式"><a href="#算法公式" class="headerlink" title="算法公式"></a>算法公式</h2><p>将上面的两个式子合并，同时最小化特征值和参数：<br>$$ J(x,\theta)=\frac{1}{2} \sum_{(i,j):r(i,j)=1}((\theta^{(j)})^Tx^{(i)} - y^{(i,j)})^2 +  \frac{\lambda}{2}\sum_{i=1}^{n_m}\sum_{k=1}^{n}(x_k^{(i)})^2  +  \frac{\lambda}{2}\sum_{j=1}^{n_u}\sum_{k=1}^{n}(\theta_k^{(j)})^2  $$</p><p><em>PS：该式子中的$x$和$\theta$都是n维的向量，它们的偏差单元$x_0$和$\theta_0$都被移除了。</em></p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><ol><li>随机初始化$x^{(1)},…,x^{(n_m)},\theta^{(1)},…,\theta^{(n_u)}$一个很小的值。</li><li>使用梯度下降算法来最小化代价函数$J$。</li></ol><p>$$ x_k^{(i)} :=  x_k^{(i)} - \alpha \frac{\partial}{\partial x_k^{(i)} }J(x,\theta) := x_k^{(i)} - \alpha \left(  \sum_{j:r(i,j)=1}((\theta^{(j)})^Tx^{(i)} - y^{(i,j)})x_k^{(i)} + \lambda x_k^{(i)} \right) $$</p><p>$$ \theta_k^{(j)} :=  x_k^{(i)} - \alpha \frac{\partial}{\partial \theta_k^{(j)} }J(x,\theta) := \theta_k^{(j)} - \alpha \left(  \sum_{i:r(i,j)=1}((\theta^{(j)})^Tx^{(i)} - y^{(i,j)})x_k^{(i)} + \lambda\theta_k^{(j)} \right) $$</p><p>这样下来可以对用户尚未评分的电影，通过预测评分大小来推荐电影。<br>对用户已评分的电影，可以根据评分和用户的属性参数来获得更好的电影特征值。</p><h2 id="其他应用"><a href="#其他应用" class="headerlink" title="其他应用"></a>其他应用</h2><p>协同过滤算法还可以用来推荐相似的产品，假如当用户看了一个电影$i$之后，可以判断其他电影和该电影的相似度来推荐，相似度的公式为$||x^{(i)} - x^{(j)}||$，当该式子越小时相似度越高，就可以据此来推荐电影。</p><h2 id="其他事项"><a href="#其他事项" class="headerlink" title="其他事项"></a>其他事项</h2><p>在上述电影网站中，除了上面的四个用户，又有一个新用户加入，他没有对任何电影评分，要预测他对某一个电影的评分，通常采用的方法取评过该电影评分的平均值$\mu$来当作预测值。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 非监督学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常检测（Anomaly Detection）</title>
      <link href="/2020/02/07/tech/machine_learning/anomaly_detection.html"/>
      <url>/2020/02/07/tech/machine_learning/anomaly_detection.html</url>
      
        <content type="html"><![CDATA[<p>异常检测（Anomaly Detection）是机器学习算法的一个常见应用。它主要用于非监督学习，但又类似一些监督学习问题。</p><p>异常检测常用在对网站异常用户的检测；还有在工程上一些零件，设备异常的检查；还有机房异常机器的监控等等</p><h2 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h2><p>假设有数据集$x^{(1)},x^{(2)},…,x^{(m)}$，当又有一个新的测试样本$x_{test}$；<br>想要知道这个新样本是否是异常的；<br>首先对x的分布概率建模p(x) ，用来说明这个例子不是异常的概率；<br>然后定一个阈值$\epsilon$，当$p(x)&lt;\epsilon$时说明是异常的。</p><img width="40%" src="/images/ml_33.jpg" alt=""><p>当出现在高概率分布的区域时，说明该例子时正常的；当出现在低概率的区域时，说明是异常的。</p><h2 id="高斯分布"><a href="#高斯分布" class="headerlink" title="高斯分布"></a>高斯分布</h2><p>高斯分布又被称之为正态分布，曲线呈钟型，两头低，中间高，左右对称因其曲线呈钟形，因此人们又经常称之为钟形曲线</p><img width="40%" src="/images/ml_34.jpg" alt=""><p>假设x是一个实数随机变量，如果它的概率分布为高斯分布，定义几个变量：<br>$\mu$=平均值<br>$\sigma$=标准差<br>$\sigma^2$=方差<br>那么x的概率分布可以用公式来表示：<br>$$x \sim \mathcal{N}(\mu, \sigma^2)$$</p><p>其平均值$\mu$决定了其位置，其标准差$σ\sigma$决定了分布的幅度</p><p>完整的高斯分布的概率公式为：<br>$$\large p(x;\mu,\sigma^2) = \dfrac{1}{\sigma\sqrt{(2\pi)}}exp(-\dfrac{1}{2}(\dfrac{x - \mu}{\sigma})^2)$$</p><p>当参数平均值$\mu$和标准差$\sigma$变化时：</p><div style="display:flex;"><img  src="/images/ml35.jpg" alt=""><img  src="/images/ml36.jpg" alt=""><img  src="/images/ml37.jpg" alt=""><img  src="/images/ml38.jpg" alt=""></div><p>关于平均值和方差的求解：<br>$$\mu=\frac{1}{m}\sum_{i=1}^m x^{(i)}, \sigma^2=\frac{1}{m}\sum_{i=1}^m (x^{(i)} - \mu)^2 $$</p><h2 id="异常检测算法"><a href="#异常检测算法" class="headerlink" title="异常检测算法"></a>异常检测算法</h2><p>在一个异常检测的例子中，有m个训练样本，每个样本的特征值数量有n个，那么某个样本的分布概率模型p(x)就可以用样本的每个特征值的概率分布来计算：<br>$$p(x) = p(x_1;\mu_1,\sigma_1^2)p(x_2;\mu_2,\sigma^2_2)\cdots p(x_n;\mu_n,\sigma^2_n)$$<br>上面的式子可以用更简洁的方式来表达<br>$$p(x) = \displaystyle \prod^n_{j=1} p(x_j;\mu_j,\sigma_j^2)$$</p><p>总计一下，异常检测的过程：</p><ol><li>在训练样本中提取觉得可能会导致异常的特征值$x_i$</li><li>计算训练样本的参数$\mu_1,…,\mu_n,\sigma_1^2,…,\sigma_n^2$<br>$$\mu_j=\frac{1}{m}\sum_{i=1}^m x_j^{(i)}, \sigma_j^2=\frac{1}{m}\sum_{i=1}^m (x_j^{(i)} - \mu_j)^2 $$</li><li>当有一个新的测试样本$x_{test}$时，计算它的分布概率：<br>$$p(x) = \displaystyle \prod^n_{j=1} p(x_j;\mu_j,\sigma_j^2) = \prod\limits^n_{j=1} \dfrac{1}{\sqrt{2\pi}\sigma_j}exp(-\dfrac{(x_j - \mu_j)^2}{2\sigma^2_j})$$</li><li>和阈值ϵ比较，当 p(x)&lt;ϵ 时，则为异常。</li></ol><h2 id="评估异常检测算法"><a href="#评估异常检测算法" class="headerlink" title="评估异常检测算法"></a>评估异常检测算法</h2><p>如何评估一个异常检测算法，以及如何开发一个关于异常检测的应用：</p><p>首先，在获取到的一堆数据中，取一大部分正常的（可能包含少部分异常）的数据用于训练集来训练分布概率公式p(x)。</p><p>然后，在交叉验证和测试集中使用包含正常和一定比例异常的数据，来通过查准率和召回率，以及F值公式来评价一个算法。</p><p><strong>举个例子</strong></p><p>假设有：</p><ul><li>10000个正常的样本</li><li>20个异常的样本</li></ul><p>下面分割一下训练集，交叉验证集和测试集：</p><ul><li>训练集：6000个正常的</li><li>交叉验证集：2000个正常的+10个异常的</li><li>测试集：2000个正常的+10个异常的</li></ul><p>在训练集上训练出概率分布函数p(x)<br>在交叉验证集上，预测y：</p><p>$y = \begin{cases} 1 　　 p(x) &lt; \epsilon \\  0 　　 p(x) \geq \epsilon  \end{cases}$</p><p>下面通过和真实标签的比较，可以计算出 查准率（Precision）和召回率（Recall），然后通过F值公式来得到一个数值。</p><p>我们可以通过改变不同的阈值$\epsilon$从而得到不同的评价系数来选取一个最佳的阈值。<br>当得到的评价系数不佳时，也可以通过改变特征值的种类和数量来获取理想的评价系数</p><h2 id="特征值的选择"><a href="#特征值的选择" class="headerlink" title="特征值的选择"></a>特征值的选择</h2><p>在使用异常检测时，对性能影响最大的因素是特征值的选择。</p><p>首先要对特征向量使用高斯分布来建模，通常情况下，我们得到的原始数据并没有呈现高斯分布，例如这种：</p><img width="40%" src="/images/ml39.jpg" alt=""><p>有几种方法可以实现：</p><ul><li>log(x)</li><li>log(x+c)</li><li>$\sqrt{x}$</li><li>$x^{\frac{1}{3}}$</li></ul><p>通过上述办法，可以将数据转换成高斯分布的形式。</p><p>异常检测有点类似监督学习中的二元分类问题。<br>我们的目标是使得p(x)对于正常的数据来说是大的，而对于异常的数据来说是很小的，而在异常检测中一个常见的问题是最终我们的到的p(x)对于正常和异常的都很大。<br>在这种情况下需要观察一下交叉验证集中的异常示例，尝试找出能更好区分数据的新特性。</p><p><strong>例子</strong></p><p>例如，有一个关于机房机器的样本示例，开始收集的样本示例中包含的特征值有关于cpu负载和网络流量的。</p><p>cpu负载和网络流量是呈线性关系的，当网络流量变大时，cpu也会相应增大。</p><p>现在有一个异常的示例是网络流量不大，cpu确负载很大。假如在只有这两个特征值的情况下运行异常检测算法得出的p(x)，可能就效果不佳。这时可以添加一个特征值，是流量和cpu的比例关系，这样就约束来上述的异常示例，通过这三个特征值得到的异常检测算法可能就会好一点。</p><h2 id="异常检测和监督学习的区别"><a href="#异常检测和监督学习的区别" class="headerlink" title="异常检测和监督学习的区别"></a>异常检测和监督学习的区别</h2><p>异常检测一般用于：<br>样本中$y=1$的数量非常少（0-50个），而$y=0$的非常多。这样由于样本数量的过少，达不到良好的训练效果，而在异常检测中确能够表现良好。<br>还有就是导致$y=1$的情况非常多，且有不可预见性。</p><p>监督学习一般用于：<br>样本中$y=1$和$y=0$的数量都非常多。这样就有足够的样本数量去训练算法。</p><h2 id="多元高斯分布（Multivariate-Gaussian-Distribution）"><a href="#多元高斯分布（Multivariate-Gaussian-Distribution）" class="headerlink" title="多元高斯分布（Multivariate Gaussian Distribution）"></a>多元高斯分布（Multivariate Gaussian Distribution）</h2><p>多元高斯分布是异常检测的一种推广，它可能会检测到更多的异常。</p><p>在原始高斯分布中，模型p(x)的搭建是通过分别计算$p(x_1),p(x_2),…,p(x_n)$来完成的，而多元高斯分布则是一步到位，直接计算出模型：<br>$$p(x;\mu,\Sigma) = \dfrac{1}{(2\pi)^{n/2} |\Sigma|^{1/2}} exp(-1/2(x-\mu)^T\Sigma^{-1}(x-\mu))$$<br><em>PS：$\Sigma$是一个协方差矩阵。</em></p><p>通过改变$\mu$和$\Sigma$可以得到不同的多元高斯分布图：</p><div style="display:flex;"><img  src="/images/ml40.jpg" alt=""><img  src="/images/ml41.jpg" alt=""><img  src="/images/ml42.jpg" alt=""><img  src="/images/ml43.jpg" alt=""></div><p>原始高斯分布模型，它的多个特征值之间的关系是轴对齐的（axis-aligned），两个或多个高斯分布之间没有相关性。<br>而多元高斯分布能够自动捕获x的不同特征之间的相关性。因此它在图像上会现实椭圆或有斜率的椭圆。</p><p>在平常的使用中，一般是使用原始高斯分布模型的，因为它的计算成本比较低。<br>在多元高斯分布中，因为要计算多个特征值之间的相关性，导致计算会慢很多，而且当特征值很多是，协方差矩阵就会很大，计算它的逆矩阵就会花费很多时间。</p><h3 id="何时使用多元高斯分布"><a href="#何时使用多元高斯分布" class="headerlink" title="何时使用多元高斯分布"></a>何时使用多元高斯分布</h3><p>要保证样本数量m大于特征值数量n，否则协方差矩阵会不可逆；<br>根据经验法则，当$m&gt;10n$时，多元高斯分布会表现良好。</p><p>在原始高斯分布模型中可以手动添加相关性高的特征值之间的关系，可以避免了使用多元高斯分布，减小计算成本。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 非监督学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PCA降维算法</title>
      <link href="/2020/02/06/tech/machine_learning/dimensionality_reduction.html"/>
      <url>/2020/02/06/tech/machine_learning/dimensionality_reduction.html</url>
      
        <content type="html"><![CDATA[<p>降维是机器学习中很重要的一种思想。在机器学习中经常会碰到一些高维的数据集，它们会占用计算机的内存和硬盘空间，而且在运算时会减缓速度。<br>降维能够使得数据量被压缩，加快运算速度，减小储存空间，以及方便可视化的观察数据特点。</p><p><em>PS：在降维中，我们减少的是特征种类而不是样本数量，样本数量m不变，特征值数量n会减少。</em></p><h2 id="主成分分析算法（PCA）"><a href="#主成分分析算法（PCA）" class="headerlink" title="主成分分析算法（PCA）"></a>主成分分析算法（PCA）</h2><p>一种常用的降维算法是主成分分析算法（Principal Component Analysis），简称<strong>PCA</strong>。</p><p>PCA是通过找到一个低维的线或面，然后将数据投影到线或面上去，然后通过减少投影误差（即每个特征到投影的距离的平均值）来实现降维。</p><img width="40%" src="/images/ml_32.jpg" alt=""><p>上图是一个包含二维特征值的样本集。黑色的叉代表样本，红色的线表示找到的低维的线，绿色的叉则是样本投影在线上的位置。而它们的投影距离就是PCA算法所需要考虑的。</p><p>通过上图可以看出PCA算法就是找出一个线，在数学上就是一个向量，使得其他样本投影到该向量上的距离最小。</p><p>推而广之：<br>一般情况下，将特征值的维度从n降到k，就是找到k个向量$u^{(1)},u^{(2)},…,u^{(k)}$，使得样本在这些向量上的投影最小。</p><p>例如，2维降到1维，就是找到1个向量，即一条线；3维降到2维，就是找到2向量，即一个平面。</p><h3 id="PCA和线性回归的区别"><a href="#PCA和线性回归的区别" class="headerlink" title="PCA和线性回归的区别"></a>PCA和线性回归的区别</h3><ul><li>在线性回归中，最小化的是没有样本到预测线的平方误差，它们之间的距离是垂直距离。</li><li>在PCA中，最小化的是投影距离，或者说是正交距离。</li></ul><h3 id="算法过程"><a href="#算法过程" class="headerlink" title="算法过程"></a>算法过程</h3><p><strong>数据处理</strong></p><p>假设有m个样本集：$x^{(1)},x^{(2)},…,x^{(m)}$<br>下面需要对数据做一下特征值缩放或者均值归一化。<br>先计算出平均值，然后用样本值减去平均值。<br>$\mu_i=\frac{1}{m}\sum_{i=1}^m x_j^{(i)}$<br>然后用$\frac{x_j^{(i)}-\mu_i}{s_j}$ 替换$ x_j^{(i)}$，$s_j$可以是数据最大值最小值的范围或者标准差。</p><p><strong>算法部分</strong></p><ol><li>计算协方差矩阵（covariance matrix）<br>$$\Sigma = \frac{1}{m}\sum^m_{i=1}(x^{(i)})(x^{(i)})^T$$</li></ol><p><em>PS：假设$x^{(i)}$为一个n维向量（n * 1）,$(x^{(i)})(x^{(i)})^T$则是一个n维方阵。</em></p><ol start="2"><li><p>计算协方差矩阵的特征向量（eigenvectors）<br>可以通过奇异值分解（SVD）来获得：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">U,S,V</span>] = svd(Sigma);</span><br></pre></td></tr></table></figure><p>我们需要的就是矩阵U，他是一个n维方阵$U \in \mathbb{R}^{n \times n}$，它的每一列就是我们需要的向量：<br>$$ U = \left[ \begin{matrix} u^{(1)} &amp; u^{(2)} &amp; … &amp; u^{(n)} \end{matrix} \right]$$</p></li><li><p>获取Ureduce矩阵<br>当要从n降维到k，从矩阵U中取前k个向量就可以了：<br>$$Ureduce = \left[ \begin{matrix} u^{(1)} &amp; u^{(2)} &amp; … &amp; u^{(k)} \end{matrix} \right]$$</p></li><li><p>计算投影后的矩阵<br>$$ z^{(i)} = Ureduce^T \cdot x^{(i)} $$</p></li></ol><p><em>PS：$Ureduce^T$ 是一个  k×n 维的矩阵，$x^{(i)}$ 是一个n×1维的向量，两者点乘后就是一个z×1的向量，这样就得到了我们需要的。</em></p><h3 id="回到原来的维度"><a href="#回到原来的维度" class="headerlink" title="回到原来的维度"></a>回到原来的维度</h3><p>使用$Ureduce$矩阵可以降维：<br>$$ z^{(i)} = Ureduce^T \cdot x^{(i)} $$<br>那么要回到原来的维度上去就需要：<br>$$ x_{approx}^{(i)} = Ureduce \cdot z^{(i)} $$</p><p><em>这里我们只能得到原来的近似值</em></p><h3 id="选择降维的维度"><a href="#选择降维的维度" class="headerlink" title="选择降维的维度"></a>选择降维的维度</h3><p>$x_{approx}^{(i)}$与$ x^{(i)}$ 近似相等，两者之间的差就是投影误差，或平均平方映射误差：<br>$$ \frac{1}{m}\sum_{i=1}^m || x^{(i)} - x_{approx}^{(i)} ||^2 $$</p><p>数据的总变差（total variation），即样本的长度平方的均值：<br>$$ \frac{1}{m}\sum_{i=1}^m || x^{(i)} ||^2 $$</p><p>选择维度k的最小值的方法：<br>$$ \frac{\frac{1}{m}\sum_{i=1}^m || x^{(i)} - x_{approx}^{(i)} ||^2}{\frac{1}{m}\sum_{i=1}^m || x^{(i)} ||^2} \leq 0.01 $$</p><p>表示平方投影误差除以总变差的值小于0.01，用PCA的语言称之为<strong>保留了99%的差异性</strong>。<br><em>PS：这个值是可以变化的，可以是95%，90%，85%等等。</em></p><p><strong>使用循环验证的办法：</strong><br> 初始化$k=1$，然后计算出$Ureduce$，通过$Ureduce$计算出$z^{(1)},z^{(2)},…,z^{(m)} $和$x_{approx}^{(1)},x_{approx}^{(2)},…,x_{approx}^{(m)}$，然后通过上方的公式计算出值是不是小于0.01。<br>如果不是，增加k值，直到获得最小的k值满足条件。</p><p><strong>快捷办法</strong></p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">U,S,V</span>] = svd(Sigma);</span><br></pre></td></tr></table></figure><p>通过奇异值分解的到的矩阵$S$是一个n维的对角矩阵：<br>$$ S = \left[ \begin{matrix} s_{11} &amp; 0  &amp; … &amp; 0 \\ 0 &amp; s_{22} &amp; … &amp; 0 \\ … &amp; … &amp; … &amp; … \\ 0 &amp; 0 &amp; … &amp; s_{nn}  \end{matrix} \right] $$</p><p>通过这个矩阵可以来计算：<br>$$ 1 - \frac{\sum_{i=1}^k S_{ii}}{\sum_{i=1}^n S_{ii}}  \leq 0.01 $$<br>也可以用下面的式子：<br>$$ \frac{\sum_{i=1}^k S_{ii}}{\sum_{i=1}^n S_{ii}}  \geq 0.99 $$<br>这种方法就非常快捷高效。</p><h2 id="使用PCA的建议"><a href="#使用PCA的建议" class="headerlink" title="使用PCA的建议"></a>使用PCA的建议</h2><p>我们在训练集上通过PCA获得矩阵$Ureduce$，在交叉验证集和测试集上就不能再使用PCA来计算矩阵了，而是直接用训练集里的矩阵来映射交叉验证集和测试集上的数据。</p><p>PCA最常用的就是压缩数据，加速算法的学习，或者可视化数据。</p><ul><li>压缩数据<br>将数据压缩到合适的维度，用来加速算法。</li><li>数据可视化<br>将数据的维度降到2或3维以便画出图像。</li></ul><p><strong>PCA的错误用法，用来防止算法过拟合</strong><br>算法过拟合的原因之一是算法过于复杂，特征值的维度过高，使用PCA可以降低维度，看起来会有效，但是实际上效果很差。防止算法过拟合还是使用正则化的方法来实现。</p><p>还有一个注意点。就是在设计一个机器学习算法时，不用一开始就考虑降维，先在不使用PCA的条件下设计算法，当算法出现问题，例如，算法计算过慢，占用大量内存…，之后当确定需要使用PCA的时候再继续使用。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 非监督学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K均值算法介绍</title>
      <link href="/2020/02/06/tech/machine_learning/k_means_intro.html"/>
      <url>/2020/02/06/tech/machine_learning/k_means_intro.html</url>
      
        <content type="html"><![CDATA[<p>从没有标记过的数据中学习称之为非监督学习。<br>在非监督学习中，通过算法来定义一些数据的结构，将数据分别聚合到这些子集中，这种算法称之为聚类算法。</p><p>K均值 (K-means) 算法是最常用的一种聚类算法。</p><h2 id="K-means算法"><a href="#K-means算法" class="headerlink" title="K-means算法"></a>K-means算法</h2><p>$[x^{(1)},x^{(2)},x^{(3)},…,x^{(m)}]$<br>假设有如上的数据集，可以看到只有输入$x$，没有输出$y$。</p><p>下面说明一下K均值算法的过程</p><ol><li>首先确认聚类的簇的个数，$K=?$</li><li>随机初始化K个聚类的中心点，$\mu_1,\mu_2,…,\mu_k$</li><li>集群分配：将所有的数据集分配到里离它最近的聚类中心，并用$c^{(i)}$表示聚类中心的索引。例如第3个样本$x^{(3)}$，离它最近的一个聚类中心是第2个($\mu_2$)，那个$c^{(3)}=2$</li></ol><p><em>通过比较$||x^{(i)}-\mu_k||^2$的大小，算出$x^{(i)}$距离最近的中心点。</em><br>4. 移动质心：每个聚类中心所分配到的样本，求出这些样本的平均值，然后将原来的聚类中心移到新的平均值点上。<br>5. 重复3和4步骤，直到找到正确的聚类的簇。</p><h2 id="优化目标"><a href="#优化目标" class="headerlink" title="优化目标"></a>优化目标</h2><h3 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h3><ul><li>$c^{(i)}$=样本$x^{(i)}$所分配到的聚类中心点的索引</li><li>$\mu_k$=第k个聚类中心</li><li>$\mu_{c^{(i)}}$=样本$x^{(i)}$所分配到的聚类中心点</li></ul><p>K均值算法的代价函数为：<br>$$ J(c^{(1)},…,c^{(m)},\mu_1,…\mu_k) = \frac{1}{m}\sum_{i=1}^m ||x^{(i)}-\mu_{c^{(i)}}||^2 $$</p><p>优化目标就是使用上面的代价函数最小化所有参数。</p><p>上述步骤中<br>第3步集群分配，是通过找到离样本最近的聚类中心点来最小化代价函数；<br>第4步移动质心，是通过改变样本和聚类中心点的距离来最小代价函数。<br><strong>在K均值算法中，代价函数是一直下降的，不可能出现上升的情况。</strong></p><h2 id="初始化聚类中心"><a href="#初始化聚类中心" class="headerlink" title="初始化聚类中心"></a>初始化聚类中心</h2><p>聚类中心的个数 $K$一般都是小于样本数量$m$的，因此可以随机取$K$个样本来作为聚类中心。</p><p>步骤</p><ul><li>确保聚类中心个数小于样本数量；</li><li>随机取K个样本；</li><li>将K个样本分配到聚类中心$\mu_1,…\mu_k$.</li></ul><p>这样做的优点是方便快捷，缺点是不一定能够找到最佳的聚类中心，容易陷入局部最优。<br>这种陷入局部最优的情况在聚类中心过少时一般会出现，一般在$K&lt;10$的情况下，解决办法是多次执行该步骤，比较代价函数的值，取最小值。</p><h2 id="聚类中心数量的选择"><a href="#聚类中心数量的选择" class="headerlink" title="聚类中心数量的选择"></a>聚类中心数量的选择</h2><p>聚类中心数量的选择没有固定的方法，跟主观上的判断有很大关系，也跟业务，以及一些客观条件，以及使用K均值算法的目标有关。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 非监督学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>核函数的概念以及在SVM上的应用</title>
      <link href="/2020/02/01/tech/machine_learning/svm_kernels.html"/>
      <url>/2020/02/01/tech/machine_learning/svm_kernels.html</url>
      
        <content type="html"><![CDATA[<h2 id="高斯核函数"><a href="#高斯核函数" class="headerlink" title="高斯核函数"></a>高斯核函数</h2><p>激励函数中$\theta^Tx=\theta_0 + \theta_1x_1 + \theta_2x_2 + … + \theta_nx_n$</p><p>现在准备用新的特征值$f_1,f_2,…$ 来替换 $x_1,x_2,…$</p><p>将$f$定义为两个向量的相似度：</p><p>例如，有一个标记向量$l^{(i)}$，某个样本的特征向量$x$和其的相似度为：<br>$$ f_i = similarity(x, l^{(i)}) = exp(-\frac{|| x-l^{(i)} ||^2}{2\sigma^2})$$</p><p><em>PS：$|| x ||$ 是 x向量的范数。</em></p><p>该核函数又称之为<strong>高斯核函数（Gaussian Kernels）</strong>。</p><p>当$x$和$l^{(i)}$很相似时，$f_i \approx 1$；当两者差距很大时，$f_i \approx 0$。</p><p>高斯核函数中有个关键参数$\sigma$，它的大小决定了，该函数值的变化速度。当$\sigma$很小时，$f_i$的变化就会很快，两个向量一点细微的差距就会本放大。当$\sigma$变大时，则相反：</p><div style="display:flex;"><img  src="/images/ml_28.jpg" alt=""><img  src="/images/ml_29.jpg" alt=""><img  src="/images/ml_30.jpg" alt=""></div><p>举个例子，假设设计三个新的特征变量$f_1,f_2,f_3$：<br>当$\theta_0 + \theta_1f_1 + \theta_2f_2 + \theta_3f_3 \geq 0$时，通过预测函数$h(\theta)$预测为1。</p><p>我们假设$\theta_0=-0.5, \theta_1=1, \theta_2=1, \theta_3=0$</p><p>当样本x接近$l_1$时，$f_1 \approx 1$，$f_2 \approx 0$，$f_3 \approx 0$，可以得出上述表达式为$-0.5 + 1 + 0 + 0 = 0.5$，可以预测该样本的输出为1，以此类推，可以得出在标记向量$l_1,l_2$附近的向量即预测为1，远离的预测为0：</p><img width="40%" src="/images/ml_31.jpg" alt=""><h2 id="应用到支持向量机上"><a href="#应用到支持向量机上" class="headerlink" title="应用到支持向量机上"></a>应用到支持向量机上</h2><h3 id="选取标记向量"><a href="#选取标记向量" class="headerlink" title="选取标记向量"></a>选取标记向量</h3><p>在实际应用中，将每个样本作为标记向量。<br>假设有样本$x^{(1)},x^{(2)},…,x^{(m)}$，同样的，将每个样本都定义为标记点，$l^{(1)},l^{(2)},…,l^{(m)}$，即：$x^{(1)}=l^{(1)},x^{(2)}=l^{(2)},…,x^{(m)}=l^{(m)}$。</p><p>对于某一个样本$(x^{(i)},y^{(i)})$来说：<br>$f_1^{(i)}$ = similarity$(x^{(i)}, l^{(1)})$<br>$f_2^{(i)}$ = similarity$(x^{(i)}, l^{(2)})$<br>…<br>$f_i^{(i)}$ = similarity$(x^{(i)}, l^{(i)})=1$<br>…<br>$f_m^{(i)}$ = similarity$(x^{(i)}, l^{(m)})$</p><p><em>PS：在这其中，第$i$个样本向量和第$i$个标记向量是同一个，所以值为1。</em></p><p>对于某一个样本的新的特征向量$f^{(i)}=\left[ \begin{matrix} f^{(i)}_0 \\ f^{(i)}_1 \\ f^{(i)}_2 \\ … \\ f^{(i)}_m \end{matrix}\right]$，同样的$f^{(i)}_0$始终为1，$f$是一个m+1的向量。</p><p>当使用新的特征值后，当$\theta^Tf \geq 0$时，即可预测输出值为1。</p><p>支持向量机的代价函数为：<br>$$ J(\theta)=-C \sum_{i=1}^m [y^{(i)} cost_1(\theta^Tx) + (1-y^{(i)}) cost_0(\theta^Tx)] + \frac{1}{2} \sum_{j=1}^n \theta_j^2 $$</p><p>将新的特征值替换到支持向量机的代价函数中去：</p><p>$$ J(\theta)=-C \sum_{i=1}^m [y^{(i)} cost_1(\theta^Tf^{(i)}) + (1-y^{(i)}) cost_0(\theta^Tf^{(i)})] + \frac{1}{2} \sum_{j=1}^m \theta_j^2 $$</p><p>可以看到将$x^{(i)}$替换成了$f^{(i)}$，$\sum_{j=1}^m \theta_j^2$中是统计从1到m的参数了，因为，新的特征向量是m+1维向量，而且$\theta_0$不用修正。</p><p>核函数也可以用到逻辑回归上，但是这样计算成本会很高，速度会慢许多。而在SVM上，有许多针对核函数的优化方法，使得核函数在SVM上运行良好。</p><h2 id="SVM使用事项"><a href="#SVM使用事项" class="headerlink" title="SVM使用事项"></a>SVM使用事项</h2><p>在使用SVM时一般都是使用第三方包提供的SVM优化算法，我们仅需提供：</p><ul><li>参数C</li><li>选择核函数</li></ul><h3 id="参数C"><a href="#参数C" class="headerlink" title="参数C"></a>参数C</h3><p>参数C可以看作$\frac{1}{\lambda}$，与$\lambda$相关的：</p><ul><li>C过大时，会导致高方差，过拟合的问题；</li><li>C过小时，会导致高偏差，欠拟合的问题。</li></ul><p>因此需要选取折中的C值，可以通过选取多个C值，然后在交叉验证集上简直多个C值的误差，选择最小的。</p><h3 id="核函数选择"><a href="#核函数选择" class="headerlink" title="核函数选择"></a>核函数选择</h3><p>在核函数的选择上，一般有两种，一个是不用核函数，一个是高斯核函数。</p><p>不用核函数也称为线性核函数。它和逻辑回归的算法效果类似。当训练集有大量的特征值，但是样本数量不是太多时，这时拟合一个线性的边界条件会有比较好的效果，也即一般会不使用核函数或使用线性核函数。 </p><p>高斯核函数 则需要去选择$\sigma^2$</p><p><strong>参数$\sigma^2$</strong></p><ul><li>当$\sigma^2$过小时，$f$核函数的变化速度会很剧烈，会导致高方差的现象；</li><li>当$\sigma^2$过大时，$f$核函数的变化速度会很平缓，会导致高偏差的现象。</li></ul><p>当训练集的特征值不是特别多，而且有大量的样本数量时可以选择高斯核函数。</p><p>当使用高斯核函数时，一个很重要的操作就是特征值的缩放，因为计算相似度时，会计算$|| x-l^{(i)} ||^2$，当每个特征值的取值范围相差很大时，求得的范数会受范围大的特征值的影响。为了避免这种情况，需要缩放到相近的范围内。</p><h2 id="多分类问题"><a href="#多分类问题" class="headerlink" title="多分类问题"></a>多分类问题</h2><p>在处理多元分类问题时，与逻辑分类和神经网络类似，也是训练多个SVM训练器，然后比较取性能最好的一个。<br>更方便的方式是使用第三方的库函数来实现多元分类问题。 </p><h2 id="逻辑回归和SVM"><a href="#逻辑回归和SVM" class="headerlink" title="逻辑回归和SVM"></a>逻辑回归和SVM</h2><p>定义：n = 样本的特征值数量，m = 样本的数量。</p><ul><li><p>当n相对于m来时很大时，比如n=10000，m=1000时，这时选择逻辑回归或者不使用核函数的SVM；</p></li><li><p>当n比较小，m中等大小，比如n=1000，m=10000时，选择SVM（使用高斯核函数）的效果会比较好； </p></li><li><p>当n比较小，m非常大时，比如n=1000，m=50000+时，这时通常手动添加更多的特征值，然后使用逻辑回归或者不使用核函数的SVM来处理。</p></li></ul><p>而神经网络算法，通常都会比这两者来的慢，且需要良好的设计才能取得较好的效果。而且使用SVM时不用担心遇到局部最优的问题。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> SVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>支持向量机算法（SVM）介绍</title>
      <link href="/2020/01/31/tech/machine_learning/svm_intro.html"/>
      <url>/2020/01/31/tech/machine_learning/svm_intro.html</url>
      
        <content type="html"><![CDATA[<p>在解决复杂的非线性分类问题时，除了逻辑回归和神经网络，还有一种更为强大的算法：叫做<strong>支持向量机（Support Vector Machines）</strong>，简称<strong>SVM</strong>。</p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>在分类问题上，常用的激励函数为：<br>$$ h_\theta(x) = \frac{1}{1+e^{-\theta^Tx}} $$</p><p>逻辑回归的cost函数：<br>$$ Cost(h_\theta(x), y) = -y \log(h_\theta(x)) - (1-y) \log(1-h_\theta(x)) $$</p><p>代入激励函数，得到：<br>$$ Cost(h_\theta(x), y) = -y \log(\frac{1}{1+e^{-\theta^Tx}}) - (1-y) \log(1-\frac{1}{1+e^{-\theta^Tx}}) $$</p><p>上述式子中：<br>当样本的输出$y$为1时：$Cost(h_\theta(x), y) = -\log(\frac{1}{1+e^{-z}}), z=\theta^Tx$</p><p>当样本的输出$y$为0时：$Cost(h_\theta(x), y) = -\log(1-\frac{1}{1+e^{-z}}), z=\theta^Tx$</p><p>该式子的值随着z的变化曲线：</p><div style="display:flex;"><img  src="/images/ml_25.jpg" alt=""><img  src="/images/ml_26.jpg" alt=""></div><p>可以看到当$y=1$时，该式子的值随着z值的增大而减小；当$y=0$时，该式子的值随着z值的增大而增大。</p><p>下面开始构建向量机<br>将上面的变化曲线做一下简化：</p><p><img src="/images/ml_27.jpg" alt=""></p><ul><li>当$y=1$时，以$z=1$为分界点，当$z\geq 1$，式子的值为0，当小于1时，是一条线性变化的直线；<br>用 <strong>$cost_1(z)$</strong>来表示该曲线。</li><li>当$y=0$时，以$z=-1$为分界点，当$z\leq -1$，式子的值为0，当大于-1时，是一条线性变化的直线；<br>用 <strong>$cost_0(z)$</strong>来表示该曲线。</li></ul><p>逻辑回归的代价函数为：<br>$$ J(\theta)=-\frac{1}{m} \sum_{i=1}^m [y^{(i)} \log(h_\theta(x^{(i)})) + (1-y^{(i)}) \log(1-h_\theta(x^{(i)}))] + \frac{\lambda}{2m} \sum_{j=1}^n \theta_j^2  $$</p><p>将$cost_1(z)$和$cost_0(z)$代入上述式子：</p><p>$$ J(\theta)=-\frac{1}{m} \sum_{i=1}^m [y^{(i)} cost_1(\theta^Tx) + (1-y^{(i)}) cost_0(\theta^Tx)] + \frac{\lambda}{2m} \sum_{j=1}^n \theta_j^2 $$</p><p>为了方便计算，将式子乘以$m$；再将$\lambda$化去，用$C$代替：</p><p>$$ J(\theta)=-C \sum_{i=1}^m [y^{(i)} cost_1(\theta^Tx) + (1-y^{(i)}) cost_0(\theta^Tx)] + \frac{1}{2} \sum_{j=1}^n \theta_j^2 $$</p><p>上述便是SVM的代价函数。<br>$C$值是一种控制参数权重的方法，和逻辑分类的$\lambda$的作用类似。区别是更关心前一个式子的优化还是后一个式子的优化。为了方便，可以简单的把C和$\lambda$的关系比做$C=\frac{1}{\lambda}$。</p><p>通过代价函数 和 $cost_1(z)$和$cost_0(z)$ 的变化曲线，可以得知：</p><ul><li>当$y=1$：$\theta^Tx \geq  1$条件下，代价函数的值趋向于0；</li><li>当$y=0$：$\theta^Tx \leq -1$条件下，代价函数的值趋向于0；</li></ul><p>上述条件比起在逻辑回归中，$\theta^Tx \geq 0$时预测值为1，$\theta^Tx &lt; 0$预测值为0，支持向量机的要求更加严格。</p><h2 id="决策边界"><a href="#决策边界" class="headerlink" title="决策边界"></a>决策边界</h2><p>支持向量机在选择决策边界时会选择一个离样本间距最大的边界，因此支持向量机有时被称为<strong>大间距分类器</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> SVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查准率（Precision）和召回率（Recall）</title>
      <link href="/2020/01/27/tech/machine_learning/precision_and_recall.html"/>
      <url>/2020/01/27/tech/machine_learning/precision_and_recall.html</url>
      
        <content type="html"><![CDATA[<p>在处理分类问题时，会遇到一种情况：</p><p>假设一个二元分类问题：假设我们的预测算法是：$h_\theta(x)=0$，这个算法忽略特征值$x$，不管任何情况下都是预测$h_\theta(x)$等于0。</p><p>毫无疑问这是一个糟糕的算法，但是在测试集中，99%的样本输出$y=1$，1%的样本输出$y=0$，这样计算预测算法的误差率的时候，会的到1%的误差率，这就是很糟糕的情况，一个完全错误的算法得到了一个正确率很高的测试结果。</p><p>这种情况称之为<strong>偏斜类（Skewed Classes）</strong>的问题。</p><h2 id="解决问题的办法"><a href="#解决问题的办法" class="headerlink" title="解决问题的办法"></a>解决问题的办法</h2><p>处理这种情况，需要参考查准率和召回率</p><table border="1">    <tr>        <th colspan="2" rowspan="2"></th>        <th colspan="2" align="center">真实结果</th>    </tr>    <tr>        <td>1</td>        <td>0</td>    </tr>    <tr><th rowspan="4">预测结果</th></tr>    <tr>        <td>1</td>        <td>TP(真阳性)</td>        <td>FP(假阳性)</td>    </tr>    <tr>        <td>0</td>        <td>FN(假阴性)</td>        <td>TN(真阴性)</td>    </tr></table><p>上图的表格中，提到了四个概念。<br><strong>TP(真阳性)</strong> 预测为真的样本中确实为真的数量。<br><strong>FP(假阳性)</strong> 预测为真的样本中确实为假的数量。<br><strong>FN(假阴性)</strong> 预测为假的样本中确实为真的数量。<br><strong>TN(真阴性)</strong> 预测为假的样本中确实为假的数量。</p><p>举个例子来说明</p><p>预测某些病人有没有得癌症。<br>假设有100个样本，真实情况是有10个得癌症的，通过预测函数遇到到了有12个得了癌症，其中有8个是真实得癌症的。<br>这种情况下:<br>TP=8<br>FP=12-8=4<br>FN=10-8=2<br>TN=(100-12)-2=86</p><h2 id="准确率-Accuracy"><a href="#准确率-Accuracy" class="headerlink" title="准确率 Accuracy"></a>准确率 Accuracy</h2><p>正确预测为1，正确预测为0的样本比率，公式为：$\frac{TP+TN}{ALL}$<br>上例中准确率为 $\frac{8+86}{100}=0.94$</p><h2 id="查准率-Precision"><a href="#查准率-Precision" class="headerlink" title="查准率 Precision"></a>查准率 Precision</h2><p>查准率是指在所有预测为1的样本中预测正确的比率，公式为：$\frac{TP}{TP+FP}$<br>上例中查准率为 $\frac{8}{8+4}=0.667$</p><h2 id="召回率-Recall"><a href="#召回率-Recall" class="headerlink" title="召回率 Recall"></a>召回率 Recall</h2><p>召回率是指在所有真正为1的样本中预测正确的比率，公式为：$\frac{TP}{TP+FN}$<br>上例中召回率为 $\frac{8}{8+2}=0.8$</p><p>在最开始偏斜类问题中 TP=0，召回率为0，因此那个预测算法是错误的。</p><h2 id="查准率和召回率的关系"><a href="#查准率和召回率的关系" class="headerlink" title="查准率和召回率的关系"></a>查准率和召回率的关系</h2><p>在分类问题中，$h_\theta(x) \geq 0.5$ 是我们就预测为1，$h_\theta(x) &lt; 0.5$ 是我们就预测为0；</p><p>边界条件就是0.5<br>当提高边界值时，即$h_\theta(x) \geq 0.7$，查准率会提高，召回率会下降；<br>当减小边界值时，即$h_\theta(x) \geq 0.3$，召回率会提高，查准率会下降。</p><img width="50%" src="/images/ml_23.jpg" alt=""><p>查准率和召回率之间的变化关系和上图类似，变化的曲线可能不是上图的平滑关系。大方向两者是相反的增长。</p><h2 id="判断一个学习算法的性能"><a href="#判断一个学习算法的性能" class="headerlink" title="判断一个学习算法的性能"></a>判断一个学习算法的性能</h2><p><img src="/images/ml_24.jpg" alt=""></p><p>要判断一个学习学习算法需要综合考虑查准率和召回率，可以使用 <strong>F值（F-Score）</strong> 来综合评价。<br>公式为：2$\frac{P*R}{P+R}$</p><p>通过上面，可以得出算法1的性能比较好。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>评估学习算法</title>
      <link href="/2020/01/26/tech/machine_learning/evaluating_learning_algorithm.html"/>
      <url>/2020/01/26/tech/machine_learning/evaluating_learning_algorithm.html</url>
      
        <content type="html"><![CDATA[<p>在使用学习算法解决机器学习问题时，可能预测函数的误差很小，但是这个学习算法不确定是不是准确的，因为可能出现过拟合的情况。</p><p>因为仅仅用一个训练集来判断学习算法是否准确是不行的，为此我们需要将原始数据集拆分成三个：</p><ul><li>训练集 (Training set) 占60%</li><li>交叉验证集 (Cross validation set) 占20%</li><li>测试集 (Test set) 占20%</li></ul><h2 id="学习模型的选择"><a href="#学习模型的选择" class="headerlink" title="学习模型的选择"></a>学习模型的选择</h2><p>例如在线性回归问题中，训练集有一个特征值$x$，在选择模型时，选择几次项：<br>1 .  $h_\theta(x)=\theta_0+\theta_1x$<br>2 .  $h_\theta(x)=\theta_0+\theta_1x+\theta_2x^2$<br>3 .  $h_\theta(x)=\theta_0+\theta_1x+…+\theta_3x^3$<br>…<br>10 . $h_\theta(x)=\theta_0+\theta_1x+…+\theta_{10}x^{10}$</p><p>首先分成三个样本集：<br>训练集：$(x^{(1)},y^{(1)}), (x^{(2)},y^{(2)}), …, (x^{(m)},y^{(m)})$<br>交叉验证集：$(x_{cv}^{(1)},y_{cv}^{(1)}), (x_{cv}^{(2)},y_{cv}^{(2)}), …, (x_{cv}^{(m_{cv})},y_{cv}^{(m_{cv})})$<br>测试集：$(x_{test}^{(1)},y_{test}^{(1)}), (x_{test}^{(2)},y_{test}^{(2)}), …, (x_{test}^{(m_{test})},y_{test}^{(m_{test})})$</p><p>分开的三个样本集上的误差：<br>$J_{train}(\Theta)=\frac{1}{2m} \sum_{i=0}^m(h_\theta(x^{(i)})-y^{(i)})^2$<br>$J_{cv}(\Theta)=\frac{1}{2m_{cv}} \sum_{i=0}^{m_{cv}}(h_\theta(x_{cv}^{(i)})-y_{cv}^{(i)})^2$<br>$J_{test}(\Theta)=\frac{1}{2m_{test}} \sum_{i=0}^{m_{test}}(h_\theta(x_{test}^{(i)})-y_{test}^{(i)})^2$</p><p>选择模型的步骤：</p><ul><li>将上面十个模型在训练集上优化每个模型的参数$\theta$；</li><li>在交叉验证集上找出一个误差最小的模型；</li><li>在测试集上用$J_{test}(\Theta)$来估计泛化误差。</li></ul><p>这样的操作是的测试集与训练集，交叉验证集完全分离开，互不影响。在测试集上的泛化误差比较准确。</p><h2 id="偏差（Bias）和方差（Variance）"><a href="#偏差（Bias）和方差（Variance）" class="headerlink" title="偏差（Bias）和方差（Variance）"></a>偏差（Bias）和方差（Variance）</h2><p>当一个算法在使用时并不理想，会有两种情况，高偏差（欠拟合）或高方差（过拟合）。</p><p>还是上面的线性回归例子。通过选择不同模型，比较它们在训练集和交叉验证集上的表现结果：</p><img width="50%" src="/images/ml_19.jpg" alt=""><p>上图中，x轴是多项式的次数，可以看作是函数的复杂程度，y轴是代价函数的值。</p><p><strong>在训练集上：</strong>当函数简单时，代价函数值很大，预测函数效果不好，随着多项式的增加，函数复杂度的增加，拟合效果越来越小，代价趋向于零。<br><strong>在交叉验证集上：</strong>当函数简单时，代价函数值很大，预测函数效果不好，多项式在增加到一定程度前，代价一直在下降，当下降到一定程度是，代价函数又会上升，拟合效果又变差了。</p><p><strong>高偏差（Bias）：</strong>$J_{train}(\Theta)$和$J_{cv}(\Theta)$都很高，而且两者非常接近，$J_{train}(\Theta)\approx J_{cv}(\Theta)$<br><strong>高方差（Variance）：</strong>$J_{train}(\Theta)$很小，$J_{cv}(\Theta)$远远大于$J_{train}(\Theta)$</p><p>在实际使用时，需要在中间找一个平衡点，避免高偏差和高方差</p><h2 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h2><p>通过正则化能够解决过拟合的问题，但是它在欠拟合也就是高偏差情况下效果并不明显。</p><p>上面的线性回归例子，选择一个模型：<br>$$h_\theta(x)=\theta_0+\theta_1x+\theta_2x^2+\theta_3x^3+\theta_4x^4$$<br>它的正则化后的代价函数：<br>$$ J(\theta)= \frac{1}{2m} \sum_{i=0}^m (h_\theta(x^{(i)})-y^{(i)})^2 + \frac{\lambda}{2m} \sum_{j=1}^n\theta_j^2 $$</p><p><em>PS: 上面的$J_{train}(\Theta),J_{cv}(\Theta),J_{test}(\Theta)$定义里面没有加上正则化，所以上面的训练集，交叉验证集，测试集都是在没有正则化的情况的误差</em></p><p>现在我们要做的是先选择一系列的$\lambda$值，比如:<br>0, 0.01, 0.02, 0.04, 0.08, 0.16, 0.32, 0.64, 1.28, 2.56, 5.12, 10.24<br>通过正则化得出优化的参数$\theta$。</p><p>然后使用这些优化参数得出$J_{train}(\Theta),J_{cv}(\Theta)$<br>$J_{train}(\Theta)=\frac{1}{2m} \sum_{i=0}^m(h_\theta(x^{(i)})-y^{(i)})^2$<br>$J_{cv}(\Theta)=\frac{1}{2m_{cv}} \sum_{i=0}^{m_{cv}}(h_\theta(x_{cv}^{(i)})-y_{cv}^{(i)})^2$<br><strong>注意，这里的误差都没有加上正则化项目</strong></p><p>比较每个$\lambda$值下的代价函数的曲线：</p><img width="50%" src="/images/ml20.png" alt=""><p><strong>在训练集上：</strong> 随着$\lambda$的增大，代价函数的值越来越大，效果越来越差。<br><strong>在交叉验证集上：</strong> 先随着$\lambda$在一定范围下增大，代价函数的值在减小，超过一个程度后，代价函数会增大。</p><p>当$\lambda$为0，或很小时，是高方差；当$\lambda$过大时，是高偏差。</p><p>同样的需要找一个$\lambda$使得代价函数在训练集和交叉验证集上平衡的。</p><h2 id="学习曲线（Learning-Curves）"><a href="#学习曲线（Learning-Curves）" class="headerlink" title="学习曲线（Learning Curves）"></a>学习曲线（Learning Curves）</h2><p>画出随着样本集数量的增加，代价函数的值的变化曲线。<br>训练集和交叉验证集的误差：<br>$J_{train}(\Theta)=\frac{1}{2m} \sum_{i=0}^m(h_\theta(x^{(i)})-y^{(i)})^2$<br>$J_{cv}(\Theta)=\frac{1}{2m_{cv}} \sum_{i=0}^{m_{cv}}(h_\theta(x_{cv}^{(i)})-y_{cv}^{(i)})^2$</p><p>当样本集数量很少时，训练集的误差很小，因为两三个样本总能够用一个直线达到不错的拟合效果，但是在交叉验证集上体现的并不好。<br>随着样本数量的增大，训练集的误差增大，而在交叉验证集上的体现会改善，误差会减小。</p><p><strong>高偏差</strong><br>在高偏差情况下，随着样本数量的增大，训练集和验证集的误差趋向于相等，但是都会偏高，与预期效果不符。</p><img width="50%" src="/images/ml_21.jpg" alt="高偏差学习曲线"><p><strong>高方差</strong><br>在高方差下，随着样本增加，训练集的误差会增加，但是增加的幅度很小；在验证集上，误差会减小，但是仍然大于训练集误差。</p><img width="50%" src="/images/ml_22.jpg" alt="高方差学习曲线"><p>可以看出，在高方差下，增加样本数量会有助于算法的优化。但是在高偏差下，增加样本数量并没有多少用处。</p><p>通过以上方法，在解决机器学习问题中，有以下方法可以帮助优化算法：</p><ul><li>获取更多样本：优化高方差</li><li>减少特征值的数量：优化高方差</li><li>添加特征值：优化高偏差</li><li>添加多项式次数，复杂的预测函数：优化高偏差</li><li>减小$\lambda$：解决高偏差</li><li>增加$\lambda$：解决高方差</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 算法优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络的反向传播算法的使用</title>
      <link href="/2020/01/20/tech/machine_learning/neural_network_backpropagation.html"/>
      <url>/2020/01/20/tech/machine_learning/neural_network_backpropagation.html</url>
      
        <content type="html"><![CDATA[<h2 id="参数展开"><a href="#参数展开" class="headerlink" title="参数展开"></a>参数展开</h2><p>在神经网络中，我们有一些参数矩阵，例如：<br>$\Theta^{(1)},\Theta^{(2)},\Theta^{(3)}…$<br>$D^{(1)},D^{(2)},D^{(3)}…$</p><p>有时为了使用方便，需要将这些矩阵统一到一个向量中去</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">thetaVector = [ Theta1(:); Theta2(:); Theta3(:); ]</span><br><span class="line">deltaVector = [ D1(:); D2(:); D3(:) ]</span><br></pre></td></tr></table></figure><p>这样就合并了三个矩阵，<br>假如$\Theta^{(1)}$ 是一个$5 \times 6$的矩阵，$\Theta^{(2)}$是一个$5 \times 6$的矩阵，$\Theta^{(3)}$是一个$1 \times 6$的矩阵<br>则 thetaVector 是一个$66 \times 1$的矩阵</p><p>当要使用时，同样要将这一个向量，拆分成三个矩阵：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Theta1 = <span class="built_in">reshape</span>(thetaVector(<span class="number">1</span>:<span class="number">30</span>),<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">Theta2 = <span class="built_in">reshape</span>(thetaVector(<span class="number">31</span>:<span class="number">60</span>),<span class="number">5</span>,<span class="number">6</span>)</span><br><span class="line">Theta3 = <span class="built_in">reshape</span>(thetaVector(<span class="number">61</span>:<span class="number">66</span>),<span class="number">1</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure><h2 id="随机初始化"><a href="#随机初始化" class="headerlink" title="随机初始化"></a>随机初始化</h2><p>在逻辑回归里，使用梯度下降算法时，需要初始化$\Theta$，这里可以设置成零向量$n\times 1$，元素全为0的向量。<br>但是在神经网络里，这样做不行。</p><p>举例说明，假设$\Theta_{i,j}^{(l)}=0$<br>$ a_1^{(2)} = g(\theta_{10}^{(1)}x_0+\theta_{11}^{(1)}x_1+\theta_{12}^{(1)}x_2+\theta_{13}^{(1)}x_3)=g(0) $<br>$ a_2^{(2)} = g(\theta_{20}^{(1)}x_0+\theta_{21}^{(1)}x_1+\theta_{22}^{(1)}x_2+\theta_{23}^{(1)}x_3)=g(0) $<br>…</p><p>这样$a_1^{(2)}=a_2^{(2)}=a_{s_l}^{(2)}$</p><p>当反向传播时$\delta^{(l)}$会发现每层的每个节点都是一样的，这样算法就会出现对称问题。<br>因此初始化的时候要随机一些初始值。初始化不同的随机址会打破对称问题。</p><p>将$\Theta_{i,j}^{(l)}$内每个值都随机在$[-\epsilon, \epsilon]$ 之间。（$-\epsilon \leq \Theta_{i,j}^{(l)} \leq \epsilon$）</p><p>例如:<br>Theta1 = rand(10,11) * (2<em>init_epsilon) - init_epsilon;<br>Theta2 = rand(1,11) * (2</em>init_epsilon) - init_epsilon;</p><p>rand(x,y)是一个初始化一个$x \times y$ 维的，其内之在0, 1之间的随机值。</p><h2 id="梯度检验（Gradient-Checking）"><a href="#梯度检验（Gradient-Checking）" class="headerlink" title="梯度检验（Gradient Checking）"></a>梯度检验（Gradient Checking）</h2><p>在使用反向传播算法时，因为反向传播有很多复杂的细节，这些细节会导致一些bug，虽然代价函数的值在减小，但是可能的结果和实际的还是有很大误差。<br>梯度检验可以减少这种错误的概率。</p><p>在数学上<br>$\frac{\partial}{\partial \Theta} J(\Theta) \approx \frac{J(\Theta+\epsilon) + J(\Theta-\epsilon)}{2\epsilon}$</p><p><em>PS：$\epsilon$这个和初始化随机的参数不一样</em></p><p>$\epsilon$ 是一个很小的值，例如$10^{-4}$</p><p>对于多个$\Theta$</p><p>$\frac{\partial}{\partial \Theta_j^{(l)}} J(\Theta) \approx \frac{J(\Theta_1,…,\Theta_j+\epsilon,…,\Theta_n) + J(\Theta_1,…,\Theta_j-\epsilon,…,\Theta_n)}{2\epsilon}$</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">epsilon = <span class="number">1e-4</span>;</span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:n,</span><br><span class="line">  thetaPlus = theta;</span><br><span class="line">  thetaPlus(<span class="built_in">i</span>) += epsilon;</span><br><span class="line">  thetaMinus = theta;</span><br><span class="line">  thetaMinus(<span class="built_in">i</span>) -= epsilon;</span><br><span class="line">  gradApprox(<span class="built_in">i</span>) = (J(thetaPlus) - J(thetaMinus))/(<span class="number">2</span>*epsilon)</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><p>将反向传播计算的DVec和梯度校验计算的gradApprox比较一下，两者一致则说明算法没有问题。但是在最终使用反向传播取训练样本集时，关掉梯度校验，因为这个非常耗时。</p><h2 id="隐藏层"><a href="#隐藏层" class="headerlink" title="隐藏层"></a>隐藏层</h2><p>每个隐藏层的单元数理论上越多准确度越好，但是实际上为了和计算成本平衡，需要选择何时的隐藏层单元数量。一般隐藏层单元数目稍大于输入层的特征值数。<br>隐藏层的数量越多，算法准确度越高，相应的计算成本也会增高，一般来说1个隐藏层。如果有多个隐藏层，建议在每个隐藏层中使用相同数量的单元。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络代价函数和反向传播算法</title>
      <link href="/2020/01/18/tech/machine_learning/neural_network_cost_function.html"/>
      <url>/2020/01/18/tech/machine_learning/neural_network_cost_function.html</url>
      
        <content type="html"><![CDATA[<img width="50%" src="/images/ml_18.jpg" alt="多层神经网络"><p>定义一些参数：<br>$L$ = 神经网络的层数<br>$s_l$ = $l$层的单元数，但不包括偏差单元<br>$K$ = 输出层的单元数，二元分类是1，大于二的就是k</p><p>逻辑回归的代价函数为：<br>$$ J(\theta)=-\frac{1}{m} \sum_{i=1}^m [y^{(i)} \log(h_\theta(x^{(i)})) + (1-y^{(i)}) \log(1-h_\theta(x^{(i)}))] + \frac{\lambda}{2m} \sum_{j=1}^n \theta_j^2 $$</p><p>神经网络的代价函数：<br>$h_\theta(x^{(i)})$ 是一个K维向量。$(h_\theta(x))_i$是输出向量的第i个单元。</p><p>$$ J(\theta)=-\frac{1}{m} \sum_{i=1}^{m}\sum_{k=1}^{K} [y_k^{(i)}\log((h_\theta(x^{(i)}))^k) + (1-y_k^{(i)})\log(1-(h_\theta(x^{(i)}))^k) ] + \frac{\lambda}{2m} \sum_{l=1}^{L-1}\sum_{i=1}^{s_l}\sum_{j=1}^{s_{l+1}}(\theta_{ji}^{(l)})^2 $$</p><p><em>PS：$(h_\theta(x^{(i)}))^k$ 这里的$k$应该是下标，这样写的原因是markdown解析不出来，囧～～</em></p><p>左侧两个求和的是将输出的每个单元的回归代价相加，右侧的三次和是将所有的$\theta$单元的平方相加</p><h2 id="最小化-J-theta"><a href="#最小化-J-theta" class="headerlink" title="最小化$J(\theta)$"></a>最小化$J(\theta)$</h2><p>想要计算神经网络的代价函数$J(\theta)$的最小化，需要计算$\frac{\partial}{\partial \theta_{i,j}^{(l)}} J(\theta)$</p><p>在神经网络算法中，最小化代价函数一般是使用<strong>反向传播算法（Backpropagation）</strong>来计算</p><p>定义一个参数：<br>$a_j^{(l)}$ = 第$l$层，第$j$个节点的激励函数返回值。<br>$\delta_j^{(l)}$ = 第$l$层，第$j$个节点的误差。</p><h3 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h3><ol><li><h4 id="初始化-Delta-i-j-l-0-，每一层的每一个元素都是0；"><a href="#初始化-Delta-i-j-l-0-，每一层的每一个元素都是0；" class="headerlink" title="初始化$\Delta_{i,j}^{(l)}=0$，每一层的每一个元素都是0；"></a>初始化$\Delta_{i,j}^{(l)}=0$，每一层的每一个元素都是0；</h4></li><li><h4 id="设置-a-1-x-i-；"><a href="#设置-a-1-x-i-；" class="headerlink" title="设置 $a^{(1)}=x^{(i)}$；"></a>设置 $a^{(1)}=x^{(i)}$；</h4></li><li><h4 id="正向计算每层的单元-a-l-，-l-2-3-…-L"><a href="#正向计算每层的单元-a-l-，-l-2-3-…-L" class="headerlink" title="正向计算每层的单元$a^{(l)}$，$l$=2,3,…,L"></a>正向计算每层的单元$a^{(l)}$，$l$=2,3,…,L</h4></li></ol><p>最上面的神经网络模型为例：<br>$a^{(1)}=x$<br>$z^{(2)}=\Theta^{(1)}a^{(1)}$<br>$a^{(2)}=g(z^{(2)})$，添加$a_0^{(2)}=1$<br>$z^{(3)}=\Theta^{(2)}a^{(2)}$<br>$a^{(3)}=g(z^{(3)})$，添加$a_0^{(3)}=1$<br>$z^{(4)}=\Theta^{(3)}a^{(3)}$<br>$a^{(4)}=h_\theta(x)=g(z^{(4)})$</p><ol start="4"><li><h4 id="计算L层（输出层）误差-delta-L-a-L-y-i"><a href="#计算L层（输出层）误差-delta-L-a-L-y-i" class="headerlink" title="计算L层（输出层）误差$\delta^{(L)}=a^{(L)}-y^{(i)}$"></a>计算L层（输出层）误差$\delta^{(L)}=a^{(L)}-y^{(i)}$</h4></li></ol><p>$y^{(i)}$是训练集的真实输出值。上例中，$\delta^{(4)}=a^{(4)}-y^{(i)}$</p><ol start="5"><li><h4 id="计算L-1-L-2-…-2层误差，-delta-L-1-delta-L-2-…-delta-2-；"><a href="#计算L-1-L-2-…-2层误差，-delta-L-1-delta-L-2-…-delta-2-；" class="headerlink" title="计算L-1,L-2,…,2层误差，$\delta^{(L-1)},\delta^{(L-2)},…,\delta^{(2)}$；"></a>计算L-1,L-2,…,2层误差，$\delta^{(L-1)},\delta^{(L-2)},…,\delta^{(2)}$；</h4></li></ol><p>L层之前的层的误差计算公式<br>$\delta^{(l)}=(\Theta^{(l)})^T\delta^{(l+1)} \cdot*g\prime(z^{(l)}),l \in [2,3,…L-1]$</p><p>其中$g\prime(z^{(l)})=a^{(l)} \cdot* (1-a^{(l)})$<br>因此误差计算公式等于：<br>$$ \delta^{(l)}=(\Theta^{(l)})^T\delta^{(l+1)} \cdot* a^{(l)} \cdot* (1-a^{(l)}),l \in [2,3,…L-1] $$<br>这里没有第一层误差，因为第一层就是输入值，不存在误差。</p><ol start="6"><li><h4 id="计算-Delta-，-Delta-i-j-l-Delta-i-j-l-a-j-i-delta-i-l-1-，用向量方式表示-Delta-l-Delta-l-delta-l-1-a-l-T-，其中-l-in-1-2-3-…-L-1"><a href="#计算-Delta-，-Delta-i-j-l-Delta-i-j-l-a-j-i-delta-i-l-1-，用向量方式表示-Delta-l-Delta-l-delta-l-1-a-l-T-，其中-l-in-1-2-3-…-L-1" class="headerlink" title="计算$\Delta$，$\Delta_{i,j}^{(l)} := \Delta_{i,j}^{(l)} + a_j^{(i)}\delta_i^{(l+1)}$，用向量方式表示$\Delta^{(l)} := \Delta^{(l)} + \delta^{(l+1)}(a^{(l)})^T $，其中$l \in [1,2,3,…,L-1]$"></a>计算$\Delta$，$\Delta_{i,j}^{(l)} := \Delta_{i,j}^{(l)} + a_j^{(i)}\delta_i^{(l+1)}$，用向量方式表示$\Delta^{(l)} := \Delta^{(l)} + \delta^{(l+1)}(a^{(l)})^T $，其中$l \in [1,2,3,…,L-1]$</h4></li><li><h4 id="在所有的样本集中，重复2-6步骤，计算出-Delta-l"><a href="#在所有的样本集中，重复2-6步骤，计算出-Delta-l" class="headerlink" title="在所有的样本集中，重复2-6步骤，计算出$\Delta^{(l)}$;"></a>在所有的样本集中，重复2-6步骤，计算出$\Delta^{(l)}$;</h4></li><li><h4 id="这里要加上正则化的过程："><a href="#这里要加上正则化的过程：" class="headerlink" title="这里要加上正则化的过程："></a>这里要加上正则化的过程：</h4></li></ol><p>$D_{i,j}^{(l)} = \frac{1}{m}\Delta_{i,j}^{(l)}, j=0$<br>$D_{i,j}^{(l)} = \frac{1}{m}(\Delta_{i,j}^{(l)} + \lambda\Theta_{i,j}^{(l)}), j\neq 0$</p><p>最终获得的代价函数的导数$\frac{\partial}{\partial \theta_{i,j}^{(l)}} J(\Theta)=D_{i,j}^{(l)}$</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络算法介绍</title>
      <link href="/2020/01/16/tech/machine_learning/neural_network_intro.html"/>
      <url>/2020/01/16/tech/machine_learning/neural_network_intro.html</url>
      
        <content type="html"><![CDATA[<p>在解决分类问题时，可以用逻辑回归算法，但当解决复杂的非线性分类器时，这并不是一个好的选择。<br>如果用逻辑回归来解决，首先要构造一个包含很多非线性项的逻辑回归函数。使用逻辑回归会构造一个s型函数$g$。当多项式足够多，足够复杂，会有一个非常扭曲的决策边界。这可能会出现过拟合的情况。<br>另一个问题，复杂的非线性分类器会包含有很多的特征项，要包含所有的特征项时很困难的事情，而且计算成本过大。</p><p>比如要识别一个图像是不是汽车，就要检测图像的每一个像素，这是一个非常大的计算量。因此神经网络是一个很好的选择。</p><h2 id="神经网络模型"><a href="#神经网络模型" class="headerlink" title="神经网络模型"></a>神经网络模型</h2><img width="50%" src="/images/ml_16.jpg" alt="逻辑单元"><p>这是一个最简单的神经网络的模型。左侧的是三个特征值的输入，右侧是一个输出，这是一个二元问题的神经网络模型。</p><p>一般在处理神经网络时，和逻辑回归一样，需要添加一个$x_0$的默认特征项。在神经网络里，这称之为偏置单位<br>$$ x=\left[ \begin{matrix}<br>x_0 \\ x_1 \\ x_2 \\ x_3<br>\end{matrix} \right], \theta=\left[ \begin{matrix}<br>\theta_0 \\ \theta_1 \\ \theta_2 \\ \theta_3<br>\end{matrix} \right]$$<br>还有关于$h(\theta)$的函数<br>$$ h_\theta(x) = \frac{1}{1+e^{-\theta^Tx}} $$<br>在神经网络里这个成为激励函数，这是神经网络的术语，它是和逻辑回归里相同的函数。在这种情况下，激励函数的参数$\theta$称之为权重。</p><p>看一个复杂一点的模型：</p><img width="50%" src="/images/ml_17.jpg" alt="多层神经网络"><p>上图中，第一层是<strong>输入层</strong>，然后进入第二层，最后输出预测函数，也就是第三层，<strong>输出层</strong>。<br>输入层和输出层之间的节点层，称之为<strong>隐藏层</strong>。上图中有一个隐藏层。<br>隐藏层中的$a_i^{(j)}$是第$j$层的第$i$个单元。和输入层一样，在计算时会添加一个偏置单元$a_0^{(j)}=1$<br>$$ a^{(j)}=\left[ \begin{matrix}<br>a_0^{(j)} \\ a_1^{(j)} \\ a_2^{(j)} \\  a_3^{(j)}<br>\end{matrix} \right]$$</p><p>$\theta^{(j)}$是从第$j$层到第$j+1$层的映射参数矩阵。</p><h2 id="计算过程"><a href="#计算过程" class="headerlink" title="计算过程"></a>计算过程</h2><p>隐藏层的激活节点和输出层的输出函数计算过程如下：<br>$ a_0^{(2)} = 1 $<br>$ a_1^{(2)} = g(\theta_{10}^{(1)}x_0+\theta_{11}^{(1)}x_1+\theta_{12}^{(1)}x_2+\theta_{13}^{(1)}x_3) $<br>$ a_2^{(2)} = g(\theta_{20}^{(1)}x_0+\theta_{21}^{(1)}x_1+\theta_{22}^{(1)}x_2+\theta_{23}^{(1)}x_3) $<br>$ a_3^{(2)} = g(\theta_{30}^{(1)}x_0+\theta_{31}^{(1)}x_1+\theta_{32}^{(1)}x_2+\theta_{33}^{(1)}x_3) $<br>$ h_\theta(x) = a_1^{(3)} = g(\theta_{10}^{(2)}a_0^{(2)}+\theta_{11}^{(2)}a_1^{(2)}+\theta_{12}^{(2)}a_2^{(2)}+\theta_{13}^{(2)}a_3^{(2)})$</p><p>$\theta^{(j)}$是一个矩阵，关于它的维度：<br>在第$j$层，该层有$s_j$个单元，而第$j+1$层有$s_k$个单元，则$\theta^{(j)}$会是一个$s_k\times s_j + 1$维矩阵</p><p>举个例子，假如有一个三层的神经网络，第一层有2个输入特征值，第二层是3个单元，最后第三层输出1个预测结果：<br>$\theta^{(1)}$s是一个$3\times 3$的矩阵<br>$\theta^{(2)}$s是一个$1\times 4$的矩阵</p><p>为了方便，将激励函数中的参数用变量$z$替换：<br>$ a_0^{(2)} = 1 $<br>$ a_1^{(2)} = g(z_1^{(2)}) $<br>$ a_2^{(2)} = g(z_2^{(2)}) $<br>$ a_3^{(2)} = g(z_3^{(2)}) $</p><p>其中$z$为：<br>$ z_k^{(2)}= \theta_{k,0}^{(1)}x_0 + \theta_{k,1}^{(1)}x_1 + … + \theta_{k,n}^{(1)}x_n $</p><h3 id="向量形式"><a href="#向量形式" class="headerlink" title="向量形式"></a>向量形式</h3><p>用向量的形式来表示：</p><p>$x=\left[ \begin{matrix}<br>x_0 \\ x_1 \\ x_2 \\ x_3<br>\end{matrix} \right], z^{(2)}= \left[ \begin{matrix}<br>z_1^{(2)} \\ z_2^{(2)} \\ z_2^{(2)}<br>\end{matrix} \right]$</p><p>$z^{(2)} = \theta^{(1)}x$<br>$a^{(2)} = g(z^{(2)})$</p><p>第三层：</p><p>$z^{(3)} = \theta^{(2)}z^{(2)}$</p><p>类推到通常情况：<br>$z^{(j)} = \theta^{(j-1)}a^{(j-1)}$<br>$a^{(j)} = g(z^{(j)})$<br>最后一步<br>$h_\theta(x) = a^{(j+1)} = g(z^{(j+1)})$</p><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><h3 id="1-预测“与”-AND"><a href="#1-预测“与”-AND" class="headerlink" title="1.预测“与” AND"></a>1.预测“与” AND</h3><p>$$ \left[ \begin{matrix}<br>x_0 \\ x_1 \\ x_2<br>\end{matrix} \right] → \left[ \begin{matrix}<br>g(z^{(2)})<br>\end{matrix} \right] → h_\theta(x) $$</p><p>其中$x_0 = 1$</p><p>我们要计算“与”，其中$x1,x2 \in [0,1]$，$y=x_1$ &amp;&amp; $x_2$<br>设置$\theta^{(1)} = \left[ \begin{matrix}<br>-30 &amp; 20 &amp; 20<br>\end{matrix} \right]$</p><p>通过上面的公式<br>$h_\theta(x) = \theta^{(1)}x = g(-30+20x_1+20x_2)$</p><p>$x_1=0,x_2=0$，$h_\theta(x)=g(-30)\approx 0$<br>$x_1=0,x_2=1$，$h_\theta(x)=g(-10)\approx 0$<br>$x_1=1,x_2=0$，$h_\theta(x)=g(-10)\approx 0$<br>$x_1=1,x_2=1$，$h_\theta(x)=g(10)\approx 1$</p><p>满足”与“的逻辑。</p><h3 id="2-预测“或”-OR"><a href="#2-预测“或”-OR" class="headerlink" title="2.预测“或” OR"></a>2.预测“或” OR</h3><p>与 预测“AND”的神经网络模型一样，我们只是调整一下：$\theta^{(1)} = \left[ \begin{matrix}<br>-10 &amp; 20 &amp; 20<br>\end{matrix} \right]$</p><p>$h_\theta(x) = \theta^{(1)}x = g(-10+20x_1+20x_2)$</p><p>$x_1=0,x_2=0$，$h_\theta(x)=g(-10)\approx 0$<br>$x_1=0,x_2=1$，$h_\theta(x)=g(10)\approx 1$<br>$x_1=1,x_2=0$，$h_\theta(x)=g(10)\approx 1$<br>$x_1=1,x_2=1$，$h_\theta(x)=g(30)\approx 1$</p><p>满足”或“的逻辑。</p><h3 id="3-预测“异或”-XOR"><a href="#3-预测“异或”-XOR" class="headerlink" title="3.预测“异或” XOR"></a>3.预测“异或” XOR</h3><p>$$ \left[ \begin{matrix}<br>x_0 \\ x_1 \\ x_2<br>\end{matrix} \right] → \left[ \begin{matrix}<br>a_0^{(2)} \\ a_1^{(2)} \\ a_2^{(2)}<br>\end{matrix} \right] → \left[ \begin{matrix}<br>g(z^{(3)})<br>\end{matrix} \right] → h_\theta(x) $$</p><p>其中$x_0=1,a_0^{(2)}=1$</p><p>$\theta^{(1)} = \left[ \begin{matrix}<br>-10 &amp; 20 &amp; 20 \\ 40 &amp; -30 &amp; -30<br>\end{matrix} \right], \theta^{(2)} = \left[ \begin{matrix}<br>-30 &amp; 20 &amp; 20<br>\end{matrix} \right] $</p><p>$a^{(2)} = \theta^{(1)}x$，$h_\theta(x)=a^{(3)}=\theta^{(2)}a^{(2)}$</p><p>$x_1=0,x_2=0$，$a^{(2)}=\left[ \begin{matrix}<br>1 \\ g(-10)\\ g(40)<br>\end{matrix} \right]\approx\left[ \begin{matrix}<br>1 \\ 0 \\ 1<br>\end{matrix} \right]$，$h_\theta(x)=g(-10)\approx 0$</p><p>$x_1=0,x_2=1$，$a^{(2)}=\left[ \begin{matrix}<br>1 \\ g(10) \\ g(10)<br>\end{matrix} \right]\approx\left[ \begin{matrix}<br>1 \\ 1 \\ 1<br>\end{matrix} \right]$，$h_\theta(x)=g(10)\approx 1$</p><p>$x_1=1,x_2=0$，$a^{(2)}=\left[ \begin{matrix}<br>1 \\ g(10) \\ g(10)<br>\end{matrix} \right]\approx\left[ \begin{matrix}<br>1 \\ 1 \\ 1<br>\end{matrix} \right]$，$h_\theta(x)=g(10)\approx 1$</p><p>$x_1=1,x_2=1$，$a^{(2)}=\left[ \begin{matrix}<br>1 \\ g(30) \\ g(-20)<br>\end{matrix} \right]\approx\left[ \begin{matrix}<br>1 \\ 1 \\ 0<br>\end{matrix} \right]$，$h_\theta(x)=g(-10)\approx 0$</p><p>这符合“异或”的逻辑。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 神经网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分类算法中多元分类</title>
      <link href="/2020/01/15/tech/machine_learning/one_vs_all.html"/>
      <url>/2020/01/15/tech/machine_learning/one_vs_all.html</url>
      
        <content type="html"><![CDATA[<p>判断垃圾邮件，这个分类问题的输出是[0, 1]，只有固定的两个输出值，这称之为二元分类问题。<br>在生活中有许多另外的分类问题，给定一张数字的图像，判断是数字几；自动将邮件归类，归为工作，朋友，家人等等，这就是一个多元分类问题了。</p><p>原来的二元分类$y\in[0,1]$，多元分类就需要扩展一下$y\in[1,2,3,…,n]$</p><h2 id="问题说明"><a href="#问题说明" class="headerlink" title="问题说明"></a>问题说明</h2><p>假如我们有一组训练集$X$，输出有三项$y\in[1,2,3]$，我们可以将问题拆分成3个二元问题，在每一个问题中，预测$y$的输出值的概率；<br>即先预测为1的概率，再预测为2的概率，再预测为3的概率，比较三个概率的大小，取其中最大的概率，就是$y$最可能的输出值。</p><p>再一般化一点：<br>$y\in[1,2,3,…,n]$<br>y有n个输出，所以要分成n个二元问题，n个预测函数：<br>$h_\theta^{(1)}(x)=P(y=1|x; \theta)$ ；y=1的概率<br>$h_\theta^{(2)}(x)=P(y=2|x; \theta)$ ；y=2的概率<br>…<br>$h_\theta^{(n)}(x)=P(y=n|x; \theta)$ ；y=n的概率<br>然后比较这n个预测函数的输出值，取其最大概率的一个。</p><h3 id="多元问题的输出"><a href="#多元问题的输出" class="headerlink" title="多元问题的输出"></a>多元问题的输出</h3><p>在实际应用上，多元问题的输出并不是一个值，而是一个向量。<br>例如：$y\in[1,2,3]$，$y$的输出值有三个可能，因此，$y$的输出是一个三维的向量$\left[ \begin{matrix} y_1 \\ y_2 \\ y_3 \end{matrix} \right]$，其中$y_1,y_2,y_3\in[0,1]$，向量的三个值都是取0和1这两个值。<br>比如说$y=\left[ \begin{matrix} 1 \\ 0 \\ 0 \end{matrix} \right]$，就是说明y最大概率的值是1；$y=\left[ \begin{matrix} 0 \\ 0 \\ 1 \end{matrix} \right]$，说明最大概率的值是3。</p><h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>在处理多元问题时，处理训练集的输出$y$时，应当将输出的实际标量转换成向量的形式：<br>例如，$y\in[1,2,3]$，$y$在1,2,3中选择。<br>我们有5个样本集，忽略输入，观察到输出为：<br>$y=\left[ \begin{matrix}<br>2 \\ 1 \\ 1 \\ 3 \\ 2<br>\end{matrix} \right]$<br>要方便计算，将向量的各个值在转换一下：<br>$y=\left[ \begin{matrix}<br>0&amp;1&amp;0 \\ 1&amp;0&amp;0 \\ 1&amp;0&amp;0 \\ 0&amp;0&amp;1 \\ 0&amp;1&amp;0<br>\end{matrix} \right]$<br>可以看出原来是一个五维的向量，每个值是标量，经过转换后每一个标量都转成一个向量，形成的一个 $5\times3$ 的矩阵，可以看到，第一行第二列的元素为1，其他为0，对应这原来y内的第一个标量2。以此类推，一一对应。</p><p>这是训练集的输出，再看一下预测值的处理，经过分类算法的计算，得出的5个样本的预测函数值为：<br>$h_\theta(x)=\left[ \begin{matrix}<br>0.2&amp;0.9&amp;0.1 \\ 0.78&amp;0.13&amp;0.3 \\ 0.88&amp;0.3&amp;0.2 \\ 0.2&amp;0.1&amp;0.92 \\ 0.2&amp;0.98&amp;0.1<br>\end{matrix} \right]$<br>比较这个矩阵的每一行中三列，这三列就是三个预测函数的预测值。比较后记录下最大的值是第几列：<br>$h_\theta(x)=\left[ \begin{matrix}<br>2 \\ 1 \\ 1 \\ 3 \\ 2<br>\end{matrix} \right]$<br>这样就训练好了一个多元分类的样本集。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 非监督学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>过拟合（Overfitting）和正则化（Regularized）</title>
      <link href="/2020/01/14/tech/machine_learning/overfitting_and_regularized.html"/>
      <url>/2020/01/14/tech/machine_learning/overfitting_and_regularized.html</url>
      
        <content type="html"><![CDATA[<p>在应用线性回归和逻辑回归去解决某些机器学习的实际应用时，它们可能会出现一种叫做“过度拟合”（Overfitting）的问题。这会使得学习的结果很糟糕。</p><h2 id="什么是过拟合"><a href="#什么是过拟合" class="headerlink" title="什么是过拟合"></a>什么是过拟合</h2><p>用预测房价的线性回归的例子：</p><p><img src="/images/ml_15.jpg" alt="线性回归图表"></p><p>最左边一张图片用一条直线来拟合数据，这种情况下随着x轴的变大，房价增长的幅度一直不变，这样的结果误差很大，这意味这该算法没有很好的拟合训练数据，<br>这种称之为 <strong>“欠拟合”</strong>；</p><p>中间一张图用的二次曲线来拟合数据，拟合情况良好，稍有偏差；</p><p>右边一张图用了四次项，拟合的更好，在图中，它贯穿了所有样本，但是它的曲线很扭曲，这不是一个很好的预测房价的模型，这称之为 <strong>“过拟合”</strong>；</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>过拟合：</strong> 假如有很多特征值，且学习算法能够很好的拟合训练集，但是在新的样本上却表现的性能很差。</p><p>数据拟合有两个极端，当预测函数过于简单或者使用的相关特征值过少，就会出现<strong>欠拟合（高偏差high bias）</strong>的情况。<br>另一个极端，当函数过于复杂，使用的非常多的特征值，使得学习算法在训练样本上非常适合，但是不能推广到新的样本集上，这就是<strong>过拟合（高方差high variance）</strong></p><p>过拟合问题除了出现在线性回归问题上，也会出现在逻辑回归上。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><ol><li>减少特征值的数量<br>可以通过观察手动删掉一些特征值，或者用模型选择算法来达到目的。</li><li>正则化<br>保留所有特征值，但是减少参数$\theta_j$的大小，因为似乎每个特征值都或多或少的在预测函数起了作用。</li></ol><p>这两种方法的本质类似，就是弱化不必要的特征值，从而解决过拟合。</p><h2 id="代价函数"><a href="#代价函数" class="headerlink" title="代价函数"></a>代价函数</h2><p>假设线性回归的预测函数为：<br>$$ h(\theta) = \theta_0+\theta_1x+\theta_2x^2+\theta_3x^3+\theta_4x^4 $$</p><p>这是一个四次项的公式，通过上面的可以知道这是一个过拟合的预测函数，需要解决过拟合，需要忽略后面的三次和四次项，这要改一下代价函数：</p><p>$$ J(\theta) = \frac{1}{2m} \sum_{i=0}^m(h_\theta(x^{(i)})-y^{(i)})^2 +1000\cdot \theta_3^2 +1000\cdot \theta_4^2 $$</p><p>在原油的代价函数上我们添加了$1000\cdot \theta_3^2$和$1000\cdot \theta_4^2$这两个，为了使代价函数尽量小，我们就需要让$\theta_3$和$\theta_4$尽量小，接近于零。</p><p>这样就给了一个正则化的思路。将关联小的特征值的参数趋向于0，使得预测函数从过拟合的状态修正过来。</p><p>正则化后的代价函数为：<br>$$ J(\theta)= \frac{1}{2m} \sum_{i=0}^m (h_\theta(x^{(i)})-y^{(i)})^2 + \lambda \sum_{j=1}^n\theta_j^2 ] $$</p><p>其中$\lambda$为正则化参数，为了平衡代价函数。$\lambda$需要选择合适的值。</p><p>可以看到，在代价函数后面添加了$\lambda \sum_{j=1}^n\theta_j^2$ 这一项。注意，这一项中的$j$ 是从1到m的，因为$x_0$固定为0，不需要修正，所以参数$\theta_0$，不需要添加进来。</p><h2 id="线性回归正则化"><a href="#线性回归正则化" class="headerlink" title="线性回归正则化"></a>线性回归正则化</h2><p>梯度下降算法：<br>重复 {<br>$$ \theta_0 = \theta_0-\alpha\frac{1}{m} \sum_{i=1}^m (h_\theta(x^{(i)})-y^{(i)})x_0^{(i)} $$<br>$$ \theta_j = \theta_j -\alpha [\frac{1}{m}\sum_{i=1}^m (h_\theta(x^{(i)})-y^{(i)})x_j^{(i)} +\frac{\lambda}{m}\theta_j ], j \in [1,2,3,…,n] $$<br>}</p><p>同样的$\theta_0$不需要修正</p><p>下面的式子可以稍作调整：<br>$$ \theta_j = \theta_j(1-\alpha\frac{\lambda}{m}) -\alpha\frac{1}{m}\sum_{i=1}^m (h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}, j \in 1,2,3,…,n] $$</p><p>可以看出$\theta_j$是在原来梯度下降的基础上有减去了$\alpha\frac{\lambda}{m}\theta_j$</p><h2 id="逻辑回归正则化"><a href="#逻辑回归正则化" class="headerlink" title="逻辑回归正则化"></a>逻辑回归正则化</h2><p>代价函数：<br>$$ J(\theta)=-\frac{1}{m} \sum_{i=1}^m [y^{(i)} \log(h_\theta(x^{(i)})) + (1-y^{(i)}) \log(1-h_\theta(x^{(i)}))] + \frac{\lambda}{2m} \sum_{j=1}^n \theta_j^2 $$</p><p>同样的$\theta_0$不需要修正</p><p>它的梯度下降算法是：</p><p>重复 {<br>$$ \theta_0 = \theta_0-\alpha\frac{1}{m} \sum_{i=1}^m (h_\theta(x^{(i)})-y^{(i)})x_0^{(i)} $$<br>$$ \theta_j = \theta_j -\alpha [\frac{1}{m}\sum_{i=1}^m (h_\theta(x^{(i)})-y^{(i)})x_j^{(i)} +\frac{\lambda}{m}\theta_j ], j \in [1,2,3,…,n] $$<br>}</p><h2 id="正规方程（Normal-Equation）"><a href="#正规方程（Normal-Equation）" class="headerlink" title="正规方程（Normal Equation）"></a>正规方程（Normal Equation）</h2><p>在求解线性回归时，除了梯度下降，还有一种正规方程的方式直接求解出$\theta$。使用正规方程的也需要正则化。</p><p>正规方程的公式为：<br>$$ \theta=(X^TX)^{-1}X^Ty $$</p><p>需要作出修改：<br>$$ \theta=(X^TX + \lambda\cdot L)^{-1}X^Ty $$</p><p>其中L是一个$n+1$的方阵 $L=\left[ \begin{matrix}<br>0&amp;&amp;&amp;&amp; \\ &amp;1&amp;&amp;&amp; \\ &amp;&amp;1&amp;&amp; \\ &amp;&amp;&amp;…&amp; \\ &amp;&amp;&amp;&amp;1<br>\end{matrix} \right]$，L是一个对角线矩阵，对角线第一个元素为0。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 算法优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于逻辑回归模型的梯度下降算法</title>
      <link href="/2020/01/11/tech/machine_learning/classification_gradient_descent.html"/>
      <url>/2020/01/11/tech/machine_learning/classification_gradient_descent.html</url>
      
        <content type="html"><![CDATA[<p>逻辑回归的代价函数：</p><p>$$ J(\theta)=-\frac{1}{m} \sum_1^m [y^{(i)} \log(h_\theta(x^{(i)})) + (1-y^{(i)}) \log(1-h_\theta(x^{(i)}))]  $$</p><p>与线性回归一样，它的梯度下降算法类似：</p><p>重复直到$J(\theta)$收敛 {<br>$  \theta_j:=\theta_j−\alpha \frac{\partial}{\partial \theta_j} J(\theta) $<br>}</p><p>计算$\frac{\partial}{\partial \theta_j} J(\theta)$后会得到：<br>$$ \theta_j:=\theta_j−\alpha \frac{1}{m} \sum_{i=0}^m((h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}), j \epsilon \left(0, 1, 2,…,n\right) $$</p><p>计算后得到的和线性回归的看上去没有区别，但是两者的$h_\theta(x)$不同。<br>线性回归的是：$h_\theta(x) = \theta^Tx$<br>逻辑回归的是：$h_\theta(x) = \frac{1}{1+e^{-\theta^Tx}} $</p><p>因为预测函数改变了，所以两者的梯度下降算法是不一样的。</p><h2 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h2><p>假设数据集有5个样本，每个样本有2个特征值，即$m=5,n=2$如下：</p><p>$$ X = \left[ \begin{matrix}<br>34.62 &amp; 78.02 \\ 30.29 &amp; 3.89 \\ 35.85 &amp; 72.9 \\ 60.18 &amp; 86.31 \\ 79.03 &amp; 75.34<br>\end{matrix} \right], y = \left[ \begin{matrix}<br>0 \\ 0 \\ 0 \\ 1 \\ 1<br>\end{matrix} \right]$$</p><p>初始化$\theta=\left[ \begin{matrix} 0\\0\\0 \end{matrix} \right]$，然后在输入矩阵加上一列$x_0=1$，<br>$ X = \left[ \begin{matrix}<br>1 &amp; 34.62 &amp; 78.02 \\ 1 &amp; 30.29 &amp; 3.89 \\ 1 &amp; 35.85 &amp; 72.9 \\ 1 &amp; 60.18 &amp; 86.31 \\ 1 &amp; 79.03 &amp; 75.34<br>\end{matrix} \right]$</p><p>先计算预测函数$h$：<br>$h=g(X\theta)$<br>$X\theta = \left[ \begin{matrix}<br>1 &amp; 34.62 &amp; 78.02 \\ 1 &amp; 30.29 &amp; 3.89 \\ 1 &amp; 35.85 &amp; 72.9 \\ 1 &amp; 60.18 &amp; 86.31 \\ 1 &amp; 79.03 &amp; 75.34<br>\end{matrix} \right] \left[ \begin{matrix}<br>0 \\ 0 \\ 0<br>\end{matrix} \right] = \left[ \begin{matrix}<br>0 \\ 0 \\ 0<br>\end{matrix} \right]$<br>代入$g$函数，可以的得到预测结果$h=\left[ \begin{matrix}<br>\frac{1}{1+e^0} \\ \frac{1}{1+e^0} \\ \frac{1}{1+e^0}\\ \frac{1}{1+e^0}\\ \frac{1}{1+e^0}<br>\end{matrix} \right]=\left[ \begin{matrix}<br>0.5 \\ 0.5 \\ 0.5 \\ 0.5 \\ 0.5<br>\end{matrix} \right]$</p><p>代入J的公式<br>$$ J(\theta)=\frac{1}{m} \cdot (-y^T \log(h) -(1-y)^T \log(1-h)) $$<br>此时代价函数$J$的值为：$\color{red}{0.69315}$</p><p>下面计算第一次梯度下降的梯度值，代入下面的公式<br>$$ \theta = \theta - \frac{\alpha}{m} X^T(h-y) $$</p><p>即：<br>$ \theta = \theta - \alpha\frac{1}{5} \cdot \left[ \begin{matrix}<br>1 &amp; 1 &amp; 1 &amp; 1 &amp; 1 \\ 34.62 &amp; 30.29 &amp; 35.85 &amp; 60.18 &amp; 79.03 \\ 78.02 &amp; 3.89 &amp; 72.9 &amp; 86.31 &amp; 75.34<br>\end{matrix} \right] \left[ \begin{matrix}<br>0.5 - 0 \\ 0.5-0 \\ 0.5-0 \\ 0.5-1 \\ 0.5-1<br>\end{matrix} \right] = \left[ \begin{matrix}<br>0 \\ 0 \\ 0<br>\end{matrix} \right] - \alpha \cdot \left[ \begin{matrix}<br>0.1 \\ -3.846 \\ 3.317<br>\end{matrix} \right]$</p><p>假设$\alpha=0.01$，则$\theta=\left[ \begin{matrix}<br>0.001 \\ 0.03846 \\ -0.03317<br>\end{matrix} \right]$</p><p>再次计算代价函数$J$为：$\color{red}{0.51494}$</p><p>这个例子用矩阵和向量来进行了代价函数和梯度下降的计算。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 监督学习 </tag>
            
            <tag> 逻辑回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑回归模型的代价函数</title>
      <link href="/2020/01/11/tech/machine_learning/classification_cost_function.html"/>
      <url>/2020/01/11/tech/machine_learning/classification_cost_function.html</url>
      
        <content type="html"><![CDATA[<p>假设有训练集有m个样本<br>$$ (x^{(1)},y^{(1)}),(x^{(2)},y^{(2)}),(x^{(3)},y^{(3)}),…,(x^{(m)},y^{(m)}) $$<br>有n个特征值<br>$$ x \in \left[ \begin{matrix} x_0 \\ x_1 \\ x_2 \\ … \\ x_n \end{matrix} \right], x_0=1,y \in [0, 1] $$<br>预测函数<br>$$ h_\theta(x) = \frac{1}{1+e^{-\theta^Tx}} $$</p><p>与线性回归类似，先要获得逻辑回归的代价函数：<br>$$ J(\theta)=\frac{1}{m} \sum_{i=1}^m Cost(h_\theta(x^{(i)}), y^{(i)}) $$</p><p>这个和线性回归的代价函数类似，只是替换了：<br>$$ Cost(h_\theta(x), y) = \frac{1}{2} (h_\theta(x^{(i)})-y^{(i)})^2 $$</p><p>上面的是线性回归的 $Cost$ 函数的值，在逻辑回归模型中，该函数为：<br>$$ Cost(h_\theta(x), y) = \begin{cases} -\log(h_\theta(x)), y=1 \\ -\log(1-h_\theta(x)), y=0 \end{cases} $$</p><p>在这样的情况下</p><ul><li>当 $y=1, h_\theta(x)=1$ 时，可以得到 $Cost(h_\theta(x), y)=0$；</li><li>当 $y=1, h_\theta(x)=0$ 时，可以得到 $Cost(h_\theta(x), y)→\infty$；</li><li>当 $y=0, h_\theta(x)=0$ 时，可以得到 $Cost(h_\theta(x), y)=0$；</li><li>当 $y=0, h_\theta(x)=1$ 时，可以得到 $Cost(h_\theta(x), y)→\infty$；</li></ul><p>这样总结一下就是当 $y=h_\theta(x)$ ,代价函数的值为0，当两者不等时，单价函数的值为去穷大，这符合代价函数的定义。</p><p>两种情况下的$Cost$函数可以合并为一个：<br>$$ Cost(h_\theta(x), y) = -y \log(h_\theta(x)) - (1-y) \log(1-h_\theta(x)) $$</p><p>这样$\color{red}{逻辑回归的代价函数}$：</p><p>$$ J(\theta)=-\frac{1}{m} \sum_{i=1}^m [y^{(i)} \log(h_\theta(x^{(i)})) + (1-y^{(i)}) \log(1-h_\theta(x^{(i)}))]  $$</p><p>用向量的形式来表示则是：</p><p>$$ h = g(X\theta) $$<br>$$ J(\theta)=\frac{1}{m} \cdot (-y^T \log(h) -(1-y)^T \log(1-h)) $$</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 监督学习 </tag>
            
            <tag> 逻辑回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分类和逻辑回归模型（Logistic Regression）</title>
      <link href="/2020/01/09/tech/machine_learning/classification.html"/>
      <url>/2020/01/09/tech/machine_learning/classification.html</url>
      
        <content type="html"><![CDATA[<p><strong>分类</strong>是监督学习的一种，是目前使用很广泛的一种算法。</p><p>比如说：</p><ul><li>判断垃圾邮件</li><li>判断交易是否是骗人的</li><li>判断肿瘤是否是恶性的</li></ul><p>这些例子有一个共同的特点，它们的输出$y\in \left[0, 1\right]$<br>0: 表示负类（negative class），例如，不是垃圾邮件；<br>1: 表示正类（positive class），例如，是垃圾邮件。</p><p>把那一类归为 “正类” 一般是看输出值所占比例的大小，占小比例的一般被当作 “正类” 。</p><p>当然$y$也可以有多个输出，例如$y\in \left[0, 1,2,3…n\right]$, 这是一个多类的问题，在了解多类问题前，先了解一下二元分类（binary classification problem）的情况。</p><p>![二元分类的输入输出图][1]</p><p>上图是随着肿瘤的大小，判断恶性肿瘤的散点图。可以看出输出只在0和1这两个值之间交替</p><p>我们先忽略$y$是离散值，采用旧的线性回归算法来尝试预测$y$。 先使用线性回归的预测函数</p><p>$$ h_\theta(x) = \theta_0x_0 + \theta_1x_1 = \theta^Tx $$</p><p>这样得出的预测是一条直线，但是这样的预测函数，我们会得到$h_\theta &gt; 1$或者$h_\theta &lt; 0$的情况出现，这样的结果是不准确的。我们期望是有一个预测函数，它的输出值在0到1之间：</p><p>$$ h_\theta(x) = g(\theta^Tx) $$</p><p>$g$函数是一个关于指数的S型函数（Sigmoid Function）：</p><p>$$ g(z) = \frac{1}{1+e^{-z}} $$</p><p>其中参数 $z=\theta^Tx$</p><p>所以分类问题的预测函数可以写成：</p><p>$$ h_\theta(x) = \frac{1}{1+e^{-\theta^Tx}} $$</p><img width="50%" src="/images/ml_12.jpg" alt="$g$函数的曲线图"><p>这是$g$函数的曲线图，从图中，可以看出输出值的范围在0到1之间，这个满足我们需要的条件，当$z$越小是就无限趋向于0，反之则无限趋向于1。</p><p>该函数得到的是连续的值，而分类算法需要的到的是离散的数（0, 1），因此我们可以将$g$函数得到的值看成是输出某个值的概率。</p><p>假设使用该预测函数得到$h(\theta)=0.7$，我们可以认为肿瘤是恶性的概率是70%，可以用一个式子表示：<br>$$ h(\theta)=P(y=1|x; \theta) $$<br>该式子表示在给定特征$x$和对应的参数$\theta$下，$y=1$的概率。</p><p>因为$y$只能在(0, 1)的范围内，所以<br>$$ P(y=1|x; \theta)+P(y=0|x; \theta) = 1 $$</p><h2 id="决策边界-decision-boundary"><a href="#决策边界-decision-boundary" class="headerlink" title="决策边界(decision boundary)"></a>决策边界(decision boundary)</h2><p>假设预测当函数返回值$h(\theta)\geq 0.5$ 时认定$y=1$，即当概率大于50%则认为会发生。<br>$h(\theta)\geq 0.5 → y=1$<br>$h(\theta)&lt; 0.5 → y=0$</p><p>当参数$z\geq 0$时，$g(z)\geq 0.5$，这样就要求:<br>$\theta^Tx \geq 0$</p><p>所以预测结果可以写成：<br>$\theta^Tx \geq 0 → y=1$<br>$\theta^Tx &lt; 0 → y=0$</p><p>因此$\theta^Tx$就是决策边界，当大于等于的就是$y=1$，当小于的就是$y=0$。</p><p>例子：<br>假如预测函数$h(\theta)=g(\theta_0+\theta_1x_1+\theta_2x_2)$，以及参数$(\theta_0,\theta_1,\theta_2)$分别为(-3,1,1)，这样这个预测函数的决策边界就是：<br>$$ -3+x_1+x_2 \geq 0 $$</p><img width="50%" src="/images/ml_13.jpg" alt="决策边界"><p>上图红线就是决策边界，在红线的右上方就是$y=1$，左下方就是$y=0$。</p><p>除了线性的决策边界，还可以是更复杂的非线性的。例如<br>$h(\theta)=g(\theta_0+\theta_1x_1^2+\theta_2x_2^2)$。且$\theta_0=-1,\theta_1=1,\theta_2=1$<br>这个的决策边界就是：<br>$$ -1 + x_1^2 + x_2^2 \geq 0 $$<br>这个的图像就是一个圆形。</p><img width="50%" src="/images/ml_14.jpg" alt="非线性条件决策边界"><p>在圆形之外的$y=1$，在圆内的就是$y=0$。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 监督学习 </tag>
            
            <tag> 逻辑回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正规方程（Normal Equation）</title>
      <link href="/2020/01/05/tech/machine_learning/normal_equation.html"/>
      <url>/2020/01/05/tech/machine_learning/normal_equation.html</url>
      
        <content type="html"><![CDATA[<p>针对某些线性回归问题，除了梯度下降算法，有一个更好的方法来求出最优解，就是<strong>正规方程（Normal Equation）</strong></p><p>与梯度下降算法采用求导，然后迭代计算的方法不同，正规方程采用的矩阵的求解，方便快捷，但也有一些弊端。</p><p>房价的例子：</p><table><thead><tr><th align="left">$x_0$</th><th align="left">尺寸$x_1$</th><th align="left">房间数$x_2$</th><th align="left">房屋年份$x_3$</th><th align="left">价格$y$</th></tr></thead><tbody><tr><td align="left">1</td><td align="left">2104</td><td align="left">5</td><td align="left">45</td><td align="left">460</td></tr><tr><td align="left">1</td><td align="left">1416</td><td align="left">3</td><td align="left">40</td><td align="left">232</td></tr><tr><td align="left">1</td><td align="left">1534</td><td align="left">3</td><td align="left">30</td><td align="left">315</td></tr><tr><td align="left">1</td><td align="left">852</td><td align="left">2</td><td align="left">36</td><td align="left">178</td></tr><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td><td align="left">…</td><td align="left">…</td></tr></tbody></table><p>和之前不同的是，这个在前面加了一列$x_0$，而这一列的值都是1。</p><p>下面用矩阵的形式来展现这个数据集：<br>$$ X=\left[ \begin{matrix} 1 &amp; 2104 &amp; 5 &amp; 45 \\ 1 &amp; 1416 &amp; 3 &amp; 40 \\ 1 &amp; 1534 &amp; 3 &amp; 30 \\ 1 &amp; 852 &amp; 2 &amp; 36 \end{matrix} \right], y=\left[ \begin{matrix} 460 \\ 232 \\ 315 \\ 178 \end{matrix} \right] $$</p><p>$X$为$m \times (n+1)$维矩阵，$y$为$m$维向量</p><p>正规方程的公式为：<br>$$ \theta=(X^TX)^{-1}X^Ty $$</p><p>$X^T$ 是矩阵 $X$ 的转置，$(X^TX)^{-1}$ 是矩阵 $X^TX$ 的逆矩阵</p><p>通过这个公式的到的$\theta$ 会最小化线性回归的代价函数 $J(\theta)$，和梯度下降算法不同的是，正规方程不需要采用特征值缩放。</p><p><strong>何时采用正规方程，何时采用梯度下降</strong></p><p>这是两种算法之间的差距</p><table><thead><tr><th align="left"></th><th align="left">梯度下降</th><th align="left">正规方程</th></tr></thead><tbody><tr><td align="left"><strong>学习率($\alpha$)</strong></td><td align="left">需要选择学习率($\alpha$)</td><td align="left">不需要学习率($\alpha$)</td></tr><tr><td align="left"><strong>迭代</strong></td><td align="left">需要迭代很多次</td><td align="left">不需要迭代</td></tr><tr><td align="left"><strong>复杂度</strong></td><td align="left">$O(kn^2)$</td><td align="left">$O(n^3)$，因为需要计算$(X^TX)^{-1}$</td></tr><tr><td align="left"><strong>多特征值</strong></td><td align="left">当特征值n非常大时，性能好</td><td align="left">当特征值n非常大时，性能差</td></tr></tbody></table><p>正规方程不需要选择学习率($\alpha$)，也不要迭代很多次，这点在计算的繁琐程度上是优于梯度下降的。<br>正规方程的劣势是在计算 $(X^TX)^{-1}$ 这个公式上面，$X$是一个$m \times (n+1)$的矩阵，那么$X^TX$则为$m$维的方阵，这个过程的复杂度相当于$O(n^2)$，在计算该矩阵的逆矩阵，就相当于$O(n^3)$的复杂度。当n很大时，正规方程的复杂度就比梯度下降大得多，也就更加耗时。</p><p>用此当n较大时，选择梯度下降性能会更好；当n较小时，选择正规方程会更好的计算$\theta$。</p><p>在实践中，当n超过10000时，可以考虑选择梯度下降算法。</p><h2 id="关于逆矩阵的一些问题"><a href="#关于逆矩阵的一些问题" class="headerlink" title="关于逆矩阵的一些问题"></a>关于逆矩阵的一些问题</h2><p>在求解 $(X^TX)$ 的逆矩阵时，可能会遇到该矩阵不可逆，造成这种情况的原因是：</p><ul><li>在特征值中有冗余的特征，例如在预测房价中，有一列特征值是以平方英尺为单位计算的房子大小，又有一列是以平方米的单位来计算房子大小，这样两个特征值就是冗余的，两个只要取其中一个就好了；</li><li>特征值过多，当特征值大于样本数时，即$m\leq n$。遇到这样的，删掉一个关联不大的特征值，或者使用正则化(regularization)来解决。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>特征值缩放</title>
      <link href="/2020/01/03/tech/machine_learning/feature_scaling.html"/>
      <url>/2020/01/03/tech/machine_learning/feature_scaling.html</url>
      
        <content type="html"><![CDATA[<p>下面用房价的例子来说明一下梯度下降算法。</p><p><strong>假设训练集中有四个训练样本：</strong><br>$x=\left[ \begin{matrix} 2104 &amp; 5 &amp; 45 \\ 1416 &amp; 3 &amp; 40 \\ 1534 &amp; 3 &amp; 30 \\ 852 &amp; 2 &amp; 36 \end{matrix} \right], y=\left[ \begin{matrix} 460 \\ 232 \\ 315 \\ 178 \end{matrix}\right]$</p><p><strong>假设预测函数为：</strong><br>$ h_\theta(x) = \theta_0x_0 + \theta_1x_1 + \theta_2x_2 + \theta_3x_3 $<br>代价函数为：<br>$ J(\theta) = \frac{1}{2m} \sum_{i=0}^m(h_\theta(x^{(i)})-y^{(i)})^2 $</p><p><strong>梯度下降算法为：</strong><br>重复直到$J(\theta)$收敛 {<br>$ \theta_j:=\theta_j - \alpha \frac{1}{m} \sum_{i=0}^m((h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}), j \epsilon \left(0, 1, 2,…,n\right) $<br>}</p><p><strong>设置初始值：</strong> $\theta_0=0,\theta_1=0,\theta_2=0,\theta_3=0$; 学习率$\alpha=0.01$<br><strong>初始的梯度值为</strong> $J(\theta)=4.9542\times10^{4}$</p><p>进行<strong>第一步梯度下降</strong>：<br>$\theta_0:=0-0.01\times((0-460)\times1+(0-232)\times1+(0-315)\times1+(0-178)\times1)／4 = 2.9625$<br>$\theta_1:=0-0.01\times((0-460)\times2104+(0-232)\times1416+(0-315)\times1534+(0-178)\times852)／4 = 4828.045$<br>$\theta_2:=0-0.01\times((0-460)\times5+(0-232)\times3+(0-315)\times3+(0-178)\times2)／4 = 10.7425$<br>$\theta_3:=0-0.01\times((0-460)\times45+(0-232)\times40+(0-315)\times30+(0-178)\times36)／4 = 114.595$</p><p>算得<strong>代价函数值为</strong>$J(\theta)=3.9024\times10^{10}$。</p><p>比较两次的代价函数值，发现梯度下降后反而上升了，这里的原因是什么。</p><h2 id="原因说明"><a href="#原因说明" class="headerlink" title="原因说明"></a>原因说明</h2><p>在上面的例子中，<br>$x_1$ 的范围是从 852 到 2104， $x_2$的范围是从2 到 5，两个特征值的范围差距很大，这样会导致在梯度下降时，需要花费更多的时间，才能收敛到最小值，在这期间梯度值还会来回波动。</p><p>这就要求每项特征值都要在大致相同的范围内。这样梯度下降会很快到达最低点，完成收敛。</p><p>理想情况下，我们可以让每个特征值都修改到<br>$-1\leq x_i \leq1$ 或者 $-0.5\leq x_i \leq 0.5$ </p><p>一般情况下有两种办法可以达到目的，是<strong>特征缩放(feature scaling)</strong>和<strong>均值归一化(mean normalization)</strong></p><p><strong>特征缩放(feature scaling)</strong><br>特征缩放就是将特征值除以该特征值的范围（最大值减去最小值）<br>$$ x_i := \frac{x_i}{x_i(max) - x_i(min)} $$</p><p>应用到上面的例子，可以得到修改后的特征值矩阵：<br>$$ x=\left[ \begin{matrix} 1.6805 &amp; 1.67 &amp; 3 \\ 1.131 &amp; 1 &amp; 2.67 \\ 1.2252 &amp; 1 &amp; 2 \\ 0.6805 &amp; 0.67 &amp; 2.4 \end{matrix} \right] $$</p><p><strong>均值归一化(mean normalization)</strong><br>均值归一化用特征值减去这些特征值的平均数，然后用减去的值除以该特征值的范围<br>$$ x_i := \frac{x_i - \mu_i}{x_i(max) - x_i(min)} $$</p><p>$\mu_i$即为平均数<br>应用到上面的例子，可以得到修改后的特征值矩阵：<br>$$ x=\left[ \begin{matrix} 0.5012 &amp; 0.5833 &amp; 0.4833 \\ -0.0483 &amp; 0 &amp; 0.15 \\ 0.0459 &amp; 0 &amp; -0.5167 \\ -0.4988 &amp; -0.3077 &amp; -0.1167 \end{matrix} \right] $$</p><p>这样就得到了范围相近的特征值。注意，这两种方法得到的结果不同。</p><p>下面将归一化后的特征值代入到开始的例子中去，经过一次梯度下降后，可以的到:<br>$J(\theta)= 4.8571\times10^{4}$</p><p>计算过程和上方类似，这里不在列出，可以看到梯度值下降了，梯度下降算法是有效的。<br>当然这边我们的数据集只有4个样本，这只是举例所用，从中我们可以看出特征值缩放的作用，可以帮助我们更好的实现梯度下降算法。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 算法优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多变量线性回归问题</title>
      <link href="/2020/01/03/tech/machine_learning/multiple_features_for_linear_regression.html"/>
      <url>/2020/01/03/tech/machine_learning/multiple_features_for_linear_regression.html</url>
      
        <content type="html"><![CDATA[<p>房价的例子，当只有一个特征变量时，线性回归的预测函数：<br>$$ h_\theta(x) = \theta_0 + \theta_1x $$</p><p>现在有了多个特征变量：</p><table><thead><tr><th align="left">尺寸$x_1$</th><th align="left">房间数$x_2$</th><th align="left">房屋年份$x_3$</th><th align="left">价格$y$</th></tr></thead><tbody><tr><td align="left">2104</td><td align="left">5</td><td align="left">45</td><td align="left">460</td></tr><tr><td align="left">1416</td><td align="left">3</td><td align="left">40</td><td align="left">232</td></tr><tr><td align="left">1534</td><td align="left">3</td><td align="left">30</td><td align="left">315</td></tr><tr><td align="left">852</td><td align="left">2</td><td align="left">36</td><td align="left">178</td></tr><tr><td align="left">…</td><td align="left">…</td><td align="left">…</td><td align="left">…</td></tr></tbody></table><p>上面的图表展示了多个和房屋价格相关的变量。</p><p>下面定义一些变量</p><ul><li><strong>m</strong> = 训练数据集数量</li><li><strong>n</strong> = 特征变量数</li><li><strong>$x^{(i)}$</strong> = 第 i 个训练样本</li><li><strong>$x_j^{(i)}$</strong> = 第 i 个训练样本的 第 j 个特征变量</li></ul><p>上面的表格中<br>$m=4$<br>$n=3$<br>$x^{(2)}=\left[ \begin{matrix} 1416 \\ 3 \\ 40 \\ \cdots \end{matrix} \right]$<br>$x_3^{(2)}=40$</p><p>在多变量条件下，预测函数为<br>$$ h_\theta(x)= \theta_0+\theta_1x_1+\theta_2x_2+\cdots+\theta_nx_n $$</p><p>为了方便，我们自定义一个变量$x_0=1$</p><p>预测函数即为：<br>$$ h_\theta(x)= \theta_0x_0+\theta_1x_1+\theta_2x_2+\cdots+\theta_nx_n $$</p><p>用向量的方式定义 $x$ 和 $\theta$</p><p>$<br>x=\left[ \begin{matrix} x_0 \\ x_1 \\ x_2  \\ \cdots \\ x_n \end{matrix} \right],<br>\theta=\left[ \begin{matrix} \theta_0 \\ \theta_1 \\ \theta_2 \\ \cdots \\ \theta_n \end{matrix} \right]<br>$</p><p>用向量的方式表示预测函数：</p><p>$$ h_\theta(x) = \left[ \begin{matrix} \theta_0 &amp; \theta_1 &amp; \cdots &amp; \theta_n \end{matrix} \right] \left[ \begin{matrix} x_0 \\ x_1 \\ \cdots \\ x_n \end{matrix} \right] = \theta^Tx $$</p><p>用梯度算法来解决这个问题。</p><p>重复直到$J(\theta)$收敛 {<br>$ \theta_j:=\theta_j - \alpha \frac{1}{m} \sum_{i=0}^m((h_\theta(x^{(i)})-y^{(i)})x_j^{(i)}), j \epsilon \left(0, 1, 2,…,n\right) $<br>}</p><p>比如说：<br>$ \theta_0:=\theta_0 - \alpha \frac{1}{m} \sum_{i=0}^m((h_\theta(x^{(i)})-y^{(i)})x_0^{(i)}) $,<br>$ \theta_1:=\theta_1 - \alpha \frac{1}{m} \sum_{i=0}^m((h_\theta(x^{(i)})-y^{(i)})x_1^{(i)}) $,<br>$ \theta_2:=\theta_2 - \alpha \frac{1}{m} \sum_{i=0}^m((h_\theta(x^{(i)})-y^{(i)})x_2^{(i)}) $,<br>$…$</p><p>重复上面的下降知道代价函数收敛。这就是梯度下降的算法过程。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 线性回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>梯度下降算法 (Gradient Descent)</title>
      <link href="/2019/12/30/tech/machine_learning/linear_regression_gradient_descent.html"/>
      <url>/2019/12/30/tech/machine_learning/linear_regression_gradient_descent.html</url>
      
        <content type="html"><![CDATA[<p>已知了代价函数：<br>$$ J(\theta_0, \theta_1) = \frac{1}{2m} \sum_{i=0}^m(h_\theta(x^{(i)})-y^{(i)})^2 $$</p><p>我们需要一个算法来最小化 $J(\theta_0, \theta_1)$，而梯度下降算法可以解决这个问题。</p><p>梯度下降算法不仅可以应用于多种函数的求解，不仅限于线性回归问题。<br>梯度下降算法可以解决更一般的问题，例如 $J(\theta_0,\theta_1,\ldots,\theta_n)$ 求解该代价函数的最小值。</p><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p>回到线性回归上来，还是使用 $J(\theta_0, \theta_1)$ 来说明。</p><ul><li>将$\theta_0, \theta_1$设置一个初始值，可以是任意值，但通常会设置成0；</li><li>不断的改变$\theta_0, \theta_1$的值，让$J(\theta_0, \theta_1)$的值一直减小，直到找到$J$的最小值或局部最小值。</li></ul><p><strong>工作流程</strong></p><p><img src="/images/ml_5.jpg" alt="" title="流程1"></p><p>这是一个随 $\theta_0, \theta_1$ 变化而导致 $J$ 变化的图表。我们希望最小化这个函数，根据流程，先初始化一个$\theta_0, \theta_1$的值。</p><p>把这个图像想像成一座上，初始化的试过就是把你放在山的某处，现在你要下到山的最下面，也就是山谷底。<br>现在把自己旋转360度，寻找一个最快下山的方向，然后迈出一步，接着重复上次的过程继续找一个最快下山的方向迈出一步，重复上面的步骤，迈出一步又一步，直到一个局部最低点的位置。</p><p>下降的轨迹<br><img src="/images/ml_6.gif" alt="" title="动态1"></p><p>当初始位置向右偏移一点，下降的轨迹就不一样了。<br><img src="/images/ml_7.gif" alt="" title="动态2"></p><p>这样我们得到了两个局部最低点，当初始位置不同时会得到不同的局部最优解，这是梯度下降算法的一个特点。</p><p>取得下降方向的方法就是取代价函数的导数（即一个函数的切线），切线的斜率就是那个点的导数。当斜率趋向于0时就说明代价函数的值在下降。而每一步的步长则是由学习率（learning rate）$\alpha$ 来表示。</p><p>例如：上图中每个 “星” 之间的距离就是由参数 $\alpha$ 来确定，当 $\alpha$ 较大时，步长就较大，同样的，$\alpha$较小时，步长就会变小；前进的方向则是由 $J(\theta_0, \theta_1)$ 出的偏导数来决定。根据不同的起点，可能会在不同的终点结束。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>梯度下降算法的定义是：</p><p><em>重复下面的步骤直到$J(\theta_0, \theta_1)$收敛</em><br>$$ \theta_j:=\theta_j−\alpha \frac{\partial}{\partial \theta_j} J(\theta_0, \theta_1), j \epsilon \left(0, 1\right) $$</p><p>$j$ 表示索引，此例中可取0, 1</p><p><strong>注意：</strong><br>当改变参数 $\theta_0, \theta_1, \ldots$ 时，需要注意的一点就是要同时改变这些参数，这对于获得正确的代价函数是非常重要的。</p><p>$\color{green}{下面这个例子是正确的}$：<br>$temp0:=\theta_0−\alpha \frac{\partial}{\partial \theta_0} J(\theta_0, \theta_1)$<br>$temp1:=\theta_1−\alpha \frac{\partial}{\partial \theta_1} J(\theta_0, \theta_1)$<br>$\theta_0:=temp0$<br>$\theta_1:=temp1$<br>这样的一个步骤是正确的。</p><p>$\color{red}{下面这个例子是错误的}$：<br>$temp0:=\theta_0−\alpha \frac{\partial}{\partial \theta_0} J(\theta_0, \theta_1)$<br>$\theta_0:=temp0$<br>$temp1:=\theta_1−\alpha \frac{\partial}{\partial \theta_1} J(\theta_0, \theta_1)$<br>$\theta_1:=temp1$</p><p>用一个例子来说明梯度下降算法：</p><p>有一个单变量线性回归的预测函数，同时将$\theta_0=0$,这样预测函数就是：$h_\theta(x) = \theta_1x$<br>这样梯度下降算法就是重复计算:<br>$$ \theta_1:=\theta_1−\alpha \frac{\partial}{\partial \theta_1} J(\theta_1) $$</p><p><img src="/images/ml_8.jpg" alt=""></p><p>红线就代表的代价函数的导数，即在这一点的斜率，上图的点上我们可以知道 $\frac{\partial}{\partial \theta_1} J(\theta_1) \geq 0$，<br>代入式子中，我们可以得到$\theta_1$在变小，向左靠拢。</p><p><img src="/images/ml_9.jpg" alt=""></p><p>当初始 $\theta_1$ 在左边，它的斜率是负数，我们可以得到$\theta_1$在变大，向右靠拢。</p><p>当接近J函数的最底部时，$\frac{\partial}{\partial \theta_1} J(\theta_1)$ 接近0。当到最理想的情况下，$\frac{\partial}{\partial \theta_1} J(\theta_1) = 0$，在这张情况下我们可以得到：$\theta_1:=\theta_1−\alpha*0$。即$\theta_1$ 不会再变化。</p><p>由上图可知，当学习率$\alpha$ 过小时，我们需要经过很多步才能到达最低点，耗时会更长。而当$\alpha$ 过大时，可能会越过最低点，导致无法收敛</p><p><img src="/images/ml_10.jpg" alt=""></p><p>总结一下：当越接近局部最小值的地方时，偏导数 $\frac{\partial}{\partial \theta_1} J(\theta_1)$ 就越小，在$\alpha$不变的情况下，$\theta_1$ 下降的步子也就越来越小，当达到局部最优时，$\theta_1$就不变了，因此，我们不需要减小$\alpha$的值。</p><h2 id="应用到线性回归问题上"><a href="#应用到线性回归问题上" class="headerlink" title="应用到线性回归问题上"></a>应用到线性回归问题上</h2><p>已知线性回归的预测函数：<br>$$ h_\theta(x) = \theta_0 + \theta_1x $$</p><p>将预测函数代入到代价函数中并应用数学求导，可得到：</p><p>当j=0时:<br>$$\theta_0:=\theta_0 - \alpha \frac{1}{m} \sum_{i=0}^m(h_\theta(x_i)-y_i)$$<br>当j=1时：<br>$$\theta_1:=\theta_1 - \alpha \frac{1}{m} \sum_{i=0}^m((h_\theta(x_i)-y_i)x_i)$$</p><p>在线性回归问题中，我们从一个假设的$\theta_0, \theta_1$开始，重复应用这些梯度下降方程，之后我们的预测函数就会越来越精确。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 监督学习 </tag>
            
            <tag> 线性回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性回归代价函数 (Cost Function)</title>
      <link href="/2019/12/29/tech/machine_learning/linear_regression_cost_function.html"/>
      <url>/2019/12/29/tech/machine_learning/linear_regression_cost_function.html</url>
      
        <content type="html"><![CDATA[<p>回到房价的例子：</p><p>单变量线性回归的预测函数：<br>$$ h_\theta(x) = \theta_0 + \theta_1x $$</p><p>要得出这个函数就要知道$\theta_0$ 和 $\theta_1$这两个值。</p><p>而想要让预测 $h_\theta(x)$ 更加准确，就需要 $h_\theta(x)$ 和 真实值 $y$ 之间的差距越小，所以我们需要做的就是得到一个 $\theta_0$ 和 $\theta_1$ 让预测函数的到的值与 $y$ 之间的差异最小，这样就得到了一个满意的预测函数了。</p><p>我们可以用平方差公式来表示两组数之间的差异度，方程为：</p><p>$$ J(\theta_0, \theta_1) = \frac{1}{2m} \sum_{i=0}^m(h_\theta(x^{(i)})-y^{(i)})^2 $$</p><blockquote><p>PS: 此处平方差公式原本应当是除以 m,这里除以 2m 只为了以后在数学上计算方便，这里除以 m 和 除以 2m 对获得最小的代价函数值没有影响。</p></blockquote><p>$J(\theta_0, \theta_1)$被成为代价函数（cost function），这是回归问题中最常使用的方法.</p><p>现在要做的就是得到使 $J(\theta_0, \theta_1)$ 最小的 $\theta_0$ 和 $\theta_1$</p><h2 id="最小化-J-theta-0-theta-1"><a href="#最小化-J-theta-0-theta-1" class="headerlink" title="最小化$J(\theta_0, \theta_1)$"></a>最小化$J(\theta_0, \theta_1)$</h2><p>为了更好的理解最小化的过程，先假设 $\theta_0$ = 0，这样就简化了预测函数$h_\theta(x) = \theta_1x$</p><p>将 $h_\theta(x)$ 带入 代价函数， 我们可以得到：<br>$$ J(\theta_1) = \frac{1}{2m} \sum_{i=0}^m(\theta_1x^{(i)}-y^{(i)})^2 $$</p><p>假设我们只有一组数据样本$(x^{(1)}, y^{(1)}) = (1, 2)$，继续简化代价函数：<br>$$ J(\theta_1) = \frac{1}{2} (\theta_1-2)^2 $$</p><p><img src="/images/ml_3.jpg" alt="J随$\theta_1$变化" title="模拟数据"></p><p>当使用不同的$\theta_1$ 带入公式时，我们可以的到这样的一个曲线图。从图中可以清楚的看到，当$\theta_1=2$时 $J$ 的返回值最小。</p><p>当$\theta_0$ 不为0时，我们就要根据$\theta_0$ 和 $\theta_1$两个变量来确定 $J$，这在图表上是一个三维的表现</p><p><img src="/images/ml_4.jpg" alt="J随$\theta_0$, $\theta_1$变化" title="三维"></p><p>除了通过图表直观的看出最小值，从数学上获得一个函数的最小值可以使用的方法就是求这个函数的导数，当导数为0时，就得到的函数的最小值。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 监督学习 </tag>
            
            <tag> 线性回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性回归算法介绍</title>
      <link href="/2019/12/29/tech/machine_learning/linear_regression_intro.html"/>
      <url>/2019/12/29/tech/machine_learning/linear_regression_intro.html</url>
      
        <content type="html"><![CDATA[<p>例子：<br>这是一个预测房价的，有一个数据集，包含了某处的房子的大小和价格。</p><table><thead><tr><th align="center">尺寸(x)</th><th align="center">价格(y)</th></tr></thead><tbody><tr><td align="center">2104</td><td align="center">460</td></tr><tr><td align="center">1416</td><td align="center">232</td></tr><tr><td align="center">1534</td><td align="center">315</td></tr><tr><td align="center">852</td><td align="center">178</td></tr><tr><td align="center">…</td><td align="center">…</td></tr></tbody></table><p>现在需要做的就是从这个数据中学习预测房屋价格。</p><p>这里说明一下变量定义：</p><ul><li><strong>m</strong> = 训练数据集数量</li><li><strong>x</strong> = 输入变量，也成特征值（feature）</li><li><strong>y</strong> = 输出变量，即目标值</li><li><strong>h</strong> = 通过学习算法的到的输出函数（hypothesis function）</li></ul><p>我们一般使用(x, y)来表示一个训练样本， 例如上面的(2104, 460)…<br>用  ($x^{(i)}$, $y^{(i)}$) 来表示第 i 个训练样本，上标 i 即为数据集的索引，从 1 开始</p><p><img src="/images/ml_1.png" alt="监督学习过程（这里用了吴恩达课程的图片）" title="监督学习"></p><p>这张图上，我们通过机器学习算法和数据集来获得一个预测函数<strong>h</strong>，然后当有新的输入值时，通过这个函数获得新的预测值。<br>在上面的例子中，新的输入值就是提供一个新的房子尺寸，然后需要得到该房子的预测价格。</p><h3 id="如何定义预测函数-h"><a href="#如何定义预测函数-h" class="headerlink" title="如何定义预测函数 h"></a>如何定义预测函数 h</h3><p>我们先用一个简单的线性函数来表示：<br>$h_\theta(x) = \theta_0 + \theta_1x$（有时简单起见，$h_\theta(x)$会缩写成$h(x)$）<br>这意味着这个预测函数是一个线性函数，至于为什么不选择一个复杂的非线性的函数，这是我们都是从简到难，一步步由简单的线性函数到复杂的模型。</p><p><img src="/images/ml_2.jpg" alt="线性回归图表（这里用了吴恩达课程的图片）" title="线性回归"></p><p>这个简单的模型就是<strong>线性回归模型（ linear regression）</strong>，而且这是一个单个变量的线性回归模型，单变量即为$x$，这个是根据$x$来预测房价的函数，因此这个模型还有另外一个名称 <strong>单变量线性回归</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 监督学习 </tag>
            
            <tag> 线性回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>监督学习与非监督学习</title>
      <link href="/2019/12/29/tech/machine_learning/supervised_learning.html"/>
      <url>/2019/12/29/tech/machine_learning/supervised_learning.html</url>
      
        <content type="html"><![CDATA[<p>这是我学习吴恩达机器学习课程的一点心得和笔记，梳理一下知识，同时与大家交流一下。</p><h2 id="监督学习（Supervised-Learning）"><a href="#监督学习（Supervised-Learning）" class="headerlink" title="监督学习（Supervised Learning）"></a>监督学习（Supervised Learning）</h2><p><strong>在监督学习中，通过给定的数据集来得出一个最优的预测算法，在这个数据集中，我们已经知道了正确的输出。</strong><br>例如：我们给出一组关于房价的数据集，数据集中包含房子的一些特征以及这些房子的价格，房子的价格即是正确的输出。</p><p>监督学习可以分为<strong>回归</strong>和<strong>分类</strong></p><p>回归问题，是在连续的输出上预测结果，通常是用一个连续函数（例如一次函数或多次函数）来拟合数据，它可能的输出值无限的。<br>例子：</p><ul><li>根据房子面积和位置预测房价；</li></ul><p>而分类问题，通常是通过离散的输出，来拟合数据，它和回归的区别是，分类预测的结果是有限的，可能就两个，三个可能的结果。<br>例子：</p><ul><li>预测房子卖不卖的出去；</li><li>预测一个肿瘤患者，他的肿瘤是恶性还是良性的；</li><li>判断垃圾邮件</li></ul><h2 id="非监督学习（Unsupervised-Learning）"><a href="#非监督学习（Unsupervised-Learning）" class="headerlink" title="非监督学习（Unsupervised Learning）"></a>非监督学习（Unsupervised Learning）</h2><p><strong>无监督学习是在不知道结果是什么的情况下处理问题，可以根据数据中变量的关系对数据进行聚类，从而得出一个算法</strong><br>即让机器自己学会做事情，区分数据。</p><p>无监督学习有两类算法：<strong>聚类（Clustering）</strong> 和 <strong>非聚类（Non-clustering）</strong></p><p>聚类：</p><ul><li>收集大量基因数据，找到一种方法将基因分组，这些分组与数据中的不同变量有关，类似，寿命，性别等；</li><li>自动将大量新闻分类，分成，体育，娱乐等分类</li></ul><p>非聚类：</p><ul><li><strong>鸡尾酒会算法</strong>，在混乱的环境中找出结构（即在一个鸡尾酒会上从一个混合的声音中识别出人声和音乐）。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue在非项目根目录上部署的问题和解决方案</title>
      <link href="/2018/09/18/tech/front/vue-relative-path-build.html"/>
      <url>/2018/09/18/tech/front/vue-relative-path-build.html</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p><code>vue-router</code> 有两种模式，默认是hash模式，通过URL的hash来模拟URL。</p><p>hash模式生成的URL有点丑，还有另一种history模式，它是利用<code>history.pushState</code>API来模拟URL。</p><p>这两种模式在开发环境下都没有什么太大的问题，但是当部署到生产环境中后，两者有所不同。</p><p>hash模式部署没有什么问题，只要访问到服务器上的<code>index.html</code>，就可以访问网站了。<br>重点是history模式。</p><h2 id="根目录下"><a href="#根目录下" class="headerlink" title="根目录下"></a>根目录下</h2><p>当项目部署在根目录下时，vue的配置文件默认不需要修改，我们要修改的是服务器的配置，这里我们使用nginx。<br>官方提供了解决方案<a href="https://router.vuejs.org/zh/guide/essentials/history-mode.html" target="_blank" rel="noopener">router.vuejs.org/zh…</a></p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">location</span> / &#123;</span><br><span class="line">  <span class="attribute">try_files</span> <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>稍微解释一下</p><p><code>$uri</code>就是访问的url，不包含域名和querystring，例如<code>/test/hello</code><br>当访问<code>$uri</code>时，如果存在，则访问<code>$uri/</code>, 不存在就访问<code>/index.html</code><br>这样配置好，访问<code>http://example.com/</code>时就可以访问到网站了，进入多级目录后刷新页面也不会存在问题。</p><h2 id="非根目录下"><a href="#非根目录下" class="headerlink" title="非根目录下"></a>非根目录下</h2><p>当然，有时候我们并不想单独申请一个域名或者设置一个子域名来部署网站，这时，就需要修改一下vue的配置文件了</p><h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>这里我们定义几个环境<br>我们的域名：<code>http://example.com/</code></p><p>nignx的root目录：<code>/usr/local/nginx/html/</code> </p><p>vue网站目录：<code>/usr/local/nginx/html/h5/main/</code></p><p>vue网站访问地址：<code>http://example.com/h5/main/</code></p><p>vue网站主页访问地址：<code>http://example.com/h5/main/index.html</code></p><p>vue网站静态文件目录：<code>http://example.com/h5/main/static/</code></p><p><strong>1. 打包后静态资源的路径需要修改</strong></p><p>修改<code>config/index.js</code>文件的build节点下的<code>assetsPublicPath</code></p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">build</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attribute">assetsSubDirectory</span>: <span class="string">'static'</span>,</span><br><span class="line">    <span class="attribute">assetsPublicPath</span>: <span class="string">'./'</span>  <span class="comment">// 未修改前的配置为 '/'，</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很多人直接修改成<code>./</code>这样的相对路径是有问题的。</p><p>这种当我们访问<code>http://example.com/h5/main/test</code>这样的目录时，<code>./static/</code>就是表示<code>static</code>目录在这一级<code>http://example.com/h5/main/static</code>，这样没有问题。</p><p>当我们访问多级目录时，例如<code>http://example.com/h5/main/test/test</code>，<code>./static/</code>就是表示<code>static</code>目录在这一级<code>http://example.com/h5/main/test/static</code>，这路径明显是不正确，访问不到。</p><p>这里我们需要改成绝对路径。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">build</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attribute">assetsSubDirectory</span>: <span class="string">'static'</span>,</span><br><span class="line">    <span class="attribute">assetsPublicPath</span>: <span class="string">'/h5/main/'</span>  <span class="comment">// 未修改前的配置为 '/'，</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样静态文件目录就始终在<code>http://example.com/h5/main/static/</code>这个路径了。</p><p><strong>2. 路由文件需要修改</strong></p><p>在路由的history模式下，所有的路由都是基于根路径的，如/xxxx，现在我们时部署到<code>/h5/main/</code>下，我们就要基于这个来修改路由。</p><p><code>vue-router</code>有一个<code>base</code>属性 <a href="https://router.vuejs.org/zh/api/#base" target="_blank" rel="noopener">https://router.vuejs.org/zh/…</a></p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">base</span></span><br><span class="line"><span class="keyword">类型: </span><span class="keyword">string</span></span><br><span class="line"><span class="keyword">默认值: </span><span class="string">"/"</span></span><br><span class="line">应用的基路径。例如，如果整个单页应用服务在 /app/ 下，然后 <span class="keyword">base </span>就应该设为 <span class="string">"/app/"</span></span><br></pre></td></tr></table></figure><p>修改路由代码</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  <span class="keyword">base</span>: <span class="string">'/h5/main/'</span>, <span class="comment">// 这是新加的配置</span></span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样打包部署时就可以了，但是开发环境下这个就不对了，所以我们还要根据环境修改一下文件。</p><p><code>config/prod.env.js</code>生产环境变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</span><br><span class="line">  NODE_ENV: <span class="string">'"production"'</span>,</span><br><span class="line">  ROUTER_BASE: <span class="string">'"/h5/main/"'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>config/dev.env.js</code>生产环境变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span>.<span class="keyword">exports</span> = &#123;</span><br><span class="line">  NODE_ENV: <span class="string">'"production"'</span>,</span><br><span class="line">  ROUTER_BASE: <span class="string">'"/"'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由代码</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> Router(&#123;</span><br><span class="line">  mode: <span class="string">'history'</span>,</span><br><span class="line">  <span class="keyword">base</span>: process.env.ROUTER_BASE, <span class="comment">// 这是新加的配置</span></span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>至此，打包配置的相关修改已全部完成，项目也能够正常访问。</p><p>但还是会有一个问题，跳转到某个路由后，刷新页面，就gg了，页面为空白，此时就要修改nginx的配置了。</p><h3 id="nginx配置修改"><a href="#nginx配置修改" class="headerlink" title="nginx配置修改"></a>nginx配置修改</h3><p>官方给的nginx配置是根目录下的，需要修改一下</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~ <span class="regexp">/h5/m</span>ain &#123;</span><br><span class="line">    try_files <span class="variable">$uri</span> <span class="variable">$uri</span><span class="regexp">/ /</span>h5<span class="regexp">/main/i</span>ndex.html;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>/h5/main/</code>就是部署的网站目录。</p><p>这样几项配置后，就可以在子目录下访问网站，刷新也没有问题。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2017南京马拉松</title>
      <link href="/2017/10/17/life/2017-nanjing-marathon.html"/>
      <url>/2017/10/17/life/2017-nanjing-marathon.html</url>
      
        <content type="html"><![CDATA[<p><img src="/images/nj/begin.jpg" height="300"></p><p>今年终于中签马拉松，而且是南京马拉松，包邮当然要凑下热闹了，这是我的第三个马拉松。</p><p>赛前得知比赛当日有雨，已经做好了雨战的准备。第二天一看，天气预报终于准了，早上蒙蒙细雨，气温稍低，感觉还是不错的。</p><p>听说今年赛道改了，减少了一些比较虐的地段，但对于我来说还是有点难度啊。</p><p>前半段状态不错，在18公里左右有一个大坡，有长又陡，虐的不轻。半程过后，脚底开始有些隐隐作痛，速度有所减缓，一路磕胶，坚持到33公里处，撞墙了，赛前没有长距离拉练的劣势显示出来了，下面就是走走跑跑，用尽了洪荒之力。</p><p>后半程撞墙后也就想开了，一路走走吃吃，面包，橘子，小番茄，葡萄干…一路吃。还有热心观众给了一块盐水鸭，和一杯红牛，大口吃完，顿时生出了一股力量，慢慢的颠完了剩下的路程。</p><p>总结一下，还是要少比赛，多锻炼。打铁还得自身硬啊！</p><p><img src="/images/nj/9.jpeg" height="300"></p><p>比赛路线和成绩，有些惨淡但还是满意的，毕竟跑完就是胜利者（安慰自己）。</p><p><img src="/images/nj/1.jpeg" height="300"></p>> 热情的观众<p><img src="/images/nj/2.jpeg" height="300"></p>> 鸡鸣寺<p><img src="/images/nj/3.jpeg" height="300"></p>> 中华门<p>由于手机电量堪忧，就拍了这些。</p><p><img src="/images/nj/4.jpeg" height="300"></p><p>赛后的拉伸区设置的很好，有很多拉伸位置，给组委会，慧跑，以及为跑友服务的工作人员点赞！</p><p>  <img src="/images/nj/8.jpeg" height="300">  <img src="/images/nj/7.jpeg" height="300"></p><p>赛后狠狠的犒劳了一下自己。</p><p><img src="/images/nj/6.jpeg" height="300"></p><p>奖牌是南京的市花（梅花），样式还是不错了，就是听说质量不太好…</p><p><img src="/images/nj/5.jpeg" height="300"></p><p>最后挑了一张还能看的过去的皂片（其他不是闭眼就是被挡住了），见笑见笑！</p><!-- ![南京马拉松][img:begin] -->]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 马拉松 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas的行数据转换为列表</title>
      <link href="/2017/09/22/tech/python/convert-row-in-pandas-into-list.html"/>
      <url>/2017/09/22/tech/python/convert-row-in-pandas-into-list.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; data = &#123;<span class="string">'state'</span>: [<span class="string">'US'</span>,<span class="string">'Ohio'</span>,<span class="string">'Nevada'</span>], <span class="string">'pop'</span><span class="symbol">:</span>[<span class="number">2.5</span>, <span class="number">4.3</span>, <span class="number">3.2</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; df = pd.DataFrame(data)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; df</span><br><span class="line">   pop   state</span><br><span class="line"><span class="number">0</span>  <span class="number">2.5</span>      US</span><br><span class="line"><span class="number">1</span>  <span class="number">4.3</span>    Ohio</span><br><span class="line"><span class="number">2</span>  <span class="number">3.2</span>  Nevada</span><br></pre></td></tr></table></figure><p>现在需要转换成</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">2.5</span>, 'US'], [<span class="number">4.3</span>, 'Ohio'], [<span class="number">3.2</span>, 'Nevada']]</span><br></pre></td></tr></table></figure><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>可以使用 <a href="http://pandas.pydata.org/pandas-docs/dev/generated/pandas.DataFrame.iterrows.html" target="_blank" rel="noopener">iterrows</a> 实现:</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; temp=[]</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; for row in df.iterrows()<span class="symbol">:</span></span><br><span class="line">...     index, data = row</span><br><span class="line">...     temp.append(data.tolist())</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; temp</span><br><span class="line">[[<span class="number">2.5</span>, <span class="string">'US'</span>], [<span class="number">4.3</span>, <span class="string">'Ohio'</span>], [<span class="number">3.2</span>, <span class="string">'Nevada'</span>]]</span><br></pre></td></tr></table></figure><p>当然这是一种办法，还有一种更 python 的办法，pandas中提供方法转换:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">df</span><span class="selector-class">.values</span><span class="selector-class">.tolist</span>()</span><br><span class="line"><span class="selector-attr">[[2.5, <span class="string">'US'</span>]</span>, <span class="selector-attr">[4.3, <span class="string">'Ohio'</span>]</span>, <span class="selector-attr">[3.2, <span class="string">'Nevada'</span>]</span>]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas的索引转换为列数据</title>
      <link href="/2017/09/22/tech/python/convert-pandas-index-in-dataframe-to-column.html"/>
      <url>/2017/09/22/tech/python/convert-pandas-index-in-dataframe-to-column.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; df = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">4</span>,<span class="number">3</span>)), index=[[<span class="string">'a'</span>,<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'b'</span>], [<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">2</span>]], columns=[<span class="string">'green'</span>,<span class="string">'blue'</span>,<span class="string">'red'</span>])</span><br><span class="line">&gt;&gt;&gt; df.index.names=[<span class="string">'key1'</span>,<span class="string">'key2'</span>]</span><br><span class="line">&gt;&gt;&gt; df</span><br><span class="line">           green  blue  red</span><br><span class="line">key1 key2</span><br><span class="line">a    <span class="number">1</span>         <span class="number">0</span>     <span class="number">1</span>    <span class="number">2</span></span><br><span class="line">     <span class="number">2</span>         <span class="number">3</span>     <span class="number">4</span>    <span class="number">5</span></span><br><span class="line">b    <span class="number">1</span>         <span class="number">6</span>     <span class="number">7</span>    <span class="number">8</span></span><br><span class="line">     <span class="number">2</span>         <span class="number">9</span>    <span class="number">10</span>   <span class="number">11</span></span><br></pre></td></tr></table></figure><p>转换成</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  key1  key2  green  blue  red</span><br><span class="line"><span class="number">0</span>    a     <span class="number">1</span>      <span class="number">0</span>     <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">1</span>    a     <span class="number">2</span>      <span class="number">3</span>     <span class="number">4</span>    <span class="number">5</span></span><br><span class="line"><span class="number">2</span>    b     <span class="number">1</span>      <span class="number">6</span>     <span class="number">7</span>    <span class="number">8</span></span><br><span class="line"><span class="number">3</span>    b     <span class="number">2</span>      <span class="number">9</span>    <span class="number">10</span>   <span class="number">11</span></span><br></pre></td></tr></table></figure><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>可以看到这是带有MultiIndex索引的DataFrame对象</p><p>首先，可以先来尝试一下普通的DataFrame:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; normal_df = pd.DataFrame(np.arange(<span class="number">12</span>).reshape((<span class="number">4</span>,<span class="number">3</span>)), columns=[<span class="string">'green'</span>,<span class="string">'blue'</span>,<span class="string">'red'</span>])</span><br><span class="line">&gt;&gt;&gt; normal_df</span><br><span class="line">   green  blue  red</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>     <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">1</span>      <span class="number">3</span>     <span class="number">4</span>    <span class="number">5</span></span><br><span class="line"><span class="number">2</span>      <span class="number">6</span>     <span class="number">7</span>    <span class="number">8</span></span><br><span class="line"><span class="number">3</span>      <span class="number">9</span>    <span class="number">10</span>   <span class="number">11</span></span><br></pre></td></tr></table></figure><p>最简单的：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; normal_df[<span class="string">'index1'</span>] = normal_df.index</span><br><span class="line">&gt;&gt;&gt; normal_df</span><br><span class="line">   green  blue  red  index1</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>     <span class="number">1</span>    <span class="number">2</span>       <span class="number">0</span></span><br><span class="line"><span class="number">1</span>      <span class="number">3</span>     <span class="number">4</span>    <span class="number">5</span>       <span class="number">1</span></span><br><span class="line"><span class="number">2</span>      <span class="number">6</span>     <span class="number">7</span>    <span class="number">8</span>       <span class="number">2</span></span><br><span class="line"><span class="number">3</span>      <span class="number">9</span>    <span class="number">10</span>   <span class="number">11</span>       <span class="number">3</span></span><br></pre></td></tr></table></figure><p>或者使用 <a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.DataFrame.reset_index.html" target="_blank" rel="noopener">pandas.DataFrame.reset_index</a></p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; normal_df.reset_index()</span><br><span class="line">   index  green  blue  red</span><br><span class="line"><span class="number">0</span>      <span class="number">0</span>      <span class="number">0</span>     <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">1</span>      <span class="number">1</span>      <span class="number">3</span>     <span class="number">4</span>    <span class="number">5</span></span><br><span class="line"><span class="number">2</span>      <span class="number">2</span>      <span class="number">6</span>     <span class="number">7</span>    <span class="number">8</span></span><br><span class="line"><span class="number">3</span>      <span class="number">3</span>      <span class="number">9</span>    <span class="number">10</span>   <span class="number">11</span></span><br></pre></td></tr></table></figure><p>现在来看最上面的DataFrame，需要使用 reset_index 方法</p><p>可以看下reset的level参数：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">level : int, str, tuple, <span class="keyword">or</span> list,<span class="built_in"> default </span>None</span><br><span class="line">Only <span class="builtin-name">remove</span> the given levels <span class="keyword">from</span> the index. Removes all levels by default</span><br></pre></td></tr></table></figure><p>该对象包含两个索引[key1, key1]，要移除索引放到列上时，就需要指定索引： 0(key1), 1(key2)</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; df.reset_index(level=<span class="number">0</span>)</span><br><span class="line">     key1  green  blue  red</span><br><span class="line">key2</span><br><span class="line"><span class="number">1</span>       a      <span class="number">0</span>     <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">2</span>       a      <span class="number">3</span>     <span class="number">4</span>    <span class="number">5</span></span><br><span class="line"><span class="number">1</span>       b      <span class="number">6</span>     <span class="number">7</span>    <span class="number">8</span></span><br><span class="line"><span class="number">2</span>       b      <span class="number">9</span>    <span class="number">10</span>   <span class="number">11</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; df.reset_index(level=<span class="number">1</span>)</span><br><span class="line">      key2  green  blue  red</span><br><span class="line">key1</span><br><span class="line">a        <span class="number">1</span>      <span class="number">0</span>     <span class="number">1</span>    <span class="number">2</span></span><br><span class="line">a        <span class="number">2</span>      <span class="number">3</span>     <span class="number">4</span>    <span class="number">5</span></span><br><span class="line">b        <span class="number">1</span>      <span class="number">6</span>     <span class="number">7</span>    <span class="number">8</span></span><br><span class="line">b        <span class="number">2</span>      <span class="number">9</span>    <span class="number">10</span>   <span class="number">11</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; df.reset_index(level=<span class="string">'key1'</span>)</span><br><span class="line">     key1  green  blue  red</span><br><span class="line">key2</span><br><span class="line"><span class="number">1</span>       a      <span class="number">0</span>     <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">2</span>       a      <span class="number">3</span>     <span class="number">4</span>    <span class="number">5</span></span><br><span class="line"><span class="number">1</span>       b      <span class="number">6</span>     <span class="number">7</span>    <span class="number">8</span></span><br><span class="line"><span class="number">2</span>       b      <span class="number">9</span>    <span class="number">10</span>   <span class="number">11</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; df.reset_index(level=[<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line">  key1  key2  green  blue  red</span><br><span class="line"><span class="number">0</span>    a     <span class="number">1</span>      <span class="number">0</span>     <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">1</span>    a     <span class="number">2</span>      <span class="number">3</span>     <span class="number">4</span>    <span class="number">5</span></span><br><span class="line"><span class="number">2</span>    b     <span class="number">1</span>      <span class="number">6</span>     <span class="number">7</span>    <span class="number">8</span></span><br><span class="line"><span class="number">3</span>    b     <span class="number">2</span>      <span class="number">9</span>    <span class="number">10</span>   <span class="number">11</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; df.reset_index(level=[<span class="string">'key1'</span>,<span class="string">'key2'</span>])</span><br><span class="line">  key1  key2  green  blue  red</span><br><span class="line"><span class="number">0</span>    a     <span class="number">1</span>      <span class="number">0</span>     <span class="number">1</span>    <span class="number">2</span></span><br><span class="line"><span class="number">1</span>    a     <span class="number">2</span>      <span class="number">3</span>     <span class="number">4</span>    <span class="number">5</span></span><br><span class="line"><span class="number">2</span>    b     <span class="number">1</span>      <span class="number">6</span>     <span class="number">7</span>    <span class="number">8</span></span><br><span class="line"><span class="number">3</span>    b     <span class="number">2</span>      <span class="number">9</span>    <span class="number">10</span>   <span class="number">11</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas逻辑运算: The truth value of a Series is ambiguous</title>
      <link href="/2017/09/22/tech/python/pandas-bool-compare.html"/>
      <url>/2017/09/22/tech/python/pandas-bool-compare.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; data = &#123;<span class="string">'state'</span>: [<span class="string">'US'</span>,<span class="string">'Ohio'</span>,<span class="string">'Nevada'</span>], <span class="string">'pop'</span><span class="symbol">:</span>[<span class="number">2.5</span>, <span class="number">4.3</span>, <span class="number">3.2</span>]&#125;</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; df = pd.DataFrame(data)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; df</span><br><span class="line">   pop   state</span><br><span class="line"><span class="number">0</span>  <span class="number">2.5</span>      US</span><br><span class="line"><span class="number">1</span>  <span class="number">4.3</span>    Ohio</span><br><span class="line"><span class="number">2</span>  <span class="number">3.2</span>  Nevada</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; df[(df[<span class="string">'pop'</span>]&gt;<span class="number">3</span>) and (df[<span class="string">'pop'</span>]&lt;<span class="number">4</span>)]</span><br><span class="line"><span class="symbol">ValueError:</span> The truth value of a Series is ambiguous. Use a.empty, a.bool(), a.item(), a.any() <span class="keyword">or</span> a.all().</span><br></pre></td></tr></table></figure><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>原因是由于在python中 <code>or</code> 和 <code>and</code> 的声明需要 <code>truth-values</code>, 即真实的True或者False</p><p>但是<code>df[&#39;pop&#39;]&gt;3</code>返回并不是True或False，而仍然是一个Series，所以在pandas中这样使用被认为是不明确(ambiguous)</p><p>因此需要使用位运算符(bitwise)即 <code>|</code>(or) 或者 <code>&amp;</code>(and):</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">df</span><span class="selector-attr">[(df[<span class="string">'pop'</span>]</span>&gt;3) &amp; (<span class="selector-tag">df</span><span class="selector-attr">[<span class="string">'pop'</span>]</span>&lt;4)]</span><br><span class="line">   <span class="selector-tag">pop</span>   <span class="selector-tag">state</span></span><br><span class="line">2  3<span class="selector-class">.2</span>  <span class="selector-tag">Nevada</span></span><br></pre></td></tr></table></figure><hr><h2 id="附加说明"><a href="#附加说明" class="headerlink" title="附加说明"></a>附加说明</h2><p>如果想实现 and 或者 or 的效果，可以使用 <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.logical_or.html" target="_blank" rel="noopener">logical_or</a> 和 <a href="https://docs.scipy.org/doc/numpy/reference/generated/numpy.logical_and.html" target="_blank" rel="noopener">logical_and</a> 或者 位运算符(bitwise)即  <code>|</code> (or) 和 <code>&amp;</code> (and)</p><ul><li>logical_or:</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import numpy as np</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; np.logical_or(x, y)</span><br></pre></td></tr></table></figure><p>或者 <code>|</code> 运算符</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="symbol">x</span> | <span class="symbol">y</span></span><br></pre></td></tr></table></figure><ul><li>logical_and:</li></ul><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import numpy as np</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; np.logical_and(x, y)</span><br></pre></td></tr></table></figure><p>或者 <code>&amp;</code> 运算符</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; x &amp; y</span><br></pre></td></tr></table></figure><p>当使用位运算符时，因为运算符优先级的问题，请将两边用括号包起来。<a href="https://docs.python.org/3/reference/expressions.html#operator-precedence" target="_blank" rel="noopener">查看详情</a></p><p>除此之外还有 一些其他逻辑操作 <code>logical_not</code> 和 <code>logical_xor</code>… <a href="https://docs.scipy.org/doc/numpy/reference/routines.logic.html" target="_blank" rel="noopener">查看详情</a></p><hr><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>当使用<code>bool</code>来操作<code>pandas.Series</code>时会返回一个异常：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x = pd.Series([<span class="number">1</span>])</span><br><span class="line">&gt;&gt;&gt; bool(x)</span><br><span class="line">ValueError: The truth <span class="built_in">value</span> <span class="keyword">of</span> <span class="keyword">a</span> Series is ambiguous. Use <span class="keyword">a</span>.<span class="literal">empty</span>, <span class="keyword">a</span>.bool(), <span class="keyword">a</span>.<span class="keyword">item</span>(), <span class="keyword">a</span>.<span class="keyword">any</span>() <span class="keyword">or</span> <span class="keyword">a</span>.all().</span><br></pre></td></tr></table></figure><p>下列操作也会抛出异常：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x <span class="keyword">or</span> x</span><br><span class="line">ValueError: The truth <span class="built_in">value</span> <span class="keyword">of</span> <span class="keyword">a</span> Series is ambiguous. Use <span class="keyword">a</span>.<span class="literal">empty</span>, <span class="keyword">a</span>.bool(), <span class="keyword">a</span>.<span class="keyword">item</span>(), <span class="keyword">a</span>.<span class="keyword">any</span>() <span class="keyword">or</span> <span class="keyword">a</span>.all().</span><br><span class="line">&gt;&gt;&gt; x <span class="keyword">and</span> x</span><br><span class="line">ValueError: The truth <span class="built_in">value</span> <span class="keyword">of</span> <span class="keyword">a</span> Series is ambiguous. Use <span class="keyword">a</span>.<span class="literal">empty</span>, <span class="keyword">a</span>.bool(), <span class="keyword">a</span>.<span class="keyword">item</span>(), <span class="keyword">a</span>.<span class="keyword">any</span>() <span class="keyword">or</span> <span class="keyword">a</span>.all().</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">if</span> x:</span><br><span class="line">...     print(<span class="string">'fun'</span>)</span><br><span class="line">ValueError: The truth <span class="built_in">value</span> <span class="keyword">of</span> <span class="keyword">a</span> Series is ambiguous. Use <span class="keyword">a</span>.<span class="literal">empty</span>, <span class="keyword">a</span>.bool(), <span class="keyword">a</span>.<span class="keyword">item</span>(), <span class="keyword">a</span>.<span class="keyword">any</span>() <span class="keyword">or</span> <span class="keyword">a</span>.all().</span><br><span class="line">&gt;&gt;&gt; <span class="keyword">while</span> x:</span><br><span class="line">...     print(<span class="string">'fun'</span>)</span><br><span class="line">ValueError: The truth <span class="built_in">value</span> <span class="keyword">of</span> <span class="keyword">a</span> Series is ambiguous. Use <span class="keyword">a</span>.<span class="literal">empty</span>, <span class="keyword">a</span>.bool(), <span class="keyword">a</span>.<span class="keyword">item</span>(), <span class="keyword">a</span>.<span class="keyword">any</span>() <span class="keyword">or</span> <span class="keyword">a</span>.all().</span><br></pre></td></tr></table></figure><p>这些隐式调用其实也是将之转为bool类型，因此仍会错误，除了上述4个声明外，还有一些操作会产生同样的效果(类似any, all, filter, …)</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django datetime: can&#39;t compare offset-naive and offset-aware datetimes</title>
      <link href="/2017/09/22/tech/python/django-compare-naive-aware-datetimes.html"/>
      <url>/2017/09/22/tech/python/django-compare-naive-aware-datetimes.html</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import datetime</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; from django.utils import timezone</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; naive = datetime.datetime.utcnow()</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; aware = timezone.now()</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; naive == aware</span><br><span class="line">Traceback (most recent call last)<span class="symbol">:</span></span><br><span class="line">...</span><br><span class="line"><span class="symbol">TypeError:</span> can<span class="string">'t compare offset-naive and offset-aware datetimes</span></span><br></pre></td></tr></table></figure><h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>当遇到这种问题，首先要了解一下 <code>offset-naive</code> 和 <code>offset-aware</code> 是如何生成的</p><ul><li>由Django生成的datetime，例如，从model的字段中读取的值，当Django开启时区支持<em>USE_TZ = True</em>，该值就是<code>aware</code></li><li>由Python原生生成的datetime，就是<code>naive</code></li></ul><p>因此，问题的解决就是改变一下datetime即可，aware=&gt;naive 或者 naive=&gt;aware</p><p>创建一个aware datetime</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; import pytz</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; aware = datetime.datetime.utcnow().replace(tzinfo=pytz.UTC)</span><br></pre></td></tr></table></figure><p>这样就生成了一个UTC时区的创建一个 aware datetime</p><p>另外一个方法</p><p>在Django中一个配置USE_TZ，该配置会影响<code>django.utils.timezone.now()</code>函数的返回，当 <em>USE_TZ = False</em> 返回 naive datetime，当 <em>USE_TZ = True</em> 返回 aware datetime</p><p>因此， 配置 <em>USE_TZ = False</em> 后即可与 datetime.timedelta 等进行计算比较等操作</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python时间日期处理</title>
      <link href="/2017/09/21/tech/python/datetime-explain.html"/>
      <url>/2017/09/21/tech/python/datetime-explain.html</url>
      
        <content type="html"><![CDATA[<h2 id="引入对象"><a href="#引入对象" class="headerlink" title="引入对象"></a>引入对象</h2><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">import</span> datetime</span><br></pre></td></tr></table></figure><h2 id="datetime基本操作"><a href="#datetime基本操作" class="headerlink" title="datetime基本操作"></a>datetime基本操作</h2><h3 id="1-获取datetime"><a href="#1-获取datetime" class="headerlink" title="1.获取datetime"></a>1.获取datetime</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; datetime.datetime.now()</span><br><span class="line">datetime.datetime(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">21</span>, <span class="number">15</span>, <span class="number">46</span>, <span class="number">32</span>, <span class="number">745801</span>)</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; datetime.datetime(<span class="number">2017</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">23</span>,<span class="number">45</span>)</span><br><span class="line">datetime.datetime(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">23</span>, <span class="number">45</span>)</span><br></pre></td></tr></table></figure><h3 id="2-获取date"><a href="#2-获取date" class="headerlink" title="2.获取date"></a>2.获取date</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; datetime.today()</span><br><span class="line">datetime.datetime(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">21</span>, <span class="number">15</span>, <span class="number">46</span>, <span class="number">32</span>, <span class="number">745801</span>)</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; datetime.date(<span class="number">2017</span>,<span class="number">9</span>,<span class="number">11</span>)</span><br><span class="line">datetime.date(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">11</span>)</span><br><span class="line">&gt;&gt;&gt; </span><br><span class="line">&gt;&gt;&gt; datetime.datetime(<span class="number">2017</span>,<span class="number">9</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">23</span>,<span class="number">45</span>).date()</span><br><span class="line">datetime.date(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">11</span>)</span><br></pre></td></tr></table></figure><h3 id="3-获取前N天-后N天"><a href="#3-获取前N天-后N天" class="headerlink" title="3.获取前N天/后N天"></a>3.获取前N天/后N天</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; datetime.date.today() - datetime.timedelta(days=<span class="number">1</span>)</span><br><span class="line">datetime.date(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">20</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; datetime.date.today() + datetime.timedelta(days=<span class="number">1</span>)</span><br><span class="line">datetime.date(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">22</span>)</span><br></pre></td></tr></table></figure><h3 id="4-获取当天开始和结束时间"><a href="#4-获取当天开始和结束时间" class="headerlink" title="4.获取当天开始和结束时间"></a>4.获取当天开始和结束时间</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="selector-tag">datetime</span><span class="selector-class">.datetime</span><span class="selector-class">.combine</span>(<span class="selector-tag">datetime</span><span class="selector-class">.date</span><span class="selector-class">.today</span>(), <span class="selector-tag">datetime</span><span class="selector-class">.time</span><span class="selector-class">.min</span>)</span><br><span class="line"><span class="selector-tag">datetime</span><span class="selector-class">.datetime</span>(2017, 9, 21, 0, 0)</span><br><span class="line">&gt;&gt;&gt; <span class="selector-tag">datetime</span><span class="selector-class">.datetime</span><span class="selector-class">.combine</span>(<span class="selector-tag">datetime</span><span class="selector-class">.date</span><span class="selector-class">.today</span>(), <span class="selector-tag">datetime</span><span class="selector-class">.time</span><span class="selector-class">.max</span>)</span><br><span class="line"><span class="selector-tag">datetime</span><span class="selector-class">.datetime</span>(2017, 9, 21, 23, 59, 59, 999999)</span><br></pre></td></tr></table></figure><h3 id="5-获取本周开始-结束日期"><a href="#5-获取本周开始-结束日期" class="headerlink" title="5.获取本周开始/结束日期"></a>5.获取本周开始/结束日期</h3><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;</span>&gt; today = datetime.date.today()</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; today</span><br><span class="line">datetime.date(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">21</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; today.weekday()</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; monday = today-datetime.timedelta(today.weekday())</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; monday</span><br><span class="line">datetime.date(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">18</span>)</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sunday = today + datetime.timedelta(<span class="number">6</span> - today.weekday())</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt; sunday</span><br><span class="line">datetime.date(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">24</span>)</span><br></pre></td></tr></table></figure><h2 id="关系转换"><a href="#关系转换" class="headerlink" title="关系转换"></a>关系转换</h2><h3 id="datetime-lt-gt-string"><a href="#datetime-lt-gt-string" class="headerlink" title="datetime &lt;=&gt; string"></a>datetime &lt;=&gt; string</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; datetime.datetime.now().strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line"><span class="string">'2017-09-21 16:03:44'</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; datetime.datetime.strptime(<span class="string">"2017-09-21 16:05:06"</span>, <span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line">datetime.datetime(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">21</span>, <span class="number">16</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure><h3 id="datetime-lt-gt-date"><a href="#datetime-lt-gt-date" class="headerlink" title="datetime &lt;=&gt; date"></a>datetime &lt;=&gt; date</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; datetime.datetime.now().date()</span><br><span class="line">datetime.date(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">21</span>)</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; today = datetime.date.today()</span><br><span class="line">&gt;&gt;&gt; datetime.datetime.combine(today, datetime.time())</span><br><span class="line">datetime.datetime(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">21</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">&gt;&gt;&gt; datetime.datetime.combine(today, datetime.time.min)</span><br><span class="line">datetime.datetime(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">21</span>, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure><h3 id="datetime-lt-gt-timestamp"><a href="#datetime-lt-gt-timestamp" class="headerlink" title="datetime &lt;=&gt; timestamp"></a>datetime &lt;=&gt; timestamp</h3><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; <span class="keyword">import</span> time</span><br><span class="line">&gt;&gt;&gt; now = datetime.datetime.now()</span><br><span class="line">&gt;&gt;&gt; now.timetuple()</span><br><span class="line">time.struct_time(tm_year=<span class="number">2017</span>, tm_mon=<span class="number">9</span>, tm_mday=<span class="number">21</span>, tm_hour=<span class="number">16</span>, tm_min=<span class="number">16</span>, tm_sec=<span class="number">48</span>, tm_wday=<span class="number">3</span>, tm_yday=<span class="number">264</span>, tm_isdst=<span class="number">-1</span>)</span><br><span class="line">&gt;&gt;&gt; time.mktime(now.timetuple())</span><br><span class="line"><span class="number">1505981808.0</span></span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt;datetime.datetime.fromtimestamp(<span class="number">1505981808.0</span>)</span><br><span class="line">datetime.datetime(<span class="number">2017</span>, <span class="number">9</span>, <span class="number">21</span>, <span class="number">16</span>, <span class="number">16</span>, <span class="number">48</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pandas中字符串和日期转换</title>
      <link href="/2017/09/21/tech/python/pandas-string-to-datetime.html"/>
      <url>/2017/09/21/tech/python/pandas-string-to-datetime.html</url>
      
        <content type="html"><![CDATA[<p>定义一个DataFrame</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; data = &#123;<span class="string">'state'</span>: [<span class="string">'US'</span>,<span class="string">'Ohio'</span>,<span class="string">'Nevada'</span>], <span class="string">'date'</span>:[<span class="string">'2001-09-12 21:11:09'</span>, <span class="string">'2001-09-13 06:32:19'</span>, <span class="string">'2002-02-23 04:12:19'</span>]&#125;</span><br><span class="line">&gt;&gt;&gt; df = pd.DataFrame(data)</span><br><span class="line">&gt;&gt;&gt; df</span><br><span class="line">                  date   state</span><br><span class="line"><span class="number">0</span>  <span class="number">2001</span><span class="number">-09</span><span class="number">-12</span>:<span class="number">21</span> <span class="number">11</span>:<span class="number">09</span>      US</span><br><span class="line"><span class="number">1</span>  <span class="number">2001</span><span class="number">-09</span><span class="number">-13</span>:<span class="number">06</span> <span class="number">32</span>:<span class="number">19</span>    Ohio</span><br><span class="line"><span class="number">2</span>  <span class="number">2002</span><span class="number">-02</span><span class="number">-23</span>:<span class="number">04</span> <span class="number">12</span>:<span class="number">19</span>  Nevada</span><br><span class="line">&gt;&gt;&gt; df[<span class="string">'date'</span>]</span><br><span class="line"><span class="number">0</span>    <span class="number">2001</span><span class="number">-09</span><span class="number">-12</span> <span class="number">21</span>:<span class="number">11</span>:<span class="number">09</span></span><br><span class="line"><span class="number">1</span>    <span class="number">2001</span><span class="number">-09</span><span class="number">-13</span> <span class="number">06</span>:<span class="number">32</span>:<span class="number">19</span></span><br><span class="line"><span class="number">2</span>    <span class="number">2002</span><span class="number">-02</span><span class="number">-23</span> <span class="number">04</span>:<span class="number">12</span>:<span class="number">19</span></span><br><span class="line">Name: date, dtype: object</span><br></pre></td></tr></table></figure><p>可以看到date列的dtype为<code>object</code>，现在需要转换成日期格式</p><p>可以使用<a href="http://pandas.pydata.org/pandas-docs/stable/generated/pandas.to_datetime.html#pandas.to_datetime" target="_blank" rel="noopener">to_datetime</a>来转换：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; pd.to_datetime(df[<span class="string">'date'</span>])</span><br><span class="line"><span class="number">0</span>   <span class="number">2001</span><span class="number">-09</span><span class="number">-12</span> <span class="number">21</span>:<span class="number">11</span>:<span class="number">09</span></span><br><span class="line"><span class="number">1</span>   <span class="number">2001</span><span class="number">-09</span><span class="number">-13</span> <span class="number">06</span>:<span class="number">32</span>:<span class="number">19</span></span><br><span class="line"><span class="number">2</span>   <span class="number">2002</span><span class="number">-02</span><span class="number">-23</span> <span class="number">04</span>:<span class="number">12</span>:<span class="number">19</span></span><br><span class="line">Name: date, dtype: datetime64[ns]</span><br></pre></td></tr></table></figure><p>Pandas已经自动将该列由<code>object</code>转成<code>datetime64[ns]</code></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>表格在移动端自适应的一种方法</title>
      <link href="/2015/02/10/tech/front/html_table_show.html"/>
      <url>/2015/02/10/tech/front/html_table_show.html</url>
      
        <content type="html"><![CDATA[<p><code>PS: 下文所说的窄距设备可以泛指移动端设备</code></p><p>在窄距设备中，表格很难搞，水平方向上没有足够的空间来舒适地摆放元素。因此可以在窄距设备上将表格变成两行，将一行的行头和单元格变成列。</p><p>下面来实现这个功能</p><p>首先一个普通的表格</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt; <span class="attr">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>Country<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>Desktop<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>Tablet<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span>Mobile<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">data-th</span>=<span class="string">"Country"</span>&gt;</span>India<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">data-th</span>=<span class="string">"Desktop"</span>&gt;</span>32%<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">data-th</span>=<span class="string">"Table"</span>&gt;</span>1%<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">data-th</span>=<span class="string">"Mobile"</span>&gt;</span>67%<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">data-th</span>=<span class="string">"Country"</span>&gt;</span>GB<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">data-th</span>=<span class="string">"Desktop"</span>&gt;</span>69%<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">data-th</span>=<span class="string">"Table"</span>&gt;</span>13%<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span> <span class="attr">data-th</span>=<span class="string">"Mobile"</span>&gt;</span>18%<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>它在桌面浏览器上是这样展示的</p><p><img src="/images/20150210144726.png" alt="普通情况下表格样式" title="普通情况下表格样式"></p><p>下面利用css3的媒体查询功能来实现表格的自适应。</p><p>这里我们设置的断点是<code>600px</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> (<span class="attribute">max-width:</span> <span class="number">600px</span>) &#123;</span><br><span class="line">    <span class="selector-tag">table</span> <span class="selector-tag">thead</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>: none;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">table</span> <span class="selector-tag">td</span> &#123;</span><br><span class="line">        <span class="attribute">display</span>: block;</span><br><span class="line">        <span class="attribute">position</span>: relative;</span><br><span class="line">        <span class="attribute">padding-left</span>: <span class="number">50%</span>;</span><br><span class="line">        <span class="attribute">padding-bottom</span>: <span class="number">15px</span>;</span><br><span class="line">        <span class="attribute">text-align</span>: left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">table</span> <span class="selector-tag">td</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">        <span class="attribute">content</span>: <span class="built_in">attr</span>(data-th) <span class="string">" :"</span>;</span><br><span class="line">        <span class="attribute">display</span>: inline-block;</span><br><span class="line">        <span class="attribute">position</span>: absolute;</span><br><span class="line">        <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">        <span class="attribute">width</span>: <span class="number">33%</span>;</span><br><span class="line">        <span class="attribute">max-height</span>: <span class="number">100%</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它在窄距设备是这样展示的</p><p><img src="/images/20150210150306.png" alt="修改后表格样式" title="修改后表格样式"></p><p>这样就比较完整的展示的表格的内容。</p><p>当然这只是表格自适应的其中一种办法，还有更多的办法哦O(∩_∩)O~</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript中正则表达式的工作原理和优化</title>
      <link href="/2015/01/30/tech/high_perf_js/regular_expression_optimization.html"/>
      <url>/2015/01/30/tech/high_perf_js/regular_expression_optimization.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>正则表达式的优化是一个相当广泛和细致入微的话题。粗浅地编写正则表达式是造成性能瓶颈的主要原因，有很多可以改进正则表达式效率的地方。两个正则表达式匹配相同的文本并不意味着他们具有同等的速度。</p><h2 id="2-正则表达式工作原理"><a href="#2-正则表达式工作原理" class="headerlink" title="2.正则表达式工作原理"></a>2.正则表达式工作原理</h2><p>一个正则表达式处理的基本步骤：</p><p><strong>第一步：编译</strong>  </p><p>当创建了一个正则表达式对象之后（使用一个正则表达式直接量或者 RegExp 构造器），浏览器检查你的模板有没有错误，然后开始执行匹配工作。如果你将正则表达式赋给一个变量，你可以避免重复执行此步骤。</p><p><strong>第二步：设置起始位置</strong> </p><p>当一个正则表达式投入使用时，目标字符串从起始位置开始匹配，或者由正则表达式的 lastIndex 属性指定。当执行到第四步执行失败后，回到上次起始位置的后面一个字符上开始匹配。</p><p><strong>第三步：匹配每个正则表达式的字元</strong>  </p><p>正则表达式一旦找好起始位置，它将一个一个地扫描目标文本和正则表达式模板。当一个特定字元匹配失败时，正则表达式将试图回溯到扫描之前的位置上，然后进入正则表达式其他可能的路径上。</p><p><strong>第四步：匹配成功或失败</strong>  </p><p>如果在字符串的当前位置上发现一个完全匹配，那么正则表达式宣布成功。如果正则表达式的所有可能路径都尝试过了，但是没有成功地匹配，那么正则表达式引擎回到第二步，从字符串的下一个字符重新尝试。只有字符串中的每个字符（以及最后一个字符后面的位置）都经历了这样的过程之后，还没有成功匹配，那么正则表达式就宣布彻底失败。</p><h2 id="3-正则表达式的回溯"><a href="#3-正则表达式的回溯" class="headerlink" title="3.正则表达式的回溯"></a>3.正则表达式的回溯</h2><p>正则表达式对目标字符串从左到右依次扫面，在每个字符的位置上是否匹配。对于每一个量词和分支，都必须决定如何继续进行。如果是一个量词（诸如*， +?，或者{2,}），正则表达式必须决定何时尝试匹配更多的字符；如果遇到分支（通过|操作符），它必须从这些选项中选择一个进行尝试。</p><p>正则表达式对于每一个量词和分支的匹配，会选择一个方案，然后记住其他选项返回备用。当所选方案匹配成功，继续扫描，如果其他部分的匹配也成功，则匹配结束。而如果所选方案匹配失败，或者其他部分的匹配失败，正则表达式会回溯到上一个选择点，选择其他方案执行上面的过程匹配，如果量词和分支的所有排列组合都匹配失败了，就放弃该位置的匹配，到该位置的下一个字符上重复此过程。</p><p><em>分支结构的栗子</em>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/h(ello|appy) hippo/.test(<span class="string">"hello there, happy hippo"</span>);</span><br></pre></td></tr></table></figure><p>匹配过程：</p><p>该正则表达式匹配“hello hippo”或“happy hippo”。<br>首先查找字符”h”，目标字符串的第一个字符就是h。<br>接下来有一个分支结构(ello|appy)，它提供了两个选项，正则表达式先选择最左边的”ello”匹配，发现匹配。<br>接下来匹配空格，成功。<br>下面匹配”h”，不能匹配接下来的字符t，匹配失败。<br>回溯到上一个检查点（匹配首字符h的下一个字符），匹配下一个分支选项”appy”，匹配失败。<br>由于没有更多选项，从第二个字符开始重新匹配该字符串。<br>由于没有找到h继续找到，知道找到第14个字符找到，匹配到h。<br>接下来匹配分支结构，和上面的过程一个，”ello”匹配失败，回溯到分支过程开始匹配”appy”。<br>下面匹配”hippo”，匹配成功结束。</p><p><em>量词结构的栗子：</em></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">"&lt;p&gt;Para 1.&lt;/p&gt;&lt;img src='smiley.jpg'&gt;&lt;p&gt;Para 2.&lt;/p&gt;&lt;div&gt;Div.&lt;/div&gt;"</span></span><br><span class="line">/<span class="xml"><span class="tag">&lt;<span class="name">p</span>&gt;</span>.*<span class="tag">&lt;<span class="name">\</span>/<span class="attr">p</span>&gt;</span>/i.test(str)</span></span><br></pre></td></tr></table></figure><p>匹配过程：</p><p>首先开始匹配了字符串开始三个字符<code>&lt;p&gt;</code>。<br>接下来匹配<code>.*</code>。<code>.</code>匹配除换行符以外的任意字符，<code>*</code>是一个贪婪量词，表示重复零次或多次，并且匹配尽量多的次数。因为目标字符串中没有换行符，它将吞噬<br>剩下的全部字符串！<br>接下来正则表达式从字符串末尾来时匹配<code>&lt;</code>，匹配最后一个字符失败，回溯上一个字符继续匹配，直到回到<code>&lt;/div&gt;</code>的<code>&lt;</code>位置。<br>然后匹配反斜杠<code>/</code>。成功。<br>然后匹配p，失败。<br>继续回溯，重复上面的过程，直到匹配了<code>&lt;/p&gt;</code>，成功。</p><p>这是贪婪匹配的模式，可能有时想要的匹配过程不是这样的。这时可以将贪婪量词<code>*</code>，改为懒惰量词<code>*?</code>。懒惰量词的回溯是和贪婪量词相反。当正则表达式<code>/&lt;p&gt;.*?&lt;\/p&gt;/</code>推进到<code>.*?</code>时。由于它是尽量少重复的匹配，下面就开始匹配<code>&lt;/p&gt;</code>，匹配字符”P”失败，直到遇到<code>&lt;/p&gt;</code>停止匹配，匹配到的就是<code>&lt;p&gt;Para 1.&lt;/p&gt;</code>。</p><p>如果目标字符串只有一个段落，此正则表达式的贪婪版本和懒惰版本是等价的，只是他们尝试匹配的过程不同。</p><p><img src="/images/20150130182803.jpg" alt="匹配过程" title="匹配过程"></p><h2 id="3-提高正则表达式效率的方法"><a href="#3-提高正则表达式效率的方法" class="headerlink" title="3.提高正则表达式效率的方法"></a>3.提高正则表达式效率的方法</h2><p><em>关注如何让匹配更快失败</em></p><p>正则表达式处理慢往往是因为匹配失败过程慢，而不是匹配成功过程慢。让正则匹配更快失效是提高效率的方法之一。</p><p><strong>正则表达式以简单的，必需的字元开始</strong></p><p>最理想的情况是，一个正则表达式的起始字元应当尽可能快速地排除明显不匹配的位置。用于此目的好的起始字元通常是一个锚（ ^或$），特定字符（例如 x 或\u363A），字符类（例如， [a-z]或\d），和单词边界（ \b）。如果可能的话，避免以分组或选择字元开头，避免顶级分支例如/one|two/，因为它强迫正则表达式识别多种起始字元。例如例如，以<code>\s\s*</code>替代<code>\s+</code>或<code>\s{1,}</code>。</p><p><strong>具体化正则表达式模板</strong></p><p>例如当你想表达“<code>[^&quot;\r\n]*</code>”时不要使用“<code>.*?</code>”</p><p><strong>减少分支的数量，缩小它们的范围</strong></p><p>分支使用 <code>|</code> ,可通过使用字符类和选项组件减少对分支的需求，或将分支在正则表达式上的位置推后。例如：</p><p>用<code>[cb]at</code>代替<code>cat|bat</code>；<br>用<code>rea?d</code>代替<code>red|read</code>；<br>用<code>r(?:ed|aw)</code>代替<code>red|raw</code>；<br>用<code>[\s\S]</code>代替<code>(.|\r|\n)</code>；  </p><p>字符类比分支更快，因为他们没有使用回溯，避免了性能开销。</p><p><strong>将正则表达式赋给变量，以重用它们</strong></p><p>将正则表达式赋给变量以避免对它们重新编译。</p><p><strong>将复杂的正则表达式拆分为简单的片断</strong></p><p>尽量避免一个正则表达式做太多的工作。复杂的搜索问题需要条件逻辑，拆分为两个或多个正则表达式<br>更容易解决，通常也更高效。</p><h2 id="4-什么时候不应该使用正则表达式"><a href="#4-什么时候不应该使用正则表达式" class="headerlink" title="4.什么时候不应该使用正则表达式"></a>4.什么时候不应该使用正则表达式</h2><p>小心使用它，正则表达式是非常快的。然而，当你只是搜索文字字符串时就没有必要使用了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/;$/.test(str);</span><br></pre></td></tr></table></figure><p>上面的正则是匹配末尾分号的。正则表达式一个一个匹配字符串，当遇到分号，就匹配下一个字符看是不是字符串末尾，不是就继续匹配，这样就匹配了整个字符串。这是没有必要的。</p><p>更好的办法是跳过正则表达式所需的所有中间步骤， 简单地检查最后一个字符是不是分号：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.charAt(str.length - <span class="number">1</span>) == <span class="string">";"</span>;</span><br></pre></td></tr></table></figure><p>字符串函数 slice， substr，和 substring 可用于在特定位置上提取并检查字符串的值。此外， indexOff和 lastIndexOf函数非常适合查找特定字符串的位置，或者判断它们是否存在。灵活的使用这些函数，可以避免使用正则表达式带来的性能开销。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript流程控制对性能的影响</title>
      <link href="/2015/01/29/tech/high_perf_js/algorithms_and_flow_control.html"/>
      <url>/2015/01/29/tech/high_perf_js/algorithms_and_flow_control.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>代码整体结构是执行速度的决定因素之一。 代码量少不一定运行速度快， 代码量多也不一定运行速度慢。性能损失与代码组织方式和具体问题解决办法直接相关。</p><h2 id="2-循环"><a href="#2-循环" class="headerlink" title="2.循环"></a>2.循环</h2><p>在各种编程语言中，循环占了很大一部分，因此它是提高性能所需要关注的重点之一。理解 JavaScript 中循环对性能的影响至关重要，因为死循环或者长时间运行的循环会严重影响用户体验。</p><h3 id="2-1-循环的类型"><a href="#2-1-循环的类型" class="headerlink" title="2.1 循环的类型"></a>2.1 循环的类型</h3><ul><li>for循环</li><li>while循环</li><li>do-while循环</li><li>for-in循环</li></ul><p>在四种循环中，前三种的性能差别不大，而第四种循环则明显慢于前三种。</p><p>for-in循环中由于每次迭代操作要搜索实例或原形的属性,for-in 循环每次迭代都要付出更多开销。因此除了遍历数量不详的对象外，要避免使用该循环。如果你迭代遍历一个有限的,已知的属性列表,使用其他循环类型更快:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="string">"prop1"</span>:<span class="number">1</span>, <span class="string">"prop2"</span>:<span class="number">2</span>&#125;,</span><br><span class="line">    props = [<span class="string">"prop1"</span>, <span class="string">"prop2"</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;props.length; i++)&#123;</span><br><span class="line">    process(obj[props[i]]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在其他三种类型的循环中，选择哪种方式，应该基于需求。</p><ul><li>每次迭代干什么</li><li>迭代的次数</li></ul><p>可以根据这两种来书写合理的循环结构</p><h3 id="2-2-减少每次循环的工作量"><a href="#2-2-减少每次循环的工作量" class="headerlink" title="2.2 减少每次循环的工作量"></a>2.2 减少每次循环的工作量</h3><p>一个典型的数组处理循环,可使用三种循环的任何一种。最常用的代码写法如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; items.length; i++)&#123;</span><br><span class="line">    process(items[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (j &lt; items.length)&#123;</span><br><span class="line">    process(items[j++]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> k=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    process(items[k++]);</span><br><span class="line">&#125; <span class="keyword">while</span> (k &lt; items.length);</span><br></pre></td></tr></table></figure><p>在每个循环中,每次运行循环体都要发生如下几个操作:</p><ol><li>在控制条件中读一次属性(items.length)</li><li>在控制条件中执行一次比较(i &lt; items.length)</li><li>比较操作,察看条件控制体的运算结果是不是 true(i &lt; items.length == true)</li><li>一次自加操作(i++)</li><li>一次数组查找(items[i])</li><li>一次函数调用(process(items[i]))</li></ol><p>在这些步骤中，有些是可以精简的。</p><p>精简后：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=items.length; i--; )&#123;</span><br><span class="line">    process(items[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> j = items.length;</span><br><span class="line"><span class="keyword">while</span> (j--)&#123;</span><br><span class="line">    process(items[j]]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> k = items.length<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    process(items[k]);</span><br><span class="line">&#125; <span class="keyword">while</span> (k--);</span><br></pre></td></tr></table></figure><p>首先减少对象成员和数组项查找的次数。在上个例子中每次循环都查找 items.length。这是一种浪费,因为该值在循环体执行过程中不会改变,可以将此值存入一局部变量中。</p><p>还可以通过改变他们的顺序提高循环性能。倒序循环是编程语言中常用的性能优化方法。使用倒序循环,并在控制条件中使用了减法。每个控制条件只是简单地与零进行比较。实际上,控制条件已经从两次比较(迭代少于总数吗?它等于 true 吗?)减少到一次比较(它等于 true 吗?)。</p><p>在精简后每个循环中,发生了:</p><ol><li>在控制条件中进行一次比较(i == true)</li><li>一次减法操作(i–)</li><li>一次数组查询(items[i])</li><li>一次函数调用(process(items[i]))</li></ol><h3 id="2-3-减少迭代次数"><a href="#2-3-减少迭代次数" class="headerlink" title="2.3 减少迭代次数"></a>2.3 减少迭代次数</h3><p>减少循环的迭代次数的方法，最广为人知的限制循环迭代次数的模式称作“达夫设备”。关于“达夫设备”可一自行google，不做详细描述。</p><h2 id="3-条件表达式"><a href="#3-条件表达式" class="headerlink" title="3. 条件表达式"></a>3. 条件表达式</h2><h3 id="3-1-if-else-与-switch-比较"><a href="#3-1-if-else-与-switch-比较" class="headerlink" title="3.1 if-else 与 switch 比较"></a>3.1 if-else 与 switch 比较</h3><p>使用 if-else 或者 switch 的流行理论是基于测试条件的数量:条件数量较大,倾向于使用 switch 而不是if-else。</p><p>在易读性上，如果条件较少时,if-else 容易阅读,而条件较多时 switch更容易阅读。</p><p>只有在条件数量很大时，switch才比if-else快，两者之间的区别是，条件体的工作量对if-else的性能影响较大。</p><p>###3.2 优化 if-else</p><p>优化 if-else 的目标总是最小化找到正确分支之前所判断条件体的数量。最简单的优化方法是将最常见的条件体放在首位。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (value &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &gt; <span class="number">5</span> &amp;&amp; value &lt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码只有当 value 值经常小于 5 时才是最优的。在if-else条件的排列要按照概率从大到小的顺序排列。</p><p>##4. 总结</p><ul><li>for,while,do-while 循环的性能特性相似,谁也不比谁更快或更慢。</li><li>只在遍历一个属性未知的对象时使用 for-in 循环。</li><li>改善循环性能的办法是减少每次迭代中的运算量,并减少循环迭代次数。</li><li>switch 与 if-else 的性能差别不大，可以根据可读性来选择使用哪一种方法</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript采用事件托管提高事件处理的效率</title>
      <link href="/2015/01/23/tech/high_perf_js/event_delegation.html"/>
      <url>/2015/01/23/tech/high_perf_js/event_delegation.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>当页面中存在大量元素,而且每个元素有一个或多个事件句柄与之挂接(例如 onclick)时,可能会影响性能。连接每个句柄都是有代价的,无论其形式是加重了页面负担(更多的页面标记和 JavaScript 代码)还是表现在运行期的运行时间上。你需要访问和修改更多的 DOM 节点,程序就会更慢,特别是因为事件挂接过程都发生在 onload(或 DOMContentReady)事件中,而onload则是网页的一个繁忙时间段。挂接事件占用了处理时间,另外,浏览器需要保存每个句柄的记录,占用更多内存。当这些工作结束时,这些事件句柄中的相当一部分根本不需要(因为并不是 100%的按钮或者链接都会被用户点到),所以很多工作都是不必要的。</p><p>我们可以利用一个简单的方式来处理这种情况：事件托管。</p><h2 id="2-事件运行的阶段"><a href="#2-事件运行的阶段" class="headerlink" title="2.事件运行的阶段"></a>2.事件运行的阶段</h2><p>DOM事件的运行分为三个阶段</p><ul><li>事件捕获</li><li>事件到达目标</li><li>事件冒泡</li></ul><p>在IE中不支持事件捕获。</p><h2 id="3-事件托管"><a href="#3-事件托管" class="headerlink" title="3.事件托管"></a>3.事件托管</h2><p>事件托管主要依赖的是事件冒泡。一个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">"menu"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#a"</span>&gt;</span>a<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#b"</span>&gt;</span>b<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#c"</span>&gt;</span>c<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在这个HTML中，点击<code>#a</code>标签，点击事件首先被<code>&lt;a&gt;</code>标签获取到，然后它沿着DOM树向上冒泡，被<code>li</code>元素收到，然后是<code>ul</code>和<code>div</code>，最后到达DOM顶层。而这时如果在它的父元素上加一个事件句柄，是可以收到它的子元素的事件通知的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'menu'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//兼容IE</span></span><br><span class="line">    e = e || <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">var</span> target = e.target || e.srcElement;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (target.nodeName !== <span class="string">'A'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ... <span class="comment">// 需要对a标签所做的处理</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">当然，我们也可以在DOM最顶级元素上面添加事件，这样页面上就只有一个事件句柄，大大减少了浏览器内存的消耗，提高了运行速度。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>JavaScript</span><br><span class="line"><span class="built_in">document</span>.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//兼容IE</span></span><br><span class="line">    e = e || <span class="built_in">window</span>.event;</span><br><span class="line">    <span class="keyword">var</span> target = e.target || e.srcElement,</span><br><span class="line">        targetNodeName = target.nodeName;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (targetNodeName == <span class="string">'A'</span>) &#123;</span><br><span class="line">        <span class="comment">// 一些处理...</span></span><br><span class="line">    &#125;elseif(targetNodeName == <span class="string">'li'</span>)&#123;</span><br><span class="line">        <span class="comment">// 一些处理...</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 一些处理...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用事件托管除了可以减少页面的句柄，提高性能。而且也能够避免获取不到ajax加载出来的元素，如果采用一般的方法给ajax加载的元素添加事件，由于添加事件是在页面的onload过程的产生的，而那是这些元素还没有加载到页面里面，因此也就获取不到了，采用事件托管可以有效的避免这种情况的发生（PS：深有感触啊！）</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript在访问和操作DOM对象的注意点</title>
      <link href="/2015/01/22/tech/high_perf_js/dom_scripting.html"/>
      <url>/2015/01/22/tech/high_perf_js/dom_scripting.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>在浏览器中，DOM实现和JavaScript实现是保持相互独立的，这意味着两个独立的部分以功能接口连接就会带来性能损耗。每当 JavaScript 要访问DOM时，就需要调用接口。这个过程中就会产生性能损耗，次数越多，损耗越大。我们应该减少JavaScript 访问DOM的次数，尽量在JavaScript部分完成。</p><h2 id="2-DOM-访问和修改"><a href="#2-DOM-访问和修改" class="headerlink" title="2.DOM 访问和修改"></a>2.DOM 访问和修改</h2><p>每当 JavaScript 要访问DOM时，会产生性能损耗，而访问或修改元素最坏的情况是使用循环执行此操作，特别是在 HTML 集合中使用循环。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">innerHTMLLoop</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> count = <span class="number">0</span>; count &lt; <span class="number">10000</span>; count++) &#123;</span><br><span class="line">        <span class="built_in">document</span>.getElementById(<span class="string">'here'</span>).innerHTML += <span class="string">'a'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">innerHTMLLoop2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> content = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> count = <span class="number">0</span>; count &lt; <span class="number">10000</span>; count++) &#123;</span><br><span class="line">        content += <span class="string">'a'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'here'</span>).innerHTML += content;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中，<code>innerHTMLLoop</code> 循环更新页面的内容，并且是访问两次，一次读取，一次写入。<code>innerHTMLLoop2</code> 使用局部变量存储更新后的内容，在循环结束时一次性写入。两种写法当然是第二种更有效率</p><p><img src="/images/20150122144500.png" alt="运行结果" title="运行结果"></p><p>可以看到简直是‘惨不忍睹’啊。这些结果清楚地表明，你访问 DOM 越多，代码的执行速度就越慢。因此，一般经验法则是：减少访问的次数，尽量在JavaScript中完成操作。</p><h2 id="3-HTML集合"><a href="#3-HTML集合" class="headerlink" title="3.HTML集合"></a>3.HTML集合</h2><p>HTML 集合是用于存放 DOM 节点引用的类数组对象。下列函数的返回值就是一个集合：</p><ul><li>document.getElementsByName()</li><li>document.getElementsByClassName()</li><li>document.getElementsByTagName()</li></ul><p>下列属性也属于 HTML 集合：</p><ul><li>document.images             页面中所有的<code>&lt;img&gt;</code>元素</li><li>document.links              页面中所有的<code>&lt;a&gt;</code>元素</li><li>document.forms              页面中所有的表单元素</li><li>document.forms[0].elements  页面中第一个表单的所有字段</li></ul><p>这些方法和属性返回 HTMLCollection 对象，是一种类似数组的列表。它们不是数组（因为它们没有诸如 push()或 slice()之类的方法），但是提供了一个 length 属性，和数组一样你可以使用索引访问列表中的元素。</p><p>HTML 集合是一个“虚拟存在，意味着当底层文档更新时，它们将自动更新”。</p><p>HTML 集合实际上在查询文档。 当更新文档时，每次都要重复执行这种查询操作。例如读取集合中元素的数目（也就是集合的 length）。这正是低效率的来源。</p><h3 id="3-1-集合的循环"><a href="#3-1-集合的循环" class="headerlink" title="3.1 集合的循环"></a>3.1 集合的循环</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> alldivs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; alldivs.length; i++) &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.appendChild(<span class="built_in">document</span>.createElement(<span class="string">'div'</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这段代码是一个错误的代码，它并不是简单地遍历页面的div元素，然后添加一个新的div，它是一个死循环，因为alldivs.length在每次迭代循环中会增加，它反映了底层文档的当前状态。</p><p>因此，不建议用集合的length属性做循环条件，因为它意味着每次都要重新运行查询过程。可以将一个集合 coll 拷贝到数组arr 中，或者用一个变量，len将length属性缓存起来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toArray</span>(<span class="params">coll</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, a = [], len = coll.length; i &lt; len; i++) &#123;</span><br><span class="line">        a[i] = coll[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 设置一个集合，并把它拷贝到一个数组：</span></span><br><span class="line"><span class="keyword">var</span> coll = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>);</span><br><span class="line"><span class="keyword">var</span> arr = toArray(coll);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loopCollection</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> count = <span class="number">0</span>; count &lt; coll.length; count++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loopCopiedArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> count = <span class="number">0</span>; count &lt; arr.length; count++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loopCacheLengthCollection</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> coll = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>),</span><br><span class="line">    len = coll.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> count = <span class="number">0</span>; count &lt; len; count++) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的例子中采用了三种循环方式：<code>loopCollection</code>每次迭代访问集合的length属性时，集合都会更新，会产生明显的性能损耗。<code>loopCopiedArray</code>则是将集合 coll 拷贝到数组arr 中，这样就避免了访问集合。<code>loopCacheLengthCollection</code>是将集合的 length 属性缓存到一个变量中，然后在循环判断条件中使用这个变量，这样也避免了访问集合。</p><p>后两种的运行速度一样快</p><p>在chrome下循环100,000个节点</p><p><img src="/images/20150122154637.png" alt="运行结果" title="运行结果"></p><h3 id="3-2-使用局部变量访问集合元素"><a href="#3-2-使用局部变量访问集合元素" class="headerlink" title="3.2 使用局部变量访问集合元素"></a>3.2 使用局部变量访问集合元素</h3><p>一般来说，对于任何类型的 DOM 访问，如果同一个 DOM 属性或方法被访问一次以上，最好使用一个局部变量缓存此 DOM 成员。当遍历一个集合时，第一个优化是将集合引用存储于局部变量，并在循环之外缓存 length 属性。然后，如果在循环体中多次访问同一个集合元素，那么使用局部变量缓存它。</p><p><strong>速度最慢</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectionGlobal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> coll = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>),</span><br><span class="line">    len = coll.length,</span><br><span class="line">    name = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> count = <span class="number">0</span>; count &lt; len; count++) &#123;</span><br><span class="line">        name = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[count].nodeName;</span><br><span class="line">        name = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[count].nodeType;</span><br><span class="line">        name = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>)[count].tagName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>速度有所提升</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectionLocal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> coll = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'div'</span>),</span><br><span class="line">    len = coll.length,</span><br><span class="line">    name = <span class="string">''</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> count = <span class="number">0</span>; count &lt; len; count++) &#123;</span><br><span class="line">        name = coll[count].nodeName;</span><br><span class="line">        name = coll[count].nodeType;</span><br><span class="line">        name = coll[count].tagName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>速度最快</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">collectionNodesLocal</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> coll = <span class="built_in">document</span>.getElementsByTagName_r(<span class="string">'div'</span>),</span><br><span class="line">    len = coll.length,</span><br><span class="line">    name = <span class="string">''</span>,</span><br><span class="line">    el = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> count = <span class="number">0</span>; count &lt; len; count++) &#123;</span><br><span class="line">        el = coll[count];</span><br><span class="line">        name = el.nodeName;</span><br><span class="line">        name = el.nodeType;</span><br><span class="line">        name = el.tagName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因此，访问集合时，通过局部引用访问集合可以带来速度提升；当多次访问时，使用缓存集合项来提升性能。</p><h2 id="4-页面重绘和重排版"><a href="#4-页面重绘和重排版" class="headerlink" title="4.页面重绘和重排版"></a>4.页面重绘和重排版</h2><p>当浏览器下载完所有页面 HTML 标记， JavaScript， CSS，图片之后，它解析文件并创建两个内部数据结构：</p><ul><li>一棵 DOM 树：表示页面结构</li><li>一棵渲染树：表示 DOM 节点如何显示</li></ul><p>渲染树中为每个需要显示的 DOM 树节点存放至少一个节点，而隐藏的DOM元素则没有。渲染树上的节点称为“框”或者“盒”，符合 CSS 模型的定义，将页面元素看作一个具有填充、边距、边框和位置的盒。一旦 DOM 树和渲染树构造完毕，浏览器就可以显示（绘制）页面上的元素了。</p><p>当 DOM 改变影响到元素的几何属性（宽和高），浏览器需要重新计算元素的几何属性，而且其他元素的几何属性和位置也会因此改变受到影响。浏览器使渲染树上受到影响的部分失效，然后重构渲染树。这个过程被称作重排版。</p><p>不是所有的 DOM 改变都会影响几何属性。例如，改变一个元素的背景颜色不会影响它的宽度或高度。在这种情况下，只需要重绘（不需要重排版），因为元素的布局没有改变。</p><p>重绘和重排版是负担很重的操作，可能导致网页应用的用户界面失去相应。所以，十分有必要尽可能减少这类事情的发生。</p><h3 id="4-1-何时页面重排版"><a href="#4-1-何时页面重排版" class="headerlink" title="4.1 何时页面重排版"></a>4.1 何时页面重排版</h3><p>在下述情况中会发生重排版：</p><ul><li>添加或删除可见的 DOM 元素</li><li>元素位置改变</li><li>元素尺寸改变（因为边距，填充，边框宽度，宽度，高度等属性改变）</li><li>内容改变，例如，文本改变或图片被另一个不同尺寸的所替代</li><li>最初的页面渲染</li><li>浏览器窗口改变尺寸</li></ul><h3 id="4-2-查询元素导致刷新渲染树改变"><a href="#4-2-查询元素导致刷新渲染树改变" class="headerlink" title="4.2 查询元素导致刷新渲染树改变"></a>4.2 查询元素导致刷新渲染树改变</h3><p>在大多数浏览器中，是通过队列化的方式来修改和批量显示优化重排版。但是还有一些操作（获取布局信息）会导致强迫队列刷新，并立即重排版：</p><ul><li>offsetTop, offsetLeft, offsetWidth, offsetHeight</li><li>scrollTop, scrollLeft, scrollWidth, scrollHeight</li><li>clientTop, clientLeft, clientWidth, clientHeight</li><li>getComputedStyle() (currentStyle in IE)（在 IE 中此函数称为 currentStyle）</li></ul><p>获取布局信息需要返回最新的数据， 所以浏览器不得不立即运行渲染队列中待改变的项目并重新排版以返回正确的值。</p><p>因此，当在改变页面样式时，最好不要使用前面列出的那些属性。无论你的操作是否改变的页面的布局信息，都将刷新渲染队列，导致重排版。</p><p>一个栗子：</p><p><strong>分次重排版</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> computed,</span><br><span class="line">tmp = <span class="string">''</span>,</span><br><span class="line">bodystyle = <span class="built_in">document</span>.body.style;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">document</span>.body.currentStyle) &#123; <span class="comment">// IE, Opera</span></span><br><span class="line">    computed = <span class="built_in">document</span>.body.currentStyle;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// W3C</span></span><br><span class="line">    computed = <span class="built_in">document</span>.defaultView.getComputedStyle(<span class="built_in">document</span>.body, <span class="string">''</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bodystyle.color = <span class="string">'red'</span>;</span><br><span class="line">tmp = computed.backgroundColor;</span><br><span class="line">bodystyle.color = <span class="string">'white'</span>;</span><br><span class="line">tmp = computed.backgroundImage;</span><br><span class="line">bodystyle.color = <span class="string">'green'</span>;</span><br><span class="line">tmp = computed.backgroundAttachment;</span><br></pre></td></tr></table></figure><p><strong>统一重排版</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bodystyle.color = <span class="string">'red'</span>;</span><br><span class="line">bodystyle.color = <span class="string">'white'</span>;</span><br><span class="line">bodystyle.color = <span class="string">'green'</span>;</span><br><span class="line">tmp = computed.backgroundColor;</span><br><span class="line">tmp = computed.backgroundImage;</span><br><span class="line">tmp = computed.backgroundAttachment;</span><br></pre></td></tr></table></figure><p>在第一个例子中，body 元素的前景色被改变了三次，每次改变之后，都访问 computed 的风格。访问的属性 backgroundColor, backgroundImage, 和 backgroundAttachment 与颜色改变无关。但是，浏览器仍然需要刷新渲染队列并重排版，因为 computed 的风格被查询而引发。</p><p>第二个例子，则是在所有改变都完成以后，再访问 computed 的风格，因此性能会得到提升：</p><p><img src="/images/20150122162931.png" alt="运行结果" title="运行结果"></p><h3 id="4-3-最小化重绘和重排版"><a href="#4-3-最小化重绘和重排版" class="headerlink" title="4.3 最小化重绘和重排版"></a>4.3 最小化重绘和重排版</h3><p>重排版和重绘代价昂贵，所以，提高程序响应速度一个好策略是减少此类操作发生的机会。为减少发生次数，将多个 DOM 和风格改变合并到一个批次中一次性执行。</p><p>当需要对 DOM 元素进行多次修改时，你可以通过以下步骤减少重绘和重排版的次数：</p><ol><li>从文档流中摘除该元素</li><li>对其应用多重改变</li><li>然后将元素带回文档中</li></ol><p>在此过程引发两次重排版——第一步引发一次，第三步引发一次。如果你忽略了这两个步骤，那么第二步中每次改变都将引发一次重排版。</p><p>有三种办法可以在文档流中摘除元素</p><ol><li>隐藏元素，进行修改，然后再显示它。</li><li>使用一个文档片断在已存 DOM 之外创建一个子树，然后将它拷贝到文档中。</li><li>将原始元素拷贝到一个脱离文档的节点中，修改副本，然后覆盖原始元素。</li></ol><p>第一种方法很简单，改变 display 属性即可</p><p>第二种方法：文档片断是一个轻量级的 document 对象，它被设计专用于更新、移动节点之类的任务。  </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment();</span><br><span class="line">appendDataToElement(fragment, data);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'mylist'</span>).appendChild(fragment);</span><br></pre></td></tr></table></figure><p>第三种方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> old = <span class="built_in">document</span>.getElementById(<span class="string">'mylist'</span>);</span><br><span class="line"><span class="keyword">var</span> clone = old.cloneNode(<span class="literal">true</span>);</span><br><span class="line">appendDataToElement(clone, data);</span><br><span class="line">old.parentNode.replaceChild(clone, old);</span><br></pre></td></tr></table></figure><p>推荐尽可能使用文档片断（第二种解决方案）因为它涉及最少数量的 DOM 操作和重排版。</p><h2 id="5-缓冲布局信息"><a href="#5-缓冲布局信息" class="headerlink" title="5.缓冲布局信息"></a>5.缓冲布局信息</h2><p>浏览器通过队列化修改和批量运行的方法，尽量减少重排版次数。当查询布局信息如偏移量、滚动条位置，或风格属性时，浏览器刷队列并执行一些修改操作，以返回最新的数值。最好是尽量减少对布局信息的查询次数，查询时将它赋给局部变量，并用局部变量参与计算。</p><h2 id="6-将元素提出动画流"><a href="#6-将元素提出动画流" class="headerlink" title="6.将元素提出动画流"></a>6.将元素提出动画流</h2><p>在动画处理中使用绝对坐标，避免修改时对页面其他元素的影响</p><p>使用绝对坐标定位页面动画的元素，使它位于页面布局流之外。当它的尺寸改变时，就不会推移页面中其他元素的位置，而只是覆盖其他元素。</p><p>启动元素动画。当它扩大时，其他元素的坐标并没有改变，换句话说，其他元素并没有因为“动画元素”的扩大而随之下移，而是任由动画元素覆盖。</p><p>动画结束时，将其他元素的位置下移到动画元素下方，界面“跳”了一下。</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><p>DOM 访问和操作是现代网页应用中很重要的一部分。Javascript每次访问DOM时都会产生性能消耗。为减少 DOM 访问和操作中的性能损失，要注意以下几点：</p><ul><li>最小化 DOM 访问，在 JavaScript 端做尽可能多的事情。</li><li>在反复访问的地方使用局部变量存放 DOM 引用.</li><li>将集合的 length 属性缓存到一个变量中，在迭代中使用这个变量。如果经常操作这个集合，可以将集合拷贝到数组中。</li><li>注意重绘和重排版；批量修改风格，离线操作 DOM 树，缓存并减少对布局信息的访问。</li><li>动画中使用绝对坐标，使用拖放代理。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript对象的嵌套成员对性能的影响</title>
      <link href="/2015/01/20/tech/high_perf_js/nested_members.html"/>
      <url>/2015/01/20/tech/high_perf_js/nested_members.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>对象成员中可能会包含其他成员，例如全局对象window包含成员location，而location又包含其他成员。window.location.href，在这种写法中，没遇到一个点号，JavaScript 引擎就要在对象成员上执行一次解析过程。很明显，当成员嵌套越深，访问速度越慢。location.href总是快于 window.location.href，如果访问的不是对象的实例属性，那么，在这种写法中，没遇到一个点号，JavaScript 引擎还要在每个点上搜索原形链，这将需要更长时间。</p><h2 id="2-缓存对象成员的值"><a href="#2-缓存对象成员的值" class="headerlink" title="2.缓存对象成员的值"></a>2.缓存对象成员的值</h2><p>当在一个函数里多次调用一个对象成员时，需要注意：可以将成员对象缓存起来，放入一个局部变量，将搜索次数减少为一次。</p><p>看下面这个栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasEitherClass</span>(<span class="params">element, className1, className2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> element.className == className1 || element.className == className2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasEitherClassByCache</span>(<span class="params">element, className1, className2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> currentClassName = element.className;</span><br><span class="line">    <span class="keyword">return</span> currentClassName == className1 || currentClassName == className2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>hasEitherClass</code>中，element.className 被访问了两次，而在这个函数中，它的值并不会改变。所以又一次多余的搜索过程。在<code>hasEitherClassByCache</code>中变量被缓存了，成员搜索只进行了一次，因此速度回有所提升。</p><p>可以比较一下结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'input'</span>)[<span class="number">0</span>];</span><br><span class="line">Test.run( <span class="string">'无缓存'</span> ); </span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">99999</span>; i++ ) &#123;</span><br><span class="line">    hasEitherClass(el,<span class="string">'className1'</span>,<span class="string">'className2'</span>);</span><br><span class="line">&#125;</span><br><span class="line">Test.stop();</span><br><span class="line">Test.run( <span class="string">'有缓存'</span> ); </span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">99999</span>; i++ ) &#123;</span><br><span class="line">    hasEitherClassByCache(el,<span class="string">'className1'</span>,<span class="string">'className2'</span>);</span><br><span class="line">&#125;</span><br><span class="line">Test.stop(); </span><br><span class="line">Test.output( <span class="string">'缓存成员对速度的影响'</span> );</span><br></pre></td></tr></table></figure><p><img src="/images/20150121113349.jpg" alt="运行结果" title="运行结果"></p><p>一般来说，如果在同一个函数中你要多次读取同一个对象属性，并且它不会发生改变，最好将它存入一个局部变量。以局部变量替代属性，避免多余的属性查找带来性能开销。在处理嵌套对象成员时这点特别重要，它们会对运行速度产生影响。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript原型链分析</title>
      <link href="/2015/01/19/tech/high_perf_js/prototype_chains.html"/>
      <url>/2015/01/19/tech/high_perf_js/prototype_chains.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>JavaScript 中的对象是基于原型的。原型是其他对象的基础，定义并实现了一个新对象所必须具有的成员。这一概念完全不同于传统面向对象编程中“类”的概念，它定义了创建新对象的过程。原型对象为所有给定类型的对象实例所共享，因此所有实例共享原型对象的成员。</p><h2 id="2-对象的创建方式"><a href="#2-对象的创建方式" class="headerlink" title="2.对象的创建方式"></a>2.对象的创建方式</h2><p><strong>通过<code>{}</code>来创建对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">location</span>:<span class="string">'天朝'</span>,<span class="attr">hobby</span>:<span class="string">'台球'</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>通过<code>new Object</code>创建对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure><p><strong>通过构造函数创建对象</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.leg = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">this</span>.tail = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">this</span>.bark = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'汪汪'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> hei = <span class="keyword">new</span> Dog();</span><br></pre></td></tr></table></figure><h2 id="3-构造函数"><a href="#3-构造函数" class="headerlink" title="3.构造函数"></a>3.构造函数</h2><p>构造函数就是构造一个对象(一堆属性)的一个规则,造完后就和该对象无关了。</p><p>分析一下上面的构造函数实例化<code>new Dog()</code>的过程</p><ol><li>首先构造了一个空对象</li><li>把this指向该空对象</li><li>开始执行函数(词法分析+语句执行)</li><li>返回该对象</li></ol><p>这里需要注意的是构造函数的返回值  与 普通函数调用的返回值 的不同。<br>普通函数调用时, 如有return,则返回该return值,如果没return,或者 ‘return;’, 则返回值为undefined。<br>对于构造函数创建对象,遇到return返回,依然成立，但返回值，如果是<code>{...}</code>或者new表达式则返回return的值，否则是构造函数的函数体形成的新对象。</p><p>一个栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Pig</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.leg = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">this</span>.hei = <span class="string">'300KG'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// Pig &#123;leg: 4, hei: "300KG"&#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hehe'</span>;  <span class="comment">// Pig &#123;leg: 4, hei: "300KG"&#125;</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="attr">leg</span>:<span class="number">2</span>,<span class="attr">hei</span>:<span class="string">'150KG'</span>&#125;  <span class="comment">// Object &#123;leg: 2, hei: "150KG"&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到两种方式返回的结果并不一样，当return的值为对象是返回的就不是Pig对象，是一个新的Object了。</p><h2 id="4-对象的原型"><a href="#4-对象的原型" class="headerlink" title="4.对象的原型"></a>4.对象的原型</h2><p>对象可以有两种类型的成员：实例成员（也称作“own”成员）和原型成员。实例成员直接存在于实例自身，而原型成员则从对象原型继承。</p><p>对象通过一个内部属性绑定到它的原型，Firefox， Safari，和 Chrome 中开放了该属性，叫做<code>__proto__</code>。</p><p>对象的原型决定了一个实例的类型。默认情况下，所有对象都是 Object 的实例</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">location</span>:<span class="string">'天朝'</span>,<span class="attr">hobby</span>:<span class="string">'台球'</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(obj.__proto__)  <span class="comment">// Object &#123;&#125;</span></span><br></pre></td></tr></table></figure><h2 id="5-实例与原型的关系"><a href="#5-实例与原型的关系" class="headerlink" title="5.实例与原型的关系"></a>5.实例与原型的关系</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat = &#123; <span class="attr">name</span>: <span class="string">"kitty"</span>, <span class="attr">age</span>: <span class="string">"3"</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(cat.toString()); <span class="comment">//"[object Object]"</span></span><br></pre></td></tr></table></figure><p>此代码中， cat 对象有两个实例成员： name 和 age。但它并没有定义 toString()，但是它被调用了，也没有抛出错误。 toString()函数就是一个 cat 对象继承的原型成员。</p><p>处理对象成员的过程与变量处理十分相似。当 cat.toString()被调用时，对成员进行名为“toString”的搜索，首先从对象实例开始，如果 cat 没有名为 toString 的成员，那么就转向搜索原型对象，在那里发现了toString()方法并执行它。通过这种方法， cat 可以访问它的原型所拥有的每个属性或方法。</p><p>确定一个对象是否具有特定名称的实例成员可以使用hasOwnProperty()；确定对象是否具有某个名称的成员，你可以使用操作符 in。接着上面的：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(cat.hasOwnProperty(<span class="string">"name"</span>)); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(cat.hasOwnProperty(<span class="string">"toString"</span>)); <span class="comment">//false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"name"</span> <span class="keyword">in</span> cat); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"toString"</span> <span class="keyword">in</span> cat); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h2 id="6-原型链"><a href="#6-原型链" class="headerlink" title="6.原型链"></a>6.原型链</h2><p>js中没有类的概念, 只有对象的概念。所以一切类型都是一个实例对象，它们继承原型的所有方法。也可以用“构造器（prototype）”创建一个类型的原型。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> kitty = &#123;<span class="attr">color</span>:<span class="string">'yellow'</span>,<span class="attr">bark</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;alert(<span class="string">'喵喵'</span>)&#125;,<span class="attr">climb</span>:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;alert(<span class="string">'我在树上'</span>)&#125;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tiger</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.color = <span class="string">'yellow and black'</span>;</span><br><span class="line">    <span class="keyword">this</span>.bark = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'吼吼'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 给构造函数声明原型, 那么构造出的对象,就会有一个祖先:即该原型</span></span><br><span class="line">Tiger.prototype = kitty;</span><br><span class="line"><span class="keyword">var</span> heihu = <span class="keyword">new</span> Tiger();</span><br><span class="line">heihu.bark(); <span class="comment">// 吼吼</span></span><br><span class="line">heihu.climb(); <span class="comment">// 我在树上</span></span><br><span class="line"><span class="built_in">console</span>.log(heihu.__proto__);  <span class="comment">// Object &#123;color: "yellow", bark: function, climb: function&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(heihu.__proto__.__proto__); <span class="comment">// Object &#123;&#125;</span></span><br></pre></td></tr></table></figure><p>Tiger构造函数用于创建一个heihu实例，heihu 的原型（<code>__proto__</code>） 是 kitty对象， kitty的原型是 Object。这就创建了一个原形链，heihu继承了它们两个的所有成员，当调用heihu.bark()时，由于对象包含该成员，直接返回；当调用heihu.climb()，发现实例对象中没有，就沿着原型链找到kitty，在它的成员中找到，然后返回。</p><p>和作用域链类似，当调用对象成员时，深入原形链越深，搜索的速度就会越慢。虽然使用优化 JavaScript引擎的现代浏览器表现良好，但是老的浏览器，特别是 IE，每深入原形链一层都会增加性能损失。因此要减少原型链的遍历深度和次数。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript数据访问对性能的影响</title>
      <link href="/2015/01/17/tech/high_perf_js/data_access.html"/>
      <url>/2015/01/17/tech/high_perf_js/data_access.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>在 <a href="/2015/01/16/scope_chains.html" title="JavaScript作用域链分析">JavaScript作用域链分析</a> 中介绍了函数的作用域链。在函数运行后，会生成激活对象,每遇到一个变量，js都要根据作用域链来决定从哪里获得和存储数据。</p><p>此过程搜索运行函数的作用域链,搜索工作从运行函数的激活目标之作用域链的前端开始，如果找到了,那么就使用这个变量;如果没找到,搜索工作将进入作用域链的下一个对象。此过程持续运行,直到变量被找到,或者没有更多对象可用于搜索,这种情况下标识符将被认为是未定义的。</p><p>而这种搜索过程影响了 JavaScript 的运行性能。</p><h2 id="2-全局变量和局部变量分析"><a href="#2-全局变量和局部变量分析" class="headerlink" title="2.全局变量和局部变量分析"></a>2.全局变量和局部变量分析</h2><p>在一个函数运行的作用域链上，一个变量所处的位置愈深，它的读写速度就愈慢。因此，局部变量的访问速度是最快的，而全局变量的访问通常是最慢的。</p><p>可以看一下比较结果</p><p>代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> global = <span class="string">'hello'</span>    </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse_part</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> part = <span class="string">'hello'</span></span><br><span class="line">part += <span class="string">' world'</span></span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parse_global</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">global += <span class="string">' world'</span></span><br><span class="line">&#125;</span><br><span class="line">b()</span><br><span class="line">&#125;</span><br><span class="line">a()</span><br><span class="line">&#125;</span><br><span class="line">Test.run( <span class="string">'局部变量'</span> ); </span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">9999</span>; i++ ) &#123;</span><br><span class="line">parse_part()</span><br><span class="line">&#125;</span><br><span class="line">Test.stop(); </span><br><span class="line">Test.run( <span class="string">'全局变量'</span> ); </span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">9999</span>; i++ ) &#123;</span><br><span class="line">parse_global()</span><br><span class="line">&#125;</span><br><span class="line">Test.stop(); </span><br><span class="line">Test.output( <span class="string">'js局部变量和全局变量性能比较'</span> );</span><br></pre></td></tr></table></figure><p>运行结果</p><p>IE8下</p><p><img src="/images/20150118003219.jpg" alt="ie下比较结果" title="ie下比较结果"></p><p>chrome39下</p><p><img src="/images/005.jpeg" alt="chrome下比较结果" title="chrome下比较结果"></p><p>在IE下运行多次基本上都是局部变量的速度快。而在Chrome下多次运行，两者的速度相差无几，而且速度快了两个数量级，这是由于Chrome优化js引擎的结果。</p><p>一般来说，对于浏览器，变量所处位置愈深，它的速度就愈慢。而在现代浏览器中，由于JavaScript引擎被优化，这种性能损失几乎就没有了。但是在那些没有优化过的浏览器里（IE），依然要注意这一点。</p><p>通过以上信息,在没有优化 JavaScript 引擎的浏览器中,最好尽可能使用局部变量。一个好的经验法则是:用局部变量存储本地范围之外的变量值。</p><p>下面举个栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initUI</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bd = <span class="built_in">document</span>.body,</span><br><span class="line">        links = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"a"</span>),</span><br><span class="line">        i = <span class="number">0</span>,</span><br><span class="line">        len = links.length;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; len)&#123;</span><br><span class="line">        update(links[i++]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"go-btn"</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        start();</span><br><span class="line">    &#125;;</span><br><span class="line">    bd.className = <span class="string">"active"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数包含三个对 document 的引用,document 是一个全局对象。搜索此变量,必须遍历整个作用域链,直到最后在全局变量 window 对象中找到它。我们可以将document这个全局变量的引用存储在一个局部变量里，在下面的代码中使用这个全局变量：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initUI</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> doc = <span class="built_in">document</span>,</span><br><span class="line">        bd = doc.body,</span><br><span class="line">        links = doc.getElementsByTagName(<span class="string">"a"</span>),</span><br><span class="line">        i = <span class="number">0</span>,</span><br><span class="line">        len = links.length;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; len)&#123;</span><br><span class="line">        update(links[i++]);</span><br><span class="line">    &#125;</span><br><span class="line">    doc.getElementById(<span class="string">"go-btn"</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        start();</span><br><span class="line">    &#125;;</span><br><span class="line">    bd.className = <span class="string">"active"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在访问全局变量的次数是 1 次,而不是 3 次。用 doc 替代 document 更快,因为它是一个局部变量。通过这个简单的函数，我们可以发现，当变量的数量增加时，性能会的到明显的提升。</p><h2 id="3-闭包中变量分析"><a href="#3-闭包中变量分析" class="headerlink" title="3.闭包中变量分析"></a>3.闭包中变量分析</h2><p>闭包允许函数访问局部范围之外的数据。举一个栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        n+=<span class="number">1</span>;</span><br><span class="line">        alert(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result=f1();</span><br><span class="line">result(); <span class="comment">// 999</span></span><br><span class="line">result(); <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure><p>可以看到，函数f1的激活对象是函数f2和变量n，当函数f2运行时，变量n读取的是f1的激活对象里面的n变量。这是闭包的一个性能关注点，当经常访问函数范围之外的变量时，每次访问都会导致一些性能损失。</p><p>根据上文中对局部变量和全局变量的分析，可以将范围之外的变量存入局部变量中，然后直接访问局部变量即可。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>JavaScript 中变量的访问是按照作用域链的规定来搜索的，在该过程中会造成性能损失。在未优化的浏览器（PS:特别是IE）中需要特别关注这一点。在局部变量、范围外变量和全局变量中读取中，可以尽量将之存入局部变量中，使用局部变量访问。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript作用域链分析</title>
      <link href="/2015/01/16/tech/high_perf_js/scope_chains.html"/>
      <url>/2015/01/16/tech/high_perf_js/scope_chains.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>作用域概念是理解 JavaScript 的关键，不仅从性能的角度，而且从功能的角度。作用域对 JavaScript 有许多影响，从确定哪些变量可以被函数访问，到确定 this 的值。</p><h2 id="2-变量"><a href="#2-变量" class="headerlink" title="2.变量"></a>2.变量</h2><p>在 JavaScript 里,对象/函数都是变量。window对象是全局对象，全局变量是全局对象的属性。每个变量内部又有自己的变量，就是局部变量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">22</span>; <span class="comment">// 全局变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">88</span>; <span class="comment">// 局部变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个变量都有自己的作用域，上面，<code>num</code>变量它的作用域为函数t，在t函数内部可以获取他，在函数外部则不行。基本上大多数的编程语言都遵循这种规律，然而JavaScript却有一个独特的地方，就是在变量内部可以访问到外部的变量。</p><p>以函数为例，在运行函数时，函数收到它运行时的环境影响，不同的外部环境可能产生的结果会不一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">22</span>;</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">99</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">88</span>;</span><br><span class="line">    <span class="keyword">var</span> str= <span class="string">'hello'</span>;</span><br><span class="line">    alert(age); <span class="comment">// 22</span></span><br><span class="line">    alert(str); <span class="comment">// hello</span></span><br><span class="line">    alert(num); <span class="comment">// 88</span></span><br><span class="line">&#125;</span><br><span class="line">t();</span><br></pre></td></tr></table></figure><p>来分析一下上面的例子，首先定义了全局变量age、num和函数t。在函数t中定义的局部变量num和str。<br>执行函数t时，局部变量里面没有age变量，于是就去函数t的外部去寻找，找到全局变量age，返回22；<br>局部变量里面有str和num变量，于是直接返回hello和88，不继续向外部寻找。</p><p><img src="/images/20150116124731.jpg" alt="作用域分析" title="作用域分析"></p><h2 id="3-词法分析"><a href="#3-词法分析" class="headerlink" title="3.词法分析"></a>3.词法分析</h2><p>一个栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'global'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(str); <span class="comment">// undefined</span></span><br><span class="line">    <span class="keyword">var</span> str = <span class="string">'local'</span>;</span><br><span class="line">    alert(str); <span class="comment">// local</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">t();</span><br></pre></td></tr></table></figure><p>产生上述结果的原因是JavaScript并不是一句一句顺序执行的，先进行词法分析(预编译)。当函数运行时，它的作用域链被初始化，创建一个激活对象（Activation Object），以下简称AO。此激活对象作为函数执行期的一个可变对象，包含访问所有局部变量，命名参数，参数集合，和 this的接口。</p><p><strong>js的执行顺序</strong>  </p><p><em>词法分析阶段</em></p><ol><li>分析参数</li><li>分析变量声明</li><li>分析函数声明</li></ol><p>说明：<br>　1.先把接收到的参数放到AO上<br>　2.分析变量声明<br>　　a: var xx = yy;<br>　　做法:先分析var xx，声明一个xx属性在AO上，xx变量此时,没有赋值,值是undefined，但如果已经有xx,则不对xx操作。<br>　　b:function t() {}<br>　　做法:直接声明t属性，且内容是函数体  </p><p><em>执行语句阶段</em></p><p>举个栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">t</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">    alert(age);  <span class="comment">// 99</span></span><br><span class="line">    <span class="keyword">var</span> age = <span class="number">12</span>;</span><br><span class="line">    alert(age);  <span class="comment">// 12</span></span><br><span class="line">&#125;</span><br><span class="line">t(<span class="number">99</span>);</span><br></pre></td></tr></table></figure><p>分析一下：</p><ol><li>执行t函数，产生t的AO ==&gt; t:AO:{}</li><li>词法分析形参得到     ==&gt; t:AO:{age:undefined} </li><li>实参赋值 age属性     ==&gt; t:AO:{age:99}         </li><li>修改age的值          ==&gt; t:AO:{age:12}         </li></ol><p>继续举个大栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">b</span>) </span>&#123;</span><br><span class="line">    alert(b);  <span class="comment">// function b()&#123;&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">b</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert (b); <span class="comment">// function b()&#123;&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    b();</span><br><span class="line">&#125;</span><br><span class="line">a(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>分析一下：</p><ol><li>执行a函数，产生a的AO ==&gt; a:AO:{}</li><li>词法分析形参得到           ==&gt; a:AO:{b:undefined}   </li><li>实参赋值 b属性             ==&gt; a:AO:{b:1}</li><li>函数声明 b属性             ==&gt; a:AO:{b:function}</li><li>执行b函数，产生b的AO ==&gt; b:AO:{}</li><li>由于在b的AO中没有b属性，向b函数外部寻找到a的AO，找到b属性，为function。AO.b —&gt;{}—&gt;a:AO</li></ol><p>有上面的例子可以看出，函数的作用域是和外部环境有着密切的关联，是一级一级通过激活对象向外部关联，一直到window对象为止，这样就形成了函数的作用域链。</p><h2 id="4-闭包"><a href="#4-闭包" class="headerlink" title="4.闭包"></a>4.闭包</h2><p>闭包是 JavaScript 最强大的一个方面,它允许函数访问局部范围之外的数据。理解起来比较抽象，可以说闭包就是能够读取其他函数内部变量的函数，由于在JavaScript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。</p><p>闭包最明显的特点，一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p><p>同样的举一个栗子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">var</span> n=<span class="number">999</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">n+=<span class="number">1</span>;</span><br><span class="line">alert(n);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> f2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result=f1();</span><br><span class="line">result(); <span class="comment">// 999</span></span><br><span class="line">result(); <span class="comment">// 1000</span></span><br></pre></td></tr></table></figure><p>上面f2就是一个闭包，运行了2次。通过两次的结果可以发现，f1函数内部的变量ｎ并没有随着第一次运行结束而销毁，而是一直存在于内存中。</p><p>分析上述代码，当f1函数被执行，生成一个激活对象，里面包含了函数f2和变量ｎ，而f2被返回并将它的引用给了全局变量result。由于全局变量result一直存在，所以f2也一直存在，f1和它内部的激活对象也一直存在，没有被销毁。从这里可以发现：</p><p><strong>当函数f1的内部函数f2被函数f1外的一个变量result引用的时候，就创建了一个闭包。</strong></p><p>通常,一个函数的激活对象在函数运行完会销毁。当涉及闭包时,激活对象就无法销毁了,因为引用仍然存在着。这意味着脚本中的闭包与非闭包函数相比,需要更多内存开销。所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p>JavaScript并不是一句一句顺序执行的，会先进行词法分析，产出激活对象。在js执行时，变量的访问会沿着激活对象向外部延伸从而产生一条作用域链。当作用域链被销毁时，激活对象也一同销毁。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《高性能JavaScript》读书笔记</title>
      <link href="/2015/01/15/tech/high_perf_js/index.html"/>
      <url>/2015/01/15/tech/high_perf_js/index.html</url>
      
        <content type="html"><![CDATA[<p>最近读了《高性能JavaScript》一书，感觉受益良多。发现以前书写js代码方面有着许多的误区和不足，对js的理解还不够深刻，特此记录下阅读该书的笔记和心得，望于各位共同进步。</p><ol><li><a href="loading_and_execution.html">JavaScript脚本在HTML页面中的加载和运行情况</a></li><li><a href="scope_chains.html">JavaScript作用域链分析</a></li><li><a href="data_access.html">JavaScript数据访问对性能的影响</a></li><li><a href="prototype_chains.html">JavaScript原型链分析</a></li><li><a href="nested_members.html">JavaScript对象的嵌套成员对性能的影响</a></li><li><a href="dom_scripting.html">JavaScript在访问和操作DOM对象的注意点</a></li><li><a href="event_delegation.html">JavaScript采用事件托管提高事件处理的效率</a></li><li><a href="algorithms_and_flow_control.html">JavaScript流程控制对性能的影响</a></li><li><a href="regular_expression_optimization.html">JavaScript中正则表达式的工作原理和优化</a></li></ol><p><strong>未完待续…</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript脚本在HTML页面中的加载和运行情况</title>
      <link href="/2015/01/15/tech/high_perf_js/loading_and_execution.html"/>
      <url>/2015/01/15/tech/high_perf_js/loading_and_execution.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1.前言"></a>1.前言</h2><p>HTML页面的加载速度与JavaScript的阻塞特性有着密切的关系，当JavaScript运行时其他的事情不能被浏览器处理，浏览器需要空闲下来等待JavaScript运行结束。</p><p><code>&lt;script&gt;</code>标签的出现使整个页面因脚本解析、运行而出现等待。不论实际的JavaScript 代码是内联的还是包含在一个不相干的外部文件中，页面下载和解析过程必须停下，等待脚本完成这些处理，然后才能继续。这是页面生命周期必不可少的部分，因为脚本可能在运行过程中修改页面内容。</p><h2 id="2-脚本位置"><a href="#2-脚本位置" class="headerlink" title="2.脚本位置"></a>2.脚本位置</h2><p>众所周知，一个<code>&lt;script&gt;</code>标签可以放在HTML文档的<code>&lt;head&gt;</code>或<code>&lt;body&gt;</code>标签中，并且可以多次出现。而脚本放置的位置对页面的加载速度有着重要的影响。</p><p>首先看一个例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://libs.baidu.com/jquery/1.9.0/jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://libs.baidu.com/bootstrap/3.0.3/js/bootstrap.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://libs.baidu.com/highcharts/2.2.5/highcharts.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.baidu.com/img/bdlogo.png"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello,World~~<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>页面运行情况（IE8）</p><p><img src="/images/20150115191022.jpg" alt="页面运行情况" title="页面运行情况"></p><p>上图中，可以看出JavaScript文件阻塞了其他文件（图片）的下载过程。</p><p>当然，这是IE8下面的情况。在大多数现代浏览器中已经支持并行下载，不会出现这样的延时情况了，如Chrome、FireFox和Opera等，我们会看到有多个文件同时下载，并没有延时的情况。</p><p>但是为了适应各浏览器的情况（PS:IE），防止脚本阻塞其他页面资源的下载过程， 所以推荐的办法是： 将所有<code>&lt;script&gt;</code>标签放在尽可能接近<code>&lt;body&gt;</code>标签底部的位置，尽量减少对整个页面下载的影响。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>Hello,World~~<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"http://www.baidu.com/img/bdlogo.png"</span> <span class="attr">alt</span>=<span class="string">""</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://libs.baidu.com/jquery/1.9.0/jquery.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://libs.baidu.com/bootstrap/3.0.3/js/bootstrap.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://libs.baidu.com/highcharts/2.2.5/highcharts.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>页面运行情况（IE8）</p><p><img src="/images/20150116100430.jpg" alt="页面运行情况" title="页面运行情况"></p><h2 id="3-脚本数量"><a href="#3-脚本数量" class="headerlink" title="3.脚本数量"></a>3.脚本数量</h2><p>减少页面的<code>&lt;script&gt;</code>的总数也可以改善页面的加载速度。每当页面解析碰到一个<code>&lt;script&gt;</code>标签时，紧接着有一段时间用于代码执行。最小化这些延迟时间可以改善页面的整体性能。</p><p>每个 HTTP 请求都会产生额外的性能负担，下载一个 100KB 的文件比下载四个 25KB 的文件要快。总之，减少引用外部脚本文件的数量。例如，可以讲一个网页的多个JavaScript文件整合成一个文件，这样就只需一个<code>&lt;script&gt;</code>标签，可以提升性能。</p><h2 id="4-非阻塞脚本"><a href="#4-非阻塞脚本" class="headerlink" title="4.非阻塞脚本"></a>4.非阻塞脚本</h2><p>保持 JavaScript 文件短小，并限制 HTTP 请求的数量，只是创建反应迅速的网页应用的第一步。一个应用程序所包含的功能越多，所需要的 JavaScript 代码就越大，保持源码短小并不总是一种选择。尽管下载一个大 JavaScript 文件只产生一次 HTTP 请求，却会锁定浏览器一大段时间。</p><p>非阻塞脚本的秘密在于，等页面完成加载之后，再加载 JavaScript 源码。从技术角度讲，这意味着在window 的 load 事件发出之后开始下载代码。有几种方法可以实现这种效果。</p><h3 id="4-1-动态脚本元素"><a href="#4-1-动态脚本元素" class="headerlink" title="4.1 动态脚本元素"></a>4.1 动态脚本元素</h3><p>DOM允许你使用 JavaScript 动态创建 HTML 的几乎全部文档内容，而<code>&lt;script&gt;</code>元素与页面其他元素没有什么不同。一个新的<code>&lt;script&gt;</code>元素可以非常容易地通过标准 DOM 函数创建：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement (<span class="string">"script"</span>);</span><br><span class="line">script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">script.src = <span class="string">"file1.js"</span>;</span><br><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(script);</span><br></pre></td></tr></table></figure><p>新的<code>&lt;script&gt;</code>元素加载 file1.js 源文件。此文件当元素添加到页面之后立刻开始下载。此技术的重点在于：无论在何处启动下载，文件的下载和运行都不会阻塞其他页面处理过程。你甚至可以将这些代码放在<code>&lt;head&gt;</code>部分而不会对其余部分的页面代码造成影响。</p><p>当动态加载的脚步文件中需要调用页面其他脚本里面的内容是，就需要跟踪脚本下载完成并准备妥善。</p><p>需要注意的是，除了Firefox和Opera，其他浏览器并不保证脚本文件的加载顺序，因此，可以将下载操作串连一起来保证加载顺序，例如：</p><p>Firefox, Opera, Chorme 和 Safari 3+会在<code>&lt;script&gt;</code>节点接收完成之后发出一个 load 事件。你可以监听这一事件，以得到脚本准备好的通知。</p><p>而IE 支持另一种实现方式， 它发出一个 readystatechange 事件。 <code>&lt;script&gt;</code>元素有一个 readyState属性，它的值随着下载外部文件的过程而改变。 readyState 有五种取值：</p><p>“uninitialized”默认状态<br>“loading”下载开始<br>“loaded”下载完成<br>“interactive”下载完成但尚不可用<br>“complete”所有数据已经准备好  </p><p>在实际应用中，最常用到的就是“loaded”和“complete”状态，IE对这两个状态的解析并不准确，不能确保哪一个一定能够获取，因此，最保险的就是两个状态都监视，当有一个状态出现时，就删除 readystatechange 事件句柄（保证事件不会被处理两次）。</p><p>下面的函数封装了标准实现和 IE 实现所需的功能：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadScript</span>(<span class="params">url, callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement (<span class="string">"script"</span>)</span><br><span class="line">    script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">    <span class="keyword">if</span> (script.readyState)&#123; <span class="comment">//IE</span></span><br><span class="line">        script.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (script.readyState == <span class="string">"loaded"</span> || script.readyState == <span class="string">"complete"</span>)&#123;</span><br><span class="line">            script.onreadystatechange = <span class="literal">null</span>;</span><br><span class="line">            callback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//Others</span></span><br><span class="line">        script.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            callback();</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    script.src = url;</span><br><span class="line">    <span class="built_in">document</span>.getElementsByTagName(<span class="string">"head"</span>)[<span class="number">0</span>].appendChild(script);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">loadScript(<span class="string">"file1.js"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"File is loaded!"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>需要注意的是，除了Firefox和Opera，其他浏览器并不保证脚本文件的加载顺序，因此，可以讲下载操作串连一起来保证加载顺序，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">loadScript(<span class="string">"file1.js"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    loadScript(<span class="string">"file2.js"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        loadScript(<span class="string">"file3.js"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            alert(<span class="string">"All files are loaded!"</span>);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果多个文件的次序十分重要，更好的办法是将这些文件按照正确的次序连接成一个文件。独立文件可以一次性下载所有代码（由于这是异步进行的，使用一个大文件并没有什么损失）。</p><h3 id="4-2-XHR-脚本注入"><a href="#4-2-XHR-脚本注入" class="headerlink" title="4.2 XHR 脚本注入"></a>4.2 XHR 脚本注入</h3><p>另一个以非阻塞方式获得脚本的方法是使用 XMLHttpRequest(XHR)对象将脚本注入到页面中。此技术首先创建一个 XHR 对象，然后下载 JavaScript 文件，接着用一个动态<code>&lt;script&gt;</code>元素将 JavaScript 代码注入页面。例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.open(<span class="string">"get"</span>, <span class="string">"file1.js"</span>, <span class="literal">true</span>);</span><br><span class="line">xhr.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span> || xhr.status == <span class="number">304</span>)&#123;</span><br><span class="line">            <span class="keyword">var</span> script = <span class="built_in">document</span>.createElement (<span class="string">"script"</span>);</span><br><span class="line">            script.type = <span class="string">"text/javascript"</span>;</span><br><span class="line">            script.text = xhr.responseText;</span><br><span class="line">            <span class="built_in">document</span>.body.appendChild(script);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure><p>这样做会创建一个带有内联代码的<code>&lt;script&gt;</code>元素。一旦新<code>&lt;script&gt;</code>元素被添加到文档，代码将被执行，并准备使用。</p><p>此方法最主要的限制是： JavaScript 文件必须与页面放置在同一个域内，不能从 CDN 下载，因此大型网页通常不采用 XHR 脚本注入技术。</p><h3 id="4-3-推荐的非阻塞模式"><a href="#4-3-推荐的非阻塞模式" class="headerlink" title="4.3 推荐的非阻塞模式"></a>4.3 推荐的非阻塞模式</h3><p>推荐的向页面加载大量 JavaScript 的方法：</p><p>第一种是先加载一个js文件，里面就只包含了动态加载脚本所需的代码：<code>loadScript函数</code>。然后用调用它来加载页面其他元素。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"loader.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    loadScript(<span class="string">"the-rest.js"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line">        Application.init();</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>第二种与第一种类似，只是将<code>loadScript函数</code>嵌入在页面中，这可以避免另一次 HTTP 请求。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span><br><span class="line"><span class="actionscript">    <span class="function"><span class="keyword">function</span> <span class="title">loadScript</span><span class="params">(url, callback)</span></span>&#123;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 函数内容</span></span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="actionscript">    loadScript(<span class="string">"the-rest.js"</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span></span><br><span class="line">        Application.init();</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>页面运行情况（IE8）<br><img src="/images/20150116101240.jpg" alt="页面运行情况" title="页面运行情况"></p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h2><p><code>&lt;script&gt;</code>元素会阻塞页面的加载，有几种方法可以减少 JavaScript 对性能的影响：</p><ul><li>将<code>&lt;script&gt;</code>标签放置在页面的底部，紧靠<code>&lt;/body&gt;</code>标签的上方。</li><li>将脚本成组打包，减少页面<code>&lt;script&gt;</code>标签的数量，不论外部脚本文件还是内联代码都是如此。</li><li>非阻塞方式下载 JavaScript：1、动态创建<code>&lt;script&gt;</code>元素，用它下载并执行代码；2、用 XHR 对象下载代码，并注入到页面中</li></ul><p><strong>这里需要注意的是。我们发现非阻塞方式后，总共的时间比将js一起放在尾部所花的时间要长，这是由于IE8+的浏览器支持 JavaScript 脚本并行下载。因此，如果使用的是IE8+、Chrome2+和FireFox3.5+等现代浏览器，不推荐使用非阻塞的方式，只需采用其他两种方式优化即可。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GOOGLE搜索从入门到精通</title>
      <link href="/2014/11/18/life/google-search-wiki.html"/>
      <url>/2014/11/18/life/google-search-wiki.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>众所周知谷歌是一个很强大的搜索引擎，但会使用它的技巧的人却不多（俺就是其中一个），在一个偶然的机会中看到了一篇关于谷歌搜索技巧的文章。因被天朝防火墙河蟹，查看不便，于是就转载到这里。希望能够于大家分享。</p><p>原文地址（需科学上网） <a href="http://fanqianghou.com/2013/11/17/google/" target="_blank" rel="noopener">http://fanqianghou.com/2013/11/17/google/</a></p><p>鉴于谷歌在天朝已经被河蟹，但是还有镜像可以访问，与大家分享： <a href="https://github.com/greatfire/wiki" target="_blank" rel="noopener" title="谷歌搜索镜像">谷歌搜索镜像</a></p><p>当然最好还是会<code>科学上网</code>啦(*^__^*)</p><h2 id="2-摘要"><a href="#2-摘要" class="headerlink" title="2. 摘要"></a>2. 摘要</h2><p>本文简要的介绍了Google的历史和特点，Google的基本搜索语法和高级搜索语法，Google的特色功能，包括图片搜索、新闻组搜索和集成工具条等。尽管本文名为“Google搜索从入门到精通”，但事实上，本文只能算是对Google的一个并不十分完全的介绍而已。</p><h2 id="3-如何使用本文"><a href="#3-如何使用本文" class="headerlink" title="3. 如何使用本文"></a>3. 如何使用本文</h2><p>阅读本文最好具备一些最基本的布林代数基础，如“与”、“或”、“非”等。不过，即便你没有这方面的知识，也不必在意。对那些实例进行练习，你的疑惑就会迎刃而解。对于刚刚接触网络搜索的读者而言，也许你应该从头到尾的阅读本文；但对于那些有一定搜索基础的读者而言，只需要跳跃著寻找自己所需要的资讯就可以了。此外，你也可以参考中文Google大全：<a href="http://www.Google.com/intl/zh-CN/about.html" target="_blank" rel="noopener">http://www.Google.com/intl/zh-CN/about.html</a>，以及搜索帮助：<a href="http://www.Google.com/intl/zh-CN/help.html" target="_blank" rel="noopener">http://www.Google.com/intl/zh-CN/help.html</a>，那是官方Google使用手册以及问题解答中心。</p><h2 id="4-Google简介"><a href="#4-Google简介" class="headerlink" title="4. Google简介"></a>4. Google简介</h2><p>Google（<a href="www.google.com">www.Google.com</a>）是一个搜索引擎，由两个斯坦福大学博士生Larry Page与Sergey Brin于1998年9月发明，Google Inc. 于1999年创立。2000年7月份，Google替代Inktomi成为Yahoo公司的搜索引擎，同年9月份，Google成为中国网易公司的搜索引擎。98年至今，Google已经获得30多项业界大奖。到Google的新闻中心（<a href="http://www.Google.com/press/index.html" target="_blank" rel="noopener">http://www.Google.com/press/index.html</a>），你可以找到关于一切关于Google的历史和新闻资料。</p><p>Google的成功得益于其强大的功能和独到的特点：</p><ul><li>Google检索网页数量达24亿，搜索引擎中排名第一；</li><li>Google支援多达132种语言，包括简体中文和繁体中文；</li><li>Google网站只提供搜索引擎功能，没有花里胡哨的累赘；</li><li>Google速度极快，年初时据说有15000多台伺服器，200多条T3级宽频；</li><li>Google的专利网页级别技术PageRank能够提供准确率极高的搜索结果； </li><li>Google智慧化的“手气不错”功能，提供可能最符合要求的网站；</li><li>Google的“网页快照”功能，能从Google伺服器里直接取出缓存的网页。</li><li>Google具有独到的图片搜索功能；</li><li>Google具有强大的新闻组搜索功能；</li><li>Google具有二进位档搜索功能（PDF，DOC，SWF等）；</li><li>Google还有很多尚在开发阶段的令人吃惊的设想和功能。</li><li>等等</li></ul><h2 id="5-搜索入门"><a href="#5-搜索入门" class="headerlink" title="5. 搜索入门"></a>5. 搜索入门</h2><p>要用Google做搜索，当然首先要进Google网站–<a href="http://www.Google.com；不过，163.com和yahoo.com.cn使用的实际上也是Google搜索引擎，只是对搜索结果进行了编排，而且无法提供一些特色功能，如图片搜索等。因此，如果你要搜索网页的话，就直接使用Google.com吧。" target="_blank" rel="noopener">www.Google.com；不过，163.com和yahoo.com.cn使用的实际上也是Google搜索引擎，只是对搜索结果进行了编排，而且无法提供一些特色功能，如图片搜索等。因此，如果你要搜索网页的话，就直接使用Google.com吧。</a></p><p>第一次进入Google，它会根据你的作业系统，确定语言介面。需要提醒的是，Google是通过cookie来存储页面设定的，所以，如果你的系统禁用cookie，就无法对Google介面进行个人设定了。</p><p>Google的首页很清爽，LOGO下面，排列了四大功能模组：网站、图像、新闻组和目录服务。默认是网站搜索。现在进行第一次搜索实践，假定你是个搜索新手，想要了解一下搜索引擎的来龙去脉和搜索技巧。在搜索框内输入一个关键字“搜索引擎”， 选中“搜索中文(简体)网页”选项，然后点击下面的“Google搜索”按钮（或者直接回车），结果就出来了。 搜索：“搜索引擎”<br>结果：已搜索有关搜索引擎的中文(简体)网页。 共约有707,000项查询结果，这是第1-10项 。 搜索用时0.08秒。</p><p>仔细看一下搜索结果的前十项，就会发现绝大部分链结是搜索引擎本身，而不是对搜索引擎的或者搜索技巧方面的介绍。</p><p>注意：文章中搜索语法外面的引号仅起引用作用，不能带入搜索栏内。</p><h2 id="6-初阶搜索"><a href="#6-初阶搜索" class="headerlink" title="6. 初阶搜索"></a>6. 初阶搜索</h2><p>上例是最基本的搜索，即查询包含单个关键字的资讯。但是，你可以发现，上例中，单个关键字“搜索引擎”，搜索得的资讯浩如烟海，而且绝大部分并不符合自己的要求，怎么办呢？我们需要进一步缩小搜索范围和结果。</p><h3 id="6-1-搜索结果要求包含两个及两个以上关键字"><a href="#6-1-搜索结果要求包含两个及两个以上关键字" class="headerlink" title="6.1. 搜索结果要求包含两个及两个以上关键字"></a>6.1. 搜索结果要求包含两个及两个以上关键字</h3><p>一般搜索引擎需要在多个关键字之间加上“ ”，而Google无需用明文的“ ”来表示逻辑“与”操作，只要空格就可以了。现在，我们需要了解一下搜索引擎的历史，因此期望搜得的网页上有“搜索引擎”和“历史”两个关键字。</p><p>示例：搜索所有包含关键字“搜索引擎”和“历史”的中文网页<br>搜索：“搜索引擎 历史”<br>结果：已搜索有关搜索引擎 历史的中文(简体)网页。 共约有78,600项查询结果，这是第1-10项 。 搜索用时0.36秒。</p><p>用了两个关键字，查询结果已经从70多万项减少到7万多项。但查看一下搜索结果，发现前列的绝大部分结果还是不符合要求，大部分网页涉及的“历史”，并不是我们所需要的“搜索引擎的历史”。 怎么办呢？删除与搜索引擎不相关的“历史”。我们发现，这部分无用的资讯，总是和“文化”这个词相关的，另外一些常见词是“中国历史”、“世界历史”、“历史书籍”等。</p><h3 id="6-2-搜索结果要求不包含某些特定资讯"><a href="#6-2-搜索结果要求不包含某些特定资讯" class="headerlink" title="6.2. 搜索结果要求不包含某些特定资讯"></a>6.2. 搜索结果要求不包含某些特定资讯</h3><p>Google用减号“-”表示逻辑“非”操作。“A –B”表示搜索包含A但没有B的网页。</p><p>示例：搜索所有包含“搜索引擎”和“历史”但不含“文化”、“中国历史”和“世界历史”的中文网页<br>搜索：“搜索引擎 历史 -文化 -中国历史 -世界历史”<br>结果：已搜索有关搜索引擎 历史 -文化 -中国历史 -世界历史的中文(简体)网页。 共约有36,800项查询结果，这是第1-10项 。 搜索用时0.22秒。</p><p>我们看到，通过去掉不相关资讯，搜索结果又减少了将近一半。第一个搜索结果是：</p><p>搜索引擎直通车≡搜索引擎发展历史<br>搜索引擎直通车, … 搜索引擎专业介绍站点. …<br><a href="http://www.se-express.com/about/about.htm" target="_blank" rel="noopener">http://www.se-express.com/about/about.htm</a> – 14k – 网页快照 - 类似网页</p><p>非常符合搜索要求。另外，第八项搜索结果：</p><p>463搜索王<br>本站检索 整个网站 在此输入关键字. 你的当前<br>位置：首页 &gt;&gt; Internet搜索手册 &gt;&gt; 搜索引擎的历史. …<br><a href="http://www.cnco.net/search/history.htm" target="_blank" rel="noopener">http://www.cnco.net/search/history.htm</a> – 21k – 网页快照 - 类似网页</p><p>也符合搜索要求。但是，10个结果只有两个符合要求，未免太少了点。不过，在没有更好的策略之前，不妨先点开一个结果看看。点开se-express.com的这个名为“搜索引擎发展历史”的网页，我们发现，搜索引擎的历史，是与互联网早期的档检索工具“Archie”息息相关的。此外，搜索引擎似乎有个核心程式，叫“蜘蛛”，而最早成型的搜索引擎是“Lycos”，使搜索引擎深入人心的是“Yahoo”。了解了这些资讯，我们就可以进一步的让搜索结果符合要求了。</p><p>注意：这里的“ ”和“-”号，是英文字元，而不是中文字元的“＋”和“－”。此外，操作符与作用的关键字之间，不能有空格。比如“搜索引擎 - 文化”，搜索引擎将视为关键字为“搜索引擎”和“文化”的逻辑“与”操作，中间的“-”被忽略。</p><h3 id="6-3-搜索结果至少包含多个关键字中的任意一个"><a href="#6-3-搜索结果至少包含多个关键字中的任意一个" class="headerlink" title="6.3. 搜索结果至少包含多个关键字中的任意一个"></a>6.3. 搜索结果至少包含多个关键字中的任意一个</h3><p>Google用大写的“OR”表示逻辑“或”操作。搜索“A OR B”，意思就是说，搜索的网页中，要么有A，要么有B，要么同时有A和B。在上例中，我们希望搜索结果中最好含有“archie”、“lycos”、“蜘蛛”等关键字中的一个或者几个，这样可以进一步的精简搜索结果。</p><p>示例：搜索如下网页，要求必须含有“搜索引擎”和“历史”，没有“文化”，可以含有以下关键字中人任何一个或者多个：“Archie”、“蜘蛛”、“Lycos”、“Yahoo”。<br>搜索：“搜索引擎 历史 archie OR 蜘蛛 OR lycos OR yahoo -文化”<br>结果：已搜索有关搜索引擎 历史 archie OR 蜘蛛 OR lycos OR yahoo -文化的中文(简体)网页。共约有8,400项查询结果，这是第1-10项 。 搜索用时0.16秒。</p><p>我们看到，搜索结果缩小到8千多项，前20项结果中，大部分都符合搜索要求。如果你想了解一下解搜索引擎的历史发展，就不妨研究一下现在搜索到的结果吧。 注意：“与”操作必须用大写的“OR”，而不是小写的“or”。</p><p>在上面的例子中，我介绍了搜索引擎最基本的语法“与”“非”和“或”，这三种搜索语法Google分别用“ ”（空格）、“-”和“OR”表示。顺着上例的思路，你也可以了解到如何缩小搜索范围，迅速找到目的资讯的一般方法：目标资讯一定含有的关键字（用“ ”连起来），目标资讯不能含有的关键字（用“-”去掉），目标资讯可能含有的关键字（用“OR”连起来）。</p><h2 id="7-杂项语法"><a href="#7-杂项语法" class="headerlink" title="7. 杂项语法"></a>7. 杂项语法</h2><h3 id="7-1-通配符问题"><a href="#7-1-通配符问题" class="headerlink" title="7.1. 通配符问题"></a>7.1. 通配符问题</h3><p>很多搜索引擎支持通配符号，如“*”代表一连串字元，“?”代表单个字元等。Google对通配符支持有限。它目前只可以用“*”来替代单个字元，而且包含“*”必须用“”引起来。比如，““以*治国“”，表示搜索第一个为“以”，末两个为“治国”的四字短语，中间的“*”可以为任何字元。</p><h3 id="7-2-关键字的字母大小写"><a href="#7-2-关键字的字母大小写" class="headerlink" title="7.2. 关键字的字母大小写"></a>7.2. 关键字的字母大小写</h3><p>Google对英文字元大小写不敏感，“GOD”和“god”搜索的结果是一样的。</p><h3 id="7-3-搜索整个短语或者句子"><a href="#7-3-搜索整个短语或者句子" class="headerlink" title="7.3. 搜索整个短语或者句子"></a>7.3. 搜索整个短语或者句子</h3><p>Google的关键字可以是单词（中间没有空格），也可以是短语（中间有空格）。但是，用短语做关键字，必须加英文引号，否则空格会被当作“与”操作符。</p><p>示例：搜索关于第一次世界大战的英文资讯。<br>搜索：““world war I””<br>结果：已向英特网搜索“world war i”. 共约有937,000项查询结果，这是第1-10项 。 搜索用时0.06秒。</p><p>###7.4. 搜索引擎忽略的字元以及强制搜索</p><p>Google对一些网路上出现频率极高的英文单词，如“i”、“com”、“www”等，以及一些符号如“*”、“.”等，作忽略处理。</p><p>示例：搜索关于www起源的一些历史资料。<br>搜索：“www的历史 internet”<br>结果：以下的字词因为使用过于频繁，没有被列入搜索范围: www 的. 已搜索有关www的历史 internet的中文(简体)网页。 共约有75,100项查询结果，这是第1-10项 。 搜索用时0.22秒。</p><p>我们看到，搜索“www的历史 internet”，但搜索引擎把“www”和“的”都省略了。于是上述搜索只搜索了“历史”和“internet”。这显然不符合要求。这里我顺便说一点搜索引擎分词的知识。当我们在搜索“www的历史”的时候，搜索引擎实际上把这个短语分成三部分，“www”、“的”和“历史”分别来检索，这就是搜索引擎的分词。所以儘管你输入了连续的“www的历史”，但搜索引擎还是把这个短语当成三个关键字分别检索。</p><p>如果要对忽略的关键字进行强制搜索，则需要在该关键字前加上明文的“+”号。</p><p>搜索：“+www +的历史 internet”<br>结果：已搜索有关+www +的历史 internet的中文(简体)网页。 共约有25,000项查询结果，这是第1-10项 。 搜索用时0.05秒。</p><p>另一个强制搜索的方法是把上述的关键字用英文双引号引起来。在上例“”world war I””中，“I”其实也是忽略词，但因为被英文双引号引起来，搜索引擎就强制搜索这一特定短语。</p><p>搜索：““www的历史” internet”<br>结果：已搜索有关“www的历史” internet的中文(简体)网页。 共约有7项查询结果，这是第1-6项 。 搜索用时0.26秒。</p><p>我们看到，这一搜索事实上把“www的历史”作为完整的一个关键字。显然，包含这样一个特定短语的网页并不是很多，不过，每一项都很符合要求。</p><p>注意：大部分常用英文符号（如问号，句号，逗号等）无法成为搜索关键字，加强制也不行。</p><p>##8. 进阶搜索</p><p>上面已经探讨了Google的一些最基础搜索语法。通常而言，这些简单的搜索语法已经能解决绝大部分问题了。不过，如果想更迅速更贴切找到需要的资讯，你还需要了解更多的东西。</p><h3 id="8-1-对搜索的网站进行限制"><a href="#8-1-对搜索的网站进行限制" class="headerlink" title="8.1. 对搜索的网站进行限制"></a>8.1. 对搜索的网站进行限制</h3><p>“site”表示搜索结果局限于某个具体网站或者网站频道，如“<a href="http://www.sina.com.cn”、“edu.sina.com.cn”，或者是某个功能变数名称，如“com.cn”、“com”等等。如果是要排除某网站或者功能变数名称范围内的页面，只需用“-网站/功能变数名称”。" target="_blank" rel="noopener">http://www.sina.com.cn”、“edu.sina.com.cn”，或者是某个功能变数名称，如“com.cn”、“com”等等。如果是要排除某网站或者功能变数名称范围内的页面，只需用“-网站/功能变数名称”。</a></p><p>示例：搜索中文教育科研网站（edu.cn）上关于搜索引擎技巧的页面。<br>搜索：“搜索引擎 技巧 site:edu.cn”<br>结果：已搜索有关搜索引擎 技巧 site:edu.cn的中文(简体)网页。 共约有608项查询结果，这是第1-10项 。 搜索用时0.05秒。</p><p>示例：上著名IT门户网站ZDNET和CNET搜索一下关于搜索引擎技巧方面的资讯。<br>搜索：““search engine” tips site:<a href="http://www.zdnet.com" target="_blank" rel="noopener">www.zdnet.com</a> OR site:<a href="http://www.cnet.com”" target="_blank" rel="noopener">www.cnet.com”</a><br>结果：已在<a href="http://www.zdnet.com内搜索有关“search" target="_blank" rel="noopener">http://www.zdnet.com内搜索有关“search</a> engine” tips OR site:<a href="http://www.cnet.com的网页。" target="_blank" rel="noopener">www.cnet.com的网页。</a> 共约有1,040项查询结果，这是第1-10项 。 搜索用时0.09秒。</p><p>注意，在这里Google有个小BUG。“已在<a href="http://www.zdnet.com" target="_blank" rel="noopener">http://www.zdnet.com</a> 内搜索…”，其实应该表述成“已在<a href="http://www.zdnet.com和http://www.cnet.com内搜索…”。" target="_blank" rel="noopener">http://www.zdnet.com和http://www.cnet.com内搜索…”。</a></p><p>示例：搜索新浪科技频道中关于搜索引擎技巧的资讯。<br>搜索：“搜索引擎 技巧 site:tech.sina.com.cn”<br>结果：已在tech.sina.com.cn搜索有关搜索引擎 技巧 的中文(简体)网页。 共约有163项查询结果，这是第1-10项 。 搜索用时0.07秒。</p><p>注意：site后的冒号为英文字元，而且，冒号后不能有空格，否则，“site:”将被作为一个搜索的关键字。此外，网站功能变数名称不能有“http://”首码，也不能有任何“/”的目录尾码；网站频道则只局限于“频道名.功能变数名称”方式，而不能是“功能变数名称/频道名”方式。</p><h3 id="8-2-在某一类档中查找资讯"><a href="#8-2-在某一类档中查找资讯" class="headerlink" title="8.2. 在某一类档中查找资讯"></a>8.2. 在某一类档中查找资讯</h3><p>“filetype:”是Google开发的非常强大实用的一个搜索语法。也就是说，Google不仅能搜索一般的文字页面，还能对某些二进位文档进行检索。目前，Google已经能检索微软的Office文档如.xls、.ppt、.doc，.rtf，WordPerfect文档，Lotus1-2-3文档，Adobe的.pdf文档，ShockWave的.swf文档（Flash动画）等。其中最实用的文档搜索是PDF搜索。PDF是ADOBE公司开发的电子文档格式，现在已经成为互联网的电子化出版标准。目前Google检索的PDF文档大约有2500万左右，大约占所有索引的二进位文档数量的80％。PDF文档通常是一些图文并茂的综合性文档，提供的资讯一般比较集中全面。</p><p>示例：搜索几个资产负债表的Office文档。<br>搜索：“资产负债表 filetype:doc OR filetype:xls OR filetype:ppt”<br>结果：已搜索有关资产负债表 filetype:doc OR filetype:xls OR filetype:ppt的中文(简体)网页。 共约有481项查询结果，这是第1-10项 。 搜索用时0.04秒。</p><p>注意，下载的Office档可能含有巨集病毒，谨慎操作。</p><p>示例：搜索一些关于搜索引擎知识和技巧方面的PDF文档<br>搜索：?quot;search engine” tips OR tutorial filetype:pdf”<br>结果：已向英特网搜索“search engine” tips OR tutorial filetype:pdf. 共约有12,600项查询结果，这是第1-10项 。 搜索用时0.22秒。</p><p>我们来看其中的一个结果：</p><p>[PDF]Search Engines Tips<br>文档类型: PDF/Adobe Acrobat – HTML 版<br>… <a href="http://www.google.com/press/zeitgeist.html" target="_blank" rel="noopener">http://www.google.com/press/zeitgeist.html</a> See what people are searching on at Google.com  </p><ul><li>Search Engine Watch <a href="http://searchenginewatch.com/" target="_blank" rel="noopener">http://searchenginewatch.com/</a> Some free tips …<br><a href="http://www.allvertical.com/PromoKits/SearchEngineTips.pdf" target="_blank" rel="noopener">http://www.allvertical.com/PromoKits/SearchEngineTips.pdf</a> – 类似网页</li></ul><p>可以看到，Google用[PDF]来标记这是一个PDF的文档检索，另外，它还给出了该PDF文档的HTML版本，该HTML版保留了文档的文字内容和结构，但没有图片。</p><h3 id="8-3-搜索的关键字包含在URL链结中"><a href="#8-3-搜索的关键字包含在URL链结中" class="headerlink" title="8.3. 搜索的关键字包含在URL链结中"></a>8.3. 搜索的关键字包含在URL链结中</h3><p>“inurl”语法返回的网页链结中包含第一个关键字，后面的关键字则出现在链结中或者网页文档中。有很多网站把某一类具有相同属性的资源名称显示在目录名称或者网页名称中，比如“MP3”、“GALLARY”等，于是，就可以用INURL语法找到这些相关资源链结，然后，用第二个关键字确定是否有某项具体资料。INURL语法和基本搜索语法的最大区别在于，前者通常能提供非常精确的专题资料。 </p><p>示例：查找MIDI曲“沧海一声笑”。<br>搜索：“inurl:midi “沧海一声笑””<br>结果：已搜索有关inurl:midi “沧海一声笑“的中文(简体)网页。 共约有27项查询结果，这是第1-10项 。 搜索用时0.34秒。</p><p>注意：“inurl:”后面不能有空格，Google也不对URL符号如“/”进行搜索。例如，Google会把“cgi-bin/phf”中的“/”当成空格处理。</p><p>“allinurl”语法返回的网页的链结中包含所有作用关键字。这个查询的关键字只集中于网页的链结字串。</p><p>示例：查找可能具有PHF安全漏洞的公司网站。通常这些网站的CGI-BIN目录中含有PHF脚本程式（这个脚本是不安全的），表现在链结中就是“功能变数名称/cgi-bin/phf”。<br>搜索：“allinurl:”cgi-bin” phf +com”<br>结果：已向英特网搜索allinurl:”cgi-bin” phf +com. 共约有51项查询结果，这是第1-10项 。 搜索用时0.11搿?/font&gt;</p><h3 id="8-4-搜索的关键字包含在网页标题中"><a href="#8-4-搜索的关键字包含在网页标题中" class="headerlink" title="8.4. 搜索的关键字包含在网页标题中"></a>8.4. 搜索的关键字包含在网页标题中</h3><p>“intitle”和“allintitle”的用法类似于上面的inurl和allinurl，只是后者对URL进行查询，而前者对网页的标题栏进行查询。网页标题，就是HTML标记语言title中之间的部分。网页设计的一个原则就是要把主页的关键内容用简洁的语言表示在网页标题中。因此，只查询标题栏，通常也可以找到高相关率的专题页面。 示例：查找日本明星藤原纪香的照片集。<br>搜索：“intitle:藤原纪香 “写真集“”<br>结果：已搜索有关intitle:藤原纪香 “写真集“的中文(简体)网页。 共约有315项查询结果，这是第1-10项 。 搜索用时0.15秒。</p><h3 id="8-5-搜索的关键字包含在网页的“锚”（anchor）链点内"><a href="#8-5-搜索的关键字包含在网页的“锚”（anchor）链点内" class="headerlink" title="8.5. 搜索的关键字包含在网页的“锚”（anchor）链点内"></a>8.5. 搜索的关键字包含在网页的“锚”（anchor）链点内</h3><p>所谓“锚”，就是在同一个网页中快速切换链结点。与URL和TITLE类似，Google提供了两种对anchor的检索，“inanchor”和“allincnchor”。对此不作详述。</p><p>##9. 其他罕用语法</p><h3 id="9-1-搜索所有链结到某个URL位址的网页"><a href="#9-1-搜索所有链结到某个URL位址的网页" class="headerlink" title="9.1. 搜索所有链结到某个URL位址的网页"></a>9.1. 搜索所有链结到某个URL位址的网页</h3><p>如果你拥有一个个人网站，估计很想知道有多少人对你的网站作了链结。而“link”语法就能让你迅速达到这个目的。</p><p>示例：搜索所有含指向华军软体园“<a href="http://www.newhua.com" target="_blank" rel="noopener">http://www.newhua.com</a>”链结的网页。<br>搜索：“link:<a href="http://www.newhua.com”" target="_blank" rel="noopener">www.newhua.com”</a><br>结果：搜索有链结到<a href="http://www.newhua.com" target="_blank" rel="noopener">http://www.newhua.com</a>的网页 。 共约有920项查询结果，这是第1-10项 。 搜索用时0.12秒。</p><p>注意：“link”不能与其他语法相混合操作，所以“link:”后面即使有空格，也将被Google忽略。另外还要说明的是，link只列出Google索引链结很小一部分，而非全部，所以如果你用Google没有搜到链到你的主页的链结，也不必灰心丧气。</p><p>除了上述功能，link语法还有其他妙用。一般说来，做友情链结的网站都有相似地方。这样，你可以通过这些友情链结，找到一大批具有相似内容的网站。比如说，你是个天文爱好者，你发现某网站非常不错，那么，可以用link语法查一下与之做链结的网站，也许可以找到更多符合你兴趣的内容。</p><h3 id="9-2-查找与某个页面结构内容相似的页面"><a href="#9-2-查找与某个页面结构内容相似的页面" class="headerlink" title="9.2. 查找与某个页面结构内容相似的页面"></a>9.2. 查找与某个页面结构内容相似的页面</h3><p>“related”用来搜索结构内容方面相似的网页。例：搜索所有与中文新浪网主页相似的页面（如网易首页，搜狐首页，中华网首页等），“related:wwwsina.com.cn/index.shtml”。我到现在也不明白这个语法有什么作用，如果有谁知道，请不吝指教。预先感谢。 :)</p><p>###9.3. 从Google伺服器上缓存页面中查询资讯</p><p>“cache”用来搜索Google伺服器上某页面的缓存，通常用于查找某些已经被删除的死链结网页，相当于使用普通搜索结果页面中的“网页快照”功能。</p><p>其他罕用语法如info、stock等不一一介绍，有兴趣的读者可以参阅Google大全。</p><h2 id="10-图片搜索"><a href="#10-图片搜索" class="headerlink" title="10. 图片搜索"></a>10. 图片搜索</h2><p>Google自称可以检索390,000,000张图片，并称自己为“互联网上最好用的图像搜索工具”。从使用结果来看，Google的图片搜索的确不错，但个人以为比AltaVista的还是要差一些，主要体现在检索图片数量比不上AV，匹配度比AV的图片搜索器也差了些。但AltaVista国内用户无法正常访问，因此对中国用户而言，Google的图片搜索引擎已经是最好的了。</p><p>Google首页点击“图像”链结就进入了Google的图像搜索介面“images.Google.com”。你可以在关键字栏位元内输入描述图像内容的关键字，如“britney spears”，就会搜索到大量的小甜甜布兰妮的图片。我目前尚不是很清楚图片的排列标准，不过以观察来看，似乎图片档案名完全符合关键字的结果排列比较考前，然后才按照普通的页面搜索时的标准排列。</p><p>Google给出的搜索结果具有一个直观的缩略图（THUMBNAIL），以及对该缩略图的简单描述，如图像档案名称，以及大小等。点击缩略图，页面分成两祯，上祯是图像之缩略图，以及页面链结，而下祯，则是该图像所处的页面。萤幕右上角有一个“Remove Frame”的按钮，可以把框架页面迅速切换到单祯的结果页面，非常方便。</p><p>Google图像搜索目前支援的语法包括基本的搜索语法如“ ”、“-”、“OR”、“site”和 “filetype:”。其中“filetype:”的尾码只能是几种限定的图片类似，如JPG，GIF等。</p><p>示例：查找新浪网上本拉登的图片<br>搜索：“拉登 OR 拉丹 site:sina.com.cn”<br>结果：搜索有关 拉登 OR 拉丹 site:sina.com.cn 的图片。 共有6项查询结果，这是第1-6项。 搜索用时0.36秒。</p><p>这里我想说明一点的是，images.google.com作为专门的图片搜索引擎，实际上有其特殊的用途。</p><p>举个例子，互联网上本拉登的照片成千上万，但是，它们都是分散的，往往随机的分佈于各种新闻报导中。如果用搜索图片库的方式（最容易想到的如“Ben Ladin photo”），来搜索本拉登的照片，显然是不恰当的，因为很少有人专门为拉登建一个线上相册。在这个时候，images.google.com就派上用场了。</p><p>但是，如果查找的图片在网上有很多主题“gallary”，如诸多电影电视明星的照片，则明显就不适合用images.google.com来查找了。</p><p>images.google.com对于很多报纸杂志的编辑，绝对是一个雪中送炭式的工具。比如要在某个版面上插一张专题图片，用google的图片搜索功能几秒钟就可以搞定。</p><p>综上，可以有这样的一般性结论：如果要搜索的图片是分散的，则用google图片搜索；如果要搜索的图片通常是处于某个图片集合中的，则不适合用google图片搜索。</p><h2 id="11-目录检索"><a href="#11-目录检索" class="headerlink" title="11. 目录检索"></a>11. 目录检索</h2><p>如果不想搜索广泛的网页，而是想寻找某些专题网站，可以访问Google的分类目录“<a href="http://directory.Google.com/" target="_blank" rel="noopener">http://directory.Google.com/</a>”，中文目录是“<a href="http://directory.Google.com/Top/World/Chinese_Simplified/" target="_blank" rel="noopener">http://directory.Google.com/Top/World/Chinese_Simplified/</a>”。分类的网站目录一般由专人负责，分类明确，资讯集中。因此读者应该养成这样的习惯：首先考虑所需要的资讯能否在一个专门主题的网站上找到。不过需要说明的是，用目录检索，往往需要用户对查询的领域很熟悉。否则，连查询的内容属于哪个类目都不知道，目录流览也就无从谈及了。 目前Google使用的分类目录採用了ODP的内容。“Open Directory Project”是网景公司所主持的一项大型公共网页目录。由全世界各地的义务编辑人员来审核挑选网页，并依照网页的性质及内容来分门别类。因此，在某一目录门类中进行搜索往往能有更高的命中率。另外，Google根据其专业的“网页级别”（PageRank）技术对目录中登录的网站进行了排序，可以让一般的检索更具高效率。</p><p>示例：查找一下介绍搜索引擎方面的中文网站<br>搜索：先进入中文简体分类目录，再进入“电脑”目录，再进入“互联网路”子目录，再进入“搜寻”子目录。我们看到在“World &gt; Chinese Simplified &gt; 电脑 &gt; 互联网路 &gt; 搜寻”下，还有两个子目录“分类目录 (33) 搜索引擎 (10)”，以及6个相关网站。显然，这些都是我们所需要的资讯。</p><p>除了用滑鼠层层点入，也可以在目录中检索。比如，在上例的“互联网路”目录下，选中“只在互联网路中搜索”选项，在搜索栏内填入“搜索引擎”进行搜索。<br>结果：在分类Google 网页目录项中搜索搜索引擎。 共约有387项查询结果，这是第11-20项 。 搜索用时0.09秒。</p><p>可以看到，上述查询结果比普通的检索更有效，因为在分类“互联网路”下进行搜索剔除了很多不相关的诸如新闻之类的无效资讯。不过，对于中文用户而言，现在最大的问题是志愿的中文目录编辑太少，导致收录站点太少，因此搜索结果范围显得过于狭隘。但愿这个问题能随著Google以及ODP项目在国内名声的响亮而能得到改观。</p><h2 id="12-新闻组搜索"><a href="#12-新闻组搜索" class="headerlink" title="12. 新闻组搜索"></a>12. 新闻组搜索</h2><p>新闻组有详尽的分类主题，某些主题还有专人管理和编辑，具有大量的有价值资讯。由于新闻组包含的资讯实在是海量，因此不利用工具进行检索是不大可能的。DEJA一直是新闻组搜索引擎中的佼佼者。2001年2月份，Google将DEJA收购并提供了所有DEJA的功能。现在，除了搜索之外，Google还支援新闻组的WEB方式流览和张贴功能。</p><p>进入Google新闻组“<a href="http://groups.Google.com/" target="_blank" rel="noopener">http://groups.Google.com/</a>”，你有两种资讯查找方式。一种是一层层的点击进入特定主题讨论组，另一种则是直接搜索。现在，我们进行一个最简单的搜索试验，查找一下新闻组中关于山顶洞人的讨论资讯。</p><p>搜索：“山顶洞人”<br>结果：在各群组内搜索 山顶洞人 共约有2,400项查询结果，这是第1-10项 。 搜索用时0.94秒。 搜索结果默认按照“留言内容”排列，但是你也可以点击“依照日期”按钮，让帖子按照发布日期排列。</p><p>因为新闻组中的帖子实在是多，而且又涉及一些普通搜索所没有的语法，所以建议使用“高级群组搜寻”进入高级搜索介面。新闻组高级搜索提供留言内容、分类主题、标题、留言者、留言代码、语言和发布日期作为条件进行搜索。其中作者项指作者发帖所用的唯一识别号电子信箱。</p><h2 id="13-Google的其他杰出功能"><a href="#13-Google的其他杰出功能" class="headerlink" title="13. Google的其他杰出功能"></a>13. Google的其他杰出功能</h2><h3 id="13-1-网页快照"><a href="#13-1-网页快照" class="headerlink" title="13.1. 网页快照"></a>13.1. 网页快照</h3><p>网页快照是Google抓下来缓存在伺服器上的网页。它有三个作用：</p><p>第一， 如果原位址打开很慢，那么可以直接查看Google缓存页面，因为Google伺服器速度极快。</p><p>第二， 如果原链结已经死掉或者因为网路的原因暂时链结不通，那么可以通过Google快照看到该页面资讯。当然，快照内容不是该页最新页面。</p><p>第三， 如果打开的页面信息量巨大，一下子找不到关键字所在位置，那么可以通过Google快照，因为快照中Google用黄色表明关键字位置。</p><h3 id="13-2-集成化的工具条"><a href="#13-2-集成化的工具条" class="headerlink" title="13.2. 集成化的工具条"></a>13.2. 集成化的工具条</h3><p>为了方便搜索者，Google提供了工具条，集成于流览器中，用户无需打开Google主页就可以在工具条内输入关键字进行搜索。此外，工具条还提供了其他许多功能，如显示页面PageRank等。最方便的一点在于用户可以快捷的在Google主页、目录服务、新闻组搜索、高级搜索和搜索设定之间切换。欲安装Google的工具条，可以访问“<a href="http://toolbar.Google.com/”，按页面提示可以自动下载并安装。不过，Google工具条目前只支援IE5.0以上版本。" target="_blank" rel="noopener">http://toolbar.Google.com/”，按页面提示可以自动下载并安装。不过，Google工具条目前只支援IE5.0以上版本。</a></p><p>对于经常进行网路搜索者而言，Google工具条实在是必备的东西！！</p><p>###13.3. 单词英文解释</p><p>写英文文章的时候，最头疼的事情就是对某个英文单词的用法不确定。现在有了Google，一切就迎刃而解了！无论你是想查找某个生词的意思还是想了解某个单词的用法，均可使用线上词典。</p><p>进入英文Google，输入你要查的单词。举个例子，我想查一下suggest的用法。结果如下：“Searched the web for suggest. Results 1 – 10 of about 8,000,000. Search took 0.08 seconds. ”注意看上面句子中，单词suggest下出现了一个横线，点击这个链结，就跳转到另外一个网站“<a href="http://www.dictionary.com/" target="_blank" rel="noopener">http://www.dictionary.com/</a>”，Google已经把单词提交给该网站的查询脚本。看看这个网站所提供的详尽解释吧。 :)</p><h3 id="13-4-网页翻译"><a href="#13-4-网页翻译" class="headerlink" title="13.4. 网页翻译"></a>13.4. 网页翻译</h3><p>你懂英文，但是你不见得就懂德文、法文、拉丁文。如果搜索出来的页面是这些语言怎么办？呵呵，Google提供了网页翻译功能！！虽然目前只支持有限的拉丁语、法语、西班牙语、德语和葡萄牙文，但是我不得不承认，这是个杰出功能。</p><p>试著做以下搜索：“big bang site:fr”。这个表示查找关于宇宙大爆炸的法文网页。看第一条结果：</p><p>The Big Bang Website – [ Translate this page ]<br>… A propos de Big Bang. Le dernier numéro en date. Les anciens numéros. Autres<br>activités. Concerts progressifs en France. Emissions de radio. Liens.<br>perso.club-internet.fr/calyx/bigbang/ – 3k – Cached – Similar pages</p><p>有点晕。没关係，点击“Translate this page”按钮。再看结果，嗯，大致能看明白，这原来是个叫“big bang”的乐队的网站，与大爆炸无关…</p><p>机器翻译是一个很前沿的人工智慧课题，想指望翻译出来的结果跟专门用英语撰写的内容是不可能的。但西文间的互相转译比中英文机译强得多得多了。至少能看明白。</p><p>###13.5. 单词纠错</p><p>笔者记忆力很差，英文单词经常拼写错误。但Google有纠错功能。比如在写上文的时候，我要用到英文单词“tutorial”，我只是依稀记得好像是“tatorial”的样子，但不肯定，于是用Google查了一下，它马上提醒：“您要找的会不会是： tutorial ”，呵呵，正是这个单词。</p><h3 id="13-6-繁简转换"><a href="#13-6-繁简转换" class="headerlink" title="13.6. 繁简转换"></a>13.6. 繁简转换</h3><p>对中文用户而言，常希望能同时检索繁体和简体资讯。Google能做到这一点。Google默认使用繁简自动转换功能，因此你输入的简体关键字也将被转换成繁体做检索。这样省了不少力气。当然，如果你不希望这样的话，也可以在“使用偏好”中把这个选项关掉。</p><h3 id="13-7-搜索结果过滤"><a href="#13-7-搜索结果过滤" class="headerlink" title="13.7. 搜索结果过滤"></a>13.7. 搜索结果过滤</h3><p>网路上的成人内容浩如烟海，而且很多站点具有欺骗或者其他不良企图，流览者很容易掉入其中的陷阱。为此，Google新设立了成人内容过滤功能，见Google的设置页面，<a href="http://www.Google.com/preferences" target="_blank" rel="noopener">http://www.Google.com/preferences</a>，最底下有一个选项SafeSearch Filtering。不过，中文状态下的Google尚没有这个功能。</p><p>##14. Google尚未发布的一些新特性和功能</p><p>###14.1. 对网页更新日期做出限定“daterange:”</p><p>评价一个搜索引擎的好坏，更新频率是一个很关键因素。通常情况下，我们总希望能找到最新的网页。Google已经开发了对更新日期做限定的搜索语法，但目前还未公佈。而且比较麻烦的是，Google现在支持的日期格式为julian（凯撒日）格式，把通用日期数值切换成julian格式需要借助第三方网站：<a href="http://www.tesre.bo.cnr.it/~mauro/JD/" target="_blank" rel="noopener">http://www.tesre.bo.cnr.it/~mauro/JD/</a>。不过，在下面这个自称是“Google终极搜索介面”的网页上，你已经可以利用Google的这项新特性了，它自动提供日期转换功能。</p><p>Google Ultimate Interface：<a href="http://www.faganfinder.com/google.html" target="_blank" rel="noopener">http://www.faganfinder.com/google.html</a></p><p>Google为什么要这样做呢？也许是在测试阶段，不想让太多人使用吧。 :)</p><h3 id="14-2-新闻搜索“http-news-google-com-”"><a href="#14-2-新闻搜索“http-news-google-com-”" class="headerlink" title="14.2. 新闻搜索“http://news.google.com/”"></a>14.2. 新闻搜索“<a href="http://news.google.com/" target="_blank" rel="noopener">http://news.google.com/</a>”</h3><p>Google的新闻搜索尚在B测试阶段，但使用起来已经非常不错了。新闻首页按头条新闻，各国新闻，以及不同领域做了分类。你可以通过Google搜索各大门户和新闻网站的新闻，简单、快捷、方便。遗憾的是，目前Google新闻只检索英文资讯。</p><p>###14.3. 分类广告搜索“<a href="http://catalogs.google.com/" target="_blank" rel="noopener">http://catalogs.google.com/</a>”</p><p>这也在B测试阶段。主要是对电子分类广告做检索。广告页为JPG图片格式。</p><h3 id="14-4-其他Google的最新发展动态"><a href="#14-4-其他Google的最新发展动态" class="headerlink" title="14.4. 其他Google的最新发展动态"></a>14.4. 其他Google的最新发展动态</h3><p>想了解Google公司的工程师们都在忙些什么吗？去看一下Google实验室（<a href="http://labs.google.com/" target="_blank" rel="noopener">http://labs.google.com/</a>）吧。Google的最新设想都在这个地方向访问者展现出来。现在处于发展和试验阶段的新功能有：术语查询、语音查询、键盘查询等等。</p><p>网路工程师和程式师可以看看这个地方：<a href="http://www.google.com/apis/" target="_blank" rel="noopener">http://www.google.com/apis/</a>，我想可以让你喜出望外的。</p><h3 id="14-5-一个有趣的地方"><a href="#14-5-一个有趣的地方" class="headerlink" title="14.5. 一个有趣的地方"></a>14.5. 一个有趣的地方</h3><p>想看看世界各国线民都用Google搜索什么资讯么？到<a href="http://www.google.com/press/zeitgeist.html" target="_blank" rel="noopener">http://www.google.com/press/zeitgeist.html</a>看一下就知道了。从这些资讯中，你大致可以了解到世界热点和流行时尚走向。 :)</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>mysql的root用户密码丢失解决办法</title>
      <link href="/2014/11/15/tech/db/mysql-forget-password.html"/>
      <url>/2014/11/15/tech/db/mysql-forget-password.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><p>当我们使用mysql数据库时，可能会遇到忘记mysql密码的情况，当遇到这种情况时，本人的第一反应是：坑爹啊，重装一个吧！（PS：感觉好弱吧），后来遇到的多了，也就有了解决的办法了。</p><h2 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h2><p>停止mysql进程</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;service mysqld <span class="built_in">stop</span> 或者 pkill mysqld</span><br></pre></td></tr></table></figure><p>启动mysql，并且附加一个选项</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="comment">mysqld_safe</span> --<span class="comment">skip</span><span class="literal">-</span><span class="comment">grant</span><span class="literal">-</span><span class="comment">tables</span> --<span class="comment">user=mysql</span> <span class="comment">&amp;</span></span><br></pre></td></tr></table></figure><p>这样就可以在登录时跳过授权表mysql.user和mysql.db,登录mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">mysql -uroot</span></span><br></pre></td></tr></table></figure><p><img src="/images/20131128225656062.png" alt="登录mysql" title="文件大小"></p><p>登录之后，就可以修改root的登录密码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> mysql.user <span class="keyword">set</span> <span class="keyword">password</span>=<span class="keyword">password</span>(<span class="string">"123"</span>) <span class="keyword">where</span> <span class="keyword">user</span>=<span class="string">"root"</span> <span class="keyword">and</span> host=<span class="string">"localhost"</span>;</span><br></pre></td></tr></table></figure><p>修改完密码后，要记得重启服务，就可以使用新密码正常登录了</p><h4 id="PS：修改用户密码还有下面几种方法"><a href="#PS：修改用户密码还有下面几种方法" class="headerlink" title="PS：修改用户密码还有下面几种方法"></a>PS：修改用户密码还有下面几种方法</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> <span class="keyword">password</span> <span class="keyword">for</span> root@localhost=<span class="keyword">password</span>(<span class="string">"123"</span>);  </span><br><span class="line"><span class="keyword">set</span> <span class="keyword">password</span>=<span class="keyword">password</span>(<span class="string">"123"</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html移动端自适应宽度</title>
      <link href="/2014/11/15/tech/front/html-viewpoint-scale.html"/>
      <url>/2014/11/15/tech/front/html-viewpoint-scale.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-添加元标签"><a href="#1-添加元标签" class="headerlink" title="1. 添加元标签"></a>1. 添加元标签</h2><p>wap2.0网页的head里加入下面这条元标签，在iPhone的浏览器中页面将以原始大小显示，并不允许缩放。</p><a id="more"></a><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width,minimum-scale=1.0,maximum-scale=1.0;user-scalable=0;"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-参数说明"><a href="#2-参数说明" class="headerlink" title="2. 参数说明"></a>2. 参数说明</h2><p>width - viewport的宽度 </p><p>height - viewport的高度</p><p>initial-scale - 初始的缩放比例</p><p>minimum-scale - 允许用户缩放到的最小比例</p><p>maximum-scale - 允许用户缩放到的最大比例</p><p>user-scalable - 用户是否可以手动缩放</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP协议和状态码</title>
      <link href="/2014/11/14/tech/http-code.html"/>
      <url>/2014/11/14/tech/http-code.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-http协议介绍"><a href="#1-http协议介绍" class="headerlink" title="1. http协议介绍"></a>1. http协议介绍</h2><p>计算机中的协议和现实中的协议是一样的，一式双份/多份。双方/多方都遵从共同的一个规范，这个规范就可以称为协议。计算机只所以能全世界互通，协议是功不可没，如果没有协议，计算机各说各话，根本谁都听不懂谁。有ftp，http，stmp，pop，tcp/ip协议…..</p><p>http协议的重要性:无论是以后用webserverice,还是用rest做大型架构,都离不开对HTTP协议的认识.</p><p>甚至可以简化的说:</p><p>webservice = http+XML</p><p>rest = http+ json</p><p>各种API,也一般是用http+XML/json来实现的.</p><h2 id="2-http协议内容"><a href="#2-http协议内容" class="headerlink" title="2. http协议内容"></a>2. http协议内容</h2><h3 id="2-1-http-请求头"><a href="#2-1-http-请求头" class="headerlink" title="2.1. http 请求头"></a>2.1. http 请求头</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">请求行(请求方法路径协议)</span><br><span class="line"><span class="section">头信息(格式为key: value)</span></span><br><span class="line">空行</span><br><span class="line">主体信息(可选) (发送内容)</span><br><span class="line"><span class="section">例:</span></span><br><span class="line">POST /http.php HTTP/1.1</span><br><span class="line"><span class="section">Host: localhost</span></span><br><span class="line"><span class="section">Content-type: application/x-www-form-urlencode</span></span><br><span class="line"><span class="section">Cotent-length: 15</span></span><br><span class="line"></span><br><span class="line">name=jack&amp;age=3</span><br></pre></td></tr></table></figure><h3 id="2-2-http-响应头"><a href="#2-2-http-响应头" class="headerlink" title="2.2. http 响应头"></a>2.2. http 响应头</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">响应行(协议状态码状态文字)</span><br><span class="line"><span class="section">响应头信息(格式为key:value)</span></span><br><span class="line">空行</span><br><span class="line">主体信息(也可能没有)</span><br><span class="line"><span class="section">例:</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line"><span class="section">Content-type: text/html</span></span><br><span class="line"><span class="section">Content-length: 5</span></span><br><span class="line"></span><br><span class="line">hello</span><br></pre></td></tr></table></figure><h2 id="3-状态码-状态文字"><a href="#3-状态码-状态文字" class="headerlink" title="3. 状态码,状态文字"></a>3. 状态码,状态文字</h2><p>状态码是用来反应服务器响应情况的，最常见的如200 OK, 404 NOT FOUND。状态文字是用来描述状态码的,便于人观察.</p><table><thead><tr><th align="left">状态码</th><th align="left">定义</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">1XX</td><td align="left">信息</td><td align="left">接受到信息，请处理</td></tr><tr><td align="left">2XX</td><td align="left">成功</td><td align="left">操作成功的收到，理解和接受</td></tr><tr><td align="left">3XX</td><td align="left">重定向</td><td align="left">为了完成请求，必须采取进一步措施</td></tr><tr><td align="left">4XX</td><td align="left">客户端错误</td><td align="left">请求的语法有错误或不能完全被满足</td></tr><tr><td align="left">5XX</td><td align="left">服务端错误</td><td align="left">服务器无法完成明显有效的请求</td></tr></tbody></table><h3 id="3-1-常见状态码"><a href="#3-1-常见状态码" class="headerlink" title="3.1. 常见状态码"></a>3.1. 常见状态码</h3><p>200 – 服务器成功返回网页  </p><p>204 - no content</p><p>301/2- 永久/临时重定向</p><p>304 Not Modified– 未修改  </p><p>307 重定向中保持原有的请求数据</p><p>404 – 请求的网页不存在 </p><p>503 – 服务器暂时不可用 </p><p>500 – 服务器内部错误</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>bootstrap中modal的data-remote属性无效的问题</title>
      <link href="/2014/11/10/tech/front/bootstrap-modal-data-remote-not-working.html"/>
      <url>/2014/11/10/tech/front/bootstrap-modal-data-remote-not-working.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><p>最近在公司更新一个项目是发现一个问题，就是bootstrap的模态框的data-remote属性没有效果，但是发现老项目里是有效果的，发现很奇怪，Google后终于发现问题所在，于是记录下来。</p><p>链接地址 <a href="http://stackoverflow.com/questions/18378720/bootstrap-3-with-remote-modal" target="_blank" rel="noopener">http://stackoverflow.com/questions/18378720/bootstrap-3-with-remote-modal</a></p><p>原因是在bootstrap3.1之后modal的一些属性发生了变化，远程的内容要插入到<code>.modal-content</code>选择器里面。可以看一下两者的区别。</p><h2 id="2-Bootstrap跨版本区别"><a href="#2-Bootstrap跨版本区别" class="headerlink" title="2. Bootstrap跨版本区别"></a>2. Bootstrap跨版本区别</h2><h3 id="2-1-Bootstrap3-1之前的版本"><a href="#2-1-Bootstrap3-1之前的版本" class="headerlink" title="2.1. Bootstrap3.1之前的版本"></a>2.1. Bootstrap3.1之前的版本</h3><h4 id="模态框页"><a href="#模态框页" class="headerlink" title="模态框页"></a>模态框页</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">data-toggle</span>=<span class="string">"modal"</span> <span class="attr">data-target</span>=<span class="string">"#myModal"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/ball.gif"</span> <span class="attr">alt</span>=<span class="string">"Add Account"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal fade"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">id</span>=<span class="string">"myModal"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">tabindex</span>=<span class="string">"-1"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-remote</span>=<span class="string">"./popups/remotePage.html"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">role</span>=<span class="string">"dialog"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-backdrop</span>=<span class="string">"static"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-keyboard</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="远程页面parentPage-html"><a href="#远程页面parentPage-html" class="headerlink" title="远程页面parentPage.html"></a>远程页面parentPage.html</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-dialog"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-content"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-header"</span>&gt;</span></span><br><span class="line">        Header</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-body"</span>&gt;</span></span><br><span class="line">            One fine body...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-footer"</span>&gt;</span>Footer</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>远程内容直接插入到<code>.modal</code>节点里面。</p><h3 id="2-2-Bootstrap3-1之后的版本"><a href="#2-2-Bootstrap3-1之后的版本" class="headerlink" title="2.2. Bootstrap3.1之后的版本"></a>2.2. Bootstrap3.1之后的版本</h3><h4 id="模态框页-1"><a href="#模态框页-1" class="headerlink" title="模态框页"></a>模态框页</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"./popups/remotePage.html"</span> <span class="attr">data-toggle</span>=<span class="string">"modal"</span> <span class="attr">data-target</span>=<span class="string">"#myModal"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/ball.gif"</span> <span class="attr">alt</span>=<span class="string">"Add Account"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal fade"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">id</span>=<span class="string">"myModal"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">tabindex</span>=<span class="string">"-1"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">role</span>=<span class="string">"dialog"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-backdrop</span>=<span class="string">"static"</span></span></span><br><span class="line"><span class="tag">     <span class="attr">data-keyboard</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-dialog"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-content"</span>&gt;</span></span><br><span class="line">            ....</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="远程页面parentPage-html-1"><a href="#远程页面parentPage-html-1" class="headerlink" title="远程页面parentPage.html"></a>远程页面parentPage.html</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-header"</span>&gt;</span>Header<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-body"</span>&gt;</span></span><br><span class="line">    One fine body...</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"modal-footer"</span>&gt;</span>Footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>远程内容直接插入到<code>.modal-content</code>节点里面。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>这是bootstrap跨版本所产生的问题，因此当我们使用开源的框架时，要时刻留意每个版本直接作出的改动。这样，我们才能够避免出现类似的错误，愿与大家共同进步。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bootstrap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用load导出mysql表数据</title>
      <link href="/2014/10/28/tech/db/mysql-load-data.html"/>
      <url>/2014/10/28/tech/db/mysql-load-data.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-准备"><a href="#1-准备" class="headerlink" title="1. 准备"></a>1. 准备</h2><p>当我们需要备份数据库时，需要导出数据，我们一般是使用mysqldump命令来进行数据的导出，下面我们先来试验一下</p><p>首先创建一张表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t1`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><p>创建t1表，只有一个字段，往数据表中插入几行数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`t1`</span> <span class="keyword">VALUES</span> (<span class="number">1</span>,<span class="string">'tom'</span>),(<span class="number">2</span>,<span class="string">'jack'</span>),(<span class="number">3</span>,<span class="string">'rose'</span>);</span><br></pre></td></tr></table></figure><h2 id="2-mysqldump导出"><a href="#2-mysqldump导出" class="headerlink" title="2. mysqldump导出"></a>2. mysqldump导出</h2><p>然后使用mysqldump开始备份</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysqldump -uroot -proot <span class="keyword">test</span> t1 -F -l &gt; /tmp/<span class="keyword">test</span>.sql</span><br></pre></td></tr></table></figure><p>这样我们就备份完毕了，我们可以查看一下test.sql的部分内容</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--</span></span><br><span class="line"><span class="comment">-- Table structure for table `t1`</span></span><br><span class="line"><span class="comment">--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> <span class="string">`t1`</span>;</span><br><span class="line"><span class="comment">/*!40101 SET @saved_cs_client     = @@character_set_client */</span>;</span><br><span class="line"><span class="comment">/*!40101 SET character_set_client = utf8 */</span>;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`t1`</span> (</span><br><span class="line"><span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line"><span class="string">`name`</span> <span class="built_in">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">''</span></span><br><span class="line">) <span class="keyword">ENGINE</span>=MyISAM <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</span><br><span class="line"><span class="comment">/*!40101 SET character_set_client = @saved_cs_client */</span>;</span><br></pre></td></tr></table></figure><p>可以看到里面有一大堆表结构的语句和表创建的语句，当数据量非常大的时候，导出的速度就可想而知。</p><p>于是我们就需要在导出的时候避开这些语句，这里就要用到load的infile和outfile来导入导出数据。</p><h2 id="3-outfile导出"><a href="#3-outfile导出" class="headerlink" title="3. outfile导出"></a>3. outfile导出</h2><p>导出outfile的使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> <span class="string">`t1`</span> <span class="keyword">INTO</span> <span class="keyword">OUTFILE</span> <span class="string">"/tmp/t1.outfile.sql"</span></span><br></pre></td></tr></table></figure><p>可以通过select查询将要导出的数据表和数据表的字段导出来，可以导出全部列和指定列，如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="string">`id`</span> <span class="keyword">FROM</span> <span class="string">`t1`</span> <span class="keyword">INTO</span> <span class="keyword">OUTFILE</span> <span class="string">"/tmp/t1.outfile.sql"</span></span><br></pre></td></tr></table></figure><p>这样就导出了t1表的id列。</p><p>看一下导出的文件格式</p><p><img src="/images/20140904110643.jpg" alt="sql文件格式" title="sql文件格式"></p><p>可以看到只导出了数据，而不存在表的结构和其他不相干的语句，这样就大大减少了导出数据的量，当大数据量时，速度就会明显提升了</p><p>导入load data的使用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span> <span class="string">"/tmp/t1.outfile.sql"</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> <span class="string">`t1`</span></span><br></pre></td></tr></table></figure><p>这样是导入到t1表的全部列中，也可以导入到某一列或几列中</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">LOAD</span> <span class="keyword">DATA</span> <span class="keyword">INFILE</span> <span class="string">"/tmp/t1.outfile.sql"</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> <span class="string">`t1`</span>(<span class="string">`id`</span>)</span><br></pre></td></tr></table></figure><hr><h2 id="3-mysqldump和load-data比较"><a href="#3-mysqldump和load-data比较" class="headerlink" title="3. mysqldump和load data比较"></a>3. mysqldump和load data比较</h2><p>下面进行一下实际操作，在t1表中插入1000万行数据进行导入导出速度的比较。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(<span class="strong">*) from t1;        </span></span><br><span class="line"><span class="strong">+----------+</span></span><br><span class="line"><span class="strong">| count(*</span>) |</span><br><span class="line"><span class="code">+----------+</span></span><br><span class="line">| 10485760 |</span><br><span class="line"><span class="code">+----------+</span></span><br></pre></td></tr></table></figure><h3 id="3-1-用outfile导出数据"><a href="#3-1-用outfile导出数据" class="headerlink" title="3.1. 用outfile导出数据"></a>3.1. 用outfile导出数据</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; <span class="keyword">select</span> * <span class="keyword">from</span> t1 <span class="keyword">into</span> outfile "/tmp/outfile.sql";</span><br><span class="line">Query OK, <span class="number">10485760</span> <span class="keyword">rows</span> affected (<span class="number">2.43</span> sec)</span><br></pre></td></tr></table></figure><p>发现导出的速度非常快，1000万行数据只需要2秒多</p><h3 id="3-2-使用mysqldump导出数据"><a href="#3-2-使用mysqldump导出数据" class="headerlink" title="3.2. 使用mysqldump导出数据"></a>3.2. 使用mysqldump导出数据</h3><p><img src="/images/20131130142325812.png" alt="导出时间" title="导出时间"></p><p>发现导出需要12秒左右，是outfile的5倍左右</p><h3 id="3-3-比较两个文件的大小"><a href="#3-3-比较两个文件的大小" class="headerlink" title="3.3. 比较两个文件的大小"></a>3.3. 比较两个文件的大小</h3><p><img src="/images/20131130142531125.png" alt="文件大小" title="文件大小"></p><p>可以看到mysqldump导出的数据是outfile的2倍，这也就说明了outfile的优势所在。</p><hr><h3 id="3-4-使用load-data-infile导入"><a href="#3-4-使用load-data-infile导入" class="headerlink" title="3.4. 使用load data infile导入"></a>3.4. 使用load data infile导入</h3><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; load data infile "/tmp/outfile.sql" into table t1;    </span><br><span class="line">Query OK, 10485760 rows affected (12.46 sec)</span><br><span class="line">Records: 10485760  Deleted: 0  Skipped: 0  Warnings: 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mysql&gt; select count(<span class="strong">*) from t1;                      </span></span><br><span class="line"><span class="strong">+----------+</span></span><br><span class="line"><span class="strong">| count(*</span>) |</span><br><span class="line"><span class="code">+----------+</span></span><br><span class="line">| 10485760 |</span><br><span class="line"><span class="code">+----------+</span></span><br></pre></td></tr></table></figure><p>发现导入的速度也是不慢的</p><h2 id="4-远程导入数据"><a href="#4-远程导入数据" class="headerlink" title="4. 远程导入数据"></a>4. 远程导入数据</h2><p>假设客户端与mysql服务器不在同一机器，导入文件在客户端机器上 d:/outfile.sql ，在客户机登录mysql后，执行下面导入语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">load</span> <span class="keyword">data</span> <span class="keyword">local</span> <span class="keyword">infile</span>  <span class="string">"d:/outfile.sql"</span> <span class="keyword">into</span> <span class="keyword">table</span> t1;</span><br></pre></td></tr></table></figure><p>正常情况是可以成功的，如果出现提示：</p><blockquote><p>ERROR 1148 (42000): The used command is not allowed with this MySQL version</p></blockquote><p>出现这种情况一般是由于MySQL限制了客户端导入本地文件的权限，可以查看一下</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="emphasis">'local%'</span>;</span><br><span class="line"><span class="code">+---------------+</span>-------+</span><br><span class="line">| Variable<span class="emphasis">_name | Value |</span></span><br><span class="line"><span class="emphasis">+---------------+-------+</span></span><br><span class="line"><span class="emphasis">| local_</span>infile  | OFF   |</span><br><span class="line"><span class="code">+---------------+</span>-------+</span><br></pre></td></tr></table></figure><p>在这种情况下，可以有两种方法解决</p><p>1.连接mysql远程客户端，添加加–local-infile=1参数。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;mysql -u xxx -p xxx <span class="keyword">database</span> -h xxx <span class="comment">--local-infile=1</span></span><br></pre></td></tr></table></figure><p>2.修改全局属性</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">set</span> <span class="keyword">global</span> local_infile = <span class="number">1</span>;</span><br><span class="line">Query OK, <span class="number">0</span> <span class="keyword">rows</span> affected (<span class="number">0.00</span> sec)</span><br><span class="line">mysql&gt; <span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">'local%'</span>;</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| Variable_name | <span class="keyword">Value</span> |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line">| local_infile  | <span class="keyword">ON</span>    |</span><br><span class="line">+<span class="comment">---------------+-------+</span></span><br><span class="line"><span class="number">1</span> <span class="keyword">row</span> <span class="keyword">in</span> <span class="keyword">set</span> (<span class="number">0.00</span> sec)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决php处理jpg格式图片的问题</title>
      <link href="/2014/10/23/tech/php/php-jpg-issue.html"/>
      <url>/2014/10/23/tech/php/php-jpg-issue.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-问题"><a href="#1-问题" class="headerlink" title="1. 问题"></a>1. 问题</h2><p>这两天在使用wordpress的编辑图像功能时遇到一个问题，发现jpeg格式的图片在上传之后无法编辑，以为是代码的问题，后来重新安装wp后发现问题依旧，就猜想是不是环境的问题，于是就查看phpinfo的结果，发现在gd模块下ibjpeg version unknown，不能识别jpeg的版本，在网上搜索一番，终于找到了结果，拿来和大家分享，希望对有同样问题的同学有帮助。 </p><h2 id="2-解决办法"><a href="#2-解决办法" class="headerlink" title="2. 解决办法"></a>2. 解决办法</h2><p>这个原因是由于gd库没有解析jpeg的版本，这就需要重新编译php和gd库扩展,首先需要编译安装 freetype，libpng，jpegv9，和gd2 安装过程就不在赘述。</p><p>然后在编译php的时候将–with-gd=/usr/local/gd2/ 替换成–enable-gd-native-ttf 这个选项，来进行编译，编译成功后进入源代码文件夹内，进入ext/gd/libgd文件夹下，修改gd_jpeg.c文件，大约在111行左右，将switch内的内容替换为如下格式</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(JPEG_LIB_VERSION) &#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="number">62</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"6b"</span>;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">case</span> <span class="number">70</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"7"</span>;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">case</span> <span class="number">80</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"8"</span>;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">case</span> <span class="number">81</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"8a"</span>;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">case</span> <span class="number">82</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"8b"</span>;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">case</span> <span class="number">83</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"8c"</span>;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">case</span> <span class="number">84</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"8d"</span>;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">case</span> <span class="number">90</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"9"</span>;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">case</span> <span class="number">91</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"9a"</span>;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">case</span> <span class="number">92</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"9b"</span>;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">case</span> <span class="number">93</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"9c"</span>;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">case</span> <span class="number">94</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"9d"</span>;</span><br><span class="line">           <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">default</span>:</span><br><span class="line">           <span class="keyword">return</span> <span class="string">"unknown"</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>然后进入到上级目录内，开始编译gd扩展</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="regexp">/usr/</span>local<span class="regexp">/php/</span>bin<span class="regexp">/phpize</span></span><br></pre></td></tr></table></figure><p>然后 </p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;./configure --<span class="keyword">with</span>-php-<span class="keyword">config</span>=/usr/<span class="keyword">local</span>/php/bin/php-<span class="keyword">config</span> --<span class="keyword">with</span>-jpeg-dir=/usr/<span class="keyword">local</span>/jpeg --<span class="keyword">with</span>-gd</span><br></pre></td></tr></table></figure><p>编译完成</p><p>然后在php.ini中添加一行</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="attribute">extension</span>=gd.so</span><br></pre></td></tr></table></figure><p>重启apache服务，就会看到在libjpeg version 后显示的不再是unknown了 ，问题解决了</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>纪念在github上开博</title>
      <link href="/2014/10/22/life/first.html"/>
      <url>/2014/10/22/life/first.html</url>
      
        <content type="html"><![CDATA[<p>折腾了半天，终于把blog弄好了，写点东西来纪念一下 O(∩_∩)O。</p><p>原来是在csdn上更新博客的，后来听群里的朋友说github可以建立独立博客，感觉挺稀奇（ps:其实已经out了）。于是就开始在github上折腾了，发现是用jekyll模板来写的，也就懒得再去看他的语法了，网上搜刮了一个主题，然后改吧改吧的，就拿来用了，哈哈，感觉还不错哦！</p><p>其实有时候我也懒得写博客（ps:主要是水平太菜了），平时也就记录记录自己的学习笔记啥的，方便以后查找查找。后来看到这篇文章<a href="http://www.cnblogs.com/bangerlee/archive/2011/09/11/2173632.html" target="_blank" rel="noopener">我为什么写博客</a>，感觉大受启发，于是决定每隔一段时间写点啥记录一下，哈。</p><p>希望可以坚持下去，看到自己的进步！</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
