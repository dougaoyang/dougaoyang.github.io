<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="这里记录了我在编程时遇到的一些问题，和解决这些问题的一些方法。还有一些是我对编程的一些看法观点，以及学习语言时的一些笔记和心得体会。"><title>字符串朴素匹配算法和KMP算法 | DeepCode</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.4.0/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">字符串朴素匹配算法和KMP算法</h1><a id="logo" href="/.">DeepCode</a><p class="description">高岸为谷，深谷为陵</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/tags/"><i class="fa fa-tag"> 标签</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">字符串朴素匹配算法和KMP算法</h1><div class="post-meta">May 24, 2020<span> | </span><span class="category"><a href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 1.6k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 6</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p>字符串的匹配在平常的编码过程中非常常用，在编程语言中通常是调用一个内置函数就可以实现字符串的匹配，当不让使用内置的函数，而是自己编写一个函数来实现匹配的功能，应该如何来写呢？</p>
<p>今天介绍两个算法，朴素匹配算法，和无回溯匹配算法中的KMP算法。</p>
<h2 id="朴素匹配算法"><a href="#朴素匹配算法" class="headerlink" title="朴素匹配算法"></a>朴素匹配算法</h2><p>朴素匹配算法就是按照常识来，最容易理解的逐个字符匹配。<br>从待匹配字符串中的某个下标<code>i</code>开始，匹配字符串从<code>0</code>开始，逐个匹配。当有不匹配的字符时，重新从<code>i+1</code>下标开始重复上次的匹配过程。</p>
<img width="50%" src="/images/struct/5.jpg" alt="图(1) 朴素匹配算法">

<p>下面用代码实现一下：<br><code>t</code>表示待匹配字符串，<code>p</code>表示用来匹配的字符串。</p>
<p><strong>$p_i$ 表示p字符串的第i个下标的字符。</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">naive_match</span><span class="params">(t, p)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    t 目标字符串</span></span><br><span class="line"><span class="string">    p 匹配字符串</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    m, n = len(p), len(t)</span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> j &lt; n:</span><br><span class="line">        <span class="keyword">if</span> p[i] == t[j]: <span class="comment"># 字符相同，考虑下一字符</span></span><br><span class="line">            i, j = i + <span class="number">1</span>, j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i, j = <span class="number">0</span>, j - i + <span class="number">1</span>  <span class="comment"># 字符不同，查找字符串重置，目标字符串回溯</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i == m:</span><br><span class="line">        <span class="keyword">return</span> j - i</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>朴素匹配算法非常简单，容易理解。当然，它的效率也是很低的，造成效率低的原因是在执行过程中会有回溯。当遇到<code>p[i] != t[j]</code>时，匹配字符串下标置0，待匹配字符串的下标回到上一次检查的下一个位置，往回退了<code>j - i + 1</code>个位置。</p>
<p>这种操作造成的效率很低。最坏的情况是，每次匹配都是到最后一个字符的时候不匹配。例如：<br>&nbsp;&nbsp;待匹配字符串： 0000000000001<br>&nbsp;&nbsp;匹配字符串：   00001<br>这样需要 <code>n-m+1</code>次比较，总的比较次数就是<code>(n-m+1) * m</code>，这样它的复杂度就是：O(n*m)</p>
<h2 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h2><p>朴素算法的效率低，根源上是把每次匹配都看成的单独的事件，没有利用到之前的匹配信息。而其他改进算法就是利用了之前的匹配信息。</p>
<p>KMP算法的基本思想就是在匹配中不回溯。</p>
<img width="60%" src="/images/struct/7.jpg" alt="图(2) KMP算法图解">

<p>描述KMP算法，需要借助上图。<br>待匹配字符串<code>t</code>，和匹配字符串<code>p</code>。<br>在匹配过程中，<code>p</code>的第i个字符在和<code>t</code>的第j个字符比较，这时，$t_{j-i}$～$t_{j-1}$和$p_0$～$p_{i-1}$相等，匹配完成。下面要做的步骤可以分为两个：</p>
<ul>
<li>当$t_j = p_i$ 时，继续进行下一个字符的比较。</li>
<li>当$t_j \neq p_i$ 时，这是不需要重置<code>p</code>，而是找到一个位置<code>k</code>($0\leq k &lt; i$)，使得$t_{j-k}$～$t_{j-1}$ 等于 $p_0$～$p_{k-1}$，继续匹配$t_{j}$和$p_{k}$，重复上面的步骤。这样待匹配字符串也不需要回溯到前面去重新匹配。</li>
</ul>
<p>KMP算法中的关键认识是：在$p_i$匹配失败时，所有的$p_k$($0\leq k &lt; i$)都已经匹配成功。也就是说，待匹配字符串中的$t_j$之前的i个字符，与匹配字符串中的前i个字符$p_0,p_1,…,p_{i-1}$。<br>通过上面的分析，要找到k，完全可以先不管待匹配字符串，而是研究一下匹配字符串<code>p</code>，通过<code>p</code>找到它前移的位置<code>k</code>。</p>
<p>得出一个结论：在<code>p</code>中，其中的每一个字符的<code>i</code>都会有其对应的下标<code>k</code>，与待匹配的字符串无关。</p>
<p>因此，我们可以为匹配字符串设计一个列表来存储每一个<code>i</code>的下标<code>k</code>。假设p的长度为m，用一个长度为m的列表pnext来存储，用表元素<code>pnext[i]</code>来表示i个元素的下标k值。<br>有一种特殊情况：$p_i$匹配失败后，之前所做的匹配都没有用，需要从头开始匹配，用$p_0$与$t_{j+1}$比较。在这种特殊情况下可以在<code>pnext[i]</code>中存入-1来表示。显然，$p_0$一直为-1。</p>
<h3 id="KMP主算法"><a href="#KMP主算法" class="headerlink" title="KMP主算法"></a>KMP主算法</h3><p>当假设pnext已经获得了，KMP的算法实现为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">kmp_match</span><span class="params">(t, p, pnext)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    KMP匹配，主函数</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    i, j = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    m, n = len(p), len(t)</span><br><span class="line">    <span class="keyword">while</span> i &lt; m <span class="keyword">and</span> j &lt; n:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">-1</span>: <span class="comment"># -1 匹配下一队字符</span></span><br><span class="line">            i, j = i + <span class="number">1</span>, j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> p[i] == t[j]: <span class="comment"># 相等，匹配下一对字符</span></span><br><span class="line">            i, j = i + <span class="number">1</span>, j + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            i = pnext[i] <span class="comment"># 从pnext中拿出下一个字符应该的位置</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i == m:</span><br><span class="line">        <span class="keyword">return</span> j - i</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure>

<p>该算法的时间复杂度为O(n)，因为j的循环次数不会超过n，<code>i = pnext[i]</code>的次数不会超过m。</p>
<h3 id="pnext的实现"><a href="#pnext的实现" class="headerlink" title="pnext的实现"></a>pnext的实现</h3><p>最长相等前后缀</p>
<p>已知pnext[0]=-1，并且pnext[0]到pnext[i-1]已知的情况下，求解pnext[i]:</p>
<ol>
<li>假设<code>pnext[i-1]=k-1</code>，如果$p_i=p_k$，则$p_0,p_1,…,p_i$的最长的匹配相等长度为k，记下<code>pnext[i]=k</code>。</li>
<li>如果$p_i \neq p_k$，就将k的值设为pnext[k]，即考虑前一个保证匹配的字符串，且更短。</li>
<li>假如k的值为-1（由第二步造成，一直到不到可以匹配的字符串），那么就将pnext[i]设置为0，将i递增后继续检查。</li>
</ol>
<p>构造方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_pnext</span><span class="params">(p)</span>:</span></span><br><span class="line">    i, k, m = <span class="number">0</span>, <span class="number">-1</span>, len(p)</span><br><span class="line"></span><br><span class="line">    pnext = [<span class="number">-1</span>] * m</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i &lt; m - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">-1</span> <span class="keyword">or</span> p[i] == p[k]:</span><br><span class="line">            i, k = i + <span class="number">1</span>, k + <span class="number">1</span></span><br><span class="line">            pnext[i] = k</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = pnext[k]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pnext</span><br></pre></td></tr></table></figure>

<p>举例：匹配字符串为 <code>abbcabcaabbcaa</code>，得到的pnext为：<br><code>[-1, 0, 0, 0, 0, 1, 2, 0, 1, 1, 2, 3, 4, 5]</code></p>
<h4 id="pnext生成算法的改进"><a href="#pnext生成算法的改进" class="headerlink" title="pnext生成算法的改进"></a>pnext生成算法的改进</h4><p>在pnext的生成中，对pnext[i]的设置可以有些优化。<br>在图(2)中，$p_i \neq t_j$匹配失败，假设pnext[i]=k，如果发现$p_i=p_k$，那么也一定有$p_k \neq t_j$，所以，这种情况下pnext[i]的位置移动到pnext[k]，这一修改减少了一个比较步骤，有可能提高效率。修改后：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gen_pnext</span><span class="params">(p)</span>:</span></span><br><span class="line">    i, k, m = <span class="number">0</span>, <span class="number">-1</span>, len(p)</span><br><span class="line"></span><br><span class="line">    pnext = [<span class="number">-1</span>] * m</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> i &lt; m - <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">-1</span> <span class="keyword">or</span> p[i] == p[k]:</span><br><span class="line">            i, k = i + <span class="number">1</span>, k + <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> p[i] == p[k]:</span><br><span class="line">                pnext[i] = pnext[k]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                pnext[i] = k</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            k = pnext[k]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pnext</span><br></pre></td></tr></table></figure>
<p>举例：匹配字符串为 <code>abbcabcaabbcaa</code>，得到的pnext为：<br><code>[-1, 0, 0, 0, -1, 0, 2, -1, 1, 0, 0, 0, -1, 5]</code></p>
<p>pnext的复杂度为O(m)，所以整个KMP算法的复杂度O(m+n)，由于m小于n，可以认为复杂度为O(n)，优于朴素算法。</p>
</div><div class="tags"><a href="/tags/python/">python</a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post-nav"><a class="next" href="/2020/04/03/tech/python/structure/josephus-solve.html">约瑟夫（Josephos）问题以及解法</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E7%94%9F%E6%B4%BB/">生活</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/%E9%A9%AC%E6%8B%89%E6%9D%BE/" style="font-size: 10px;">马拉松</a> <a href="/tags/HTTP/" style="font-size: 10px;">HTTP</a> <a href="/tags/mysql/" style="font-size: 11.25px;">mysql</a> <a href="/tags/javascript/" style="font-size: 18.75px;">javascript</a> <a href="/tags/bootstrap/" style="font-size: 10px;">bootstrap</a> <a href="/tags/HTML/" style="font-size: 11.25px;">HTML</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 20px;">机器学习</a> <a href="/tags/%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" style="font-size: 16.25px;">监督学习</a> <a href="/tags/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92/" style="font-size: 12.5px;">逻辑回归</a> <a href="/tags/%E9%9D%9E%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" style="font-size: 15px;">非监督学习</a> <a href="/tags/%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/" style="font-size: 12.5px;">算法优化</a> <a href="/tags/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/" style="font-size: 13.75px;">线性回归</a> <a href="/tags/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" style="font-size: 12.5px;">神经网络</a> <a href="/tags/SVM/" style="font-size: 11.25px;">SVM</a> <a href="/tags/PHP/" style="font-size: 10px;">PHP</a> <a href="/tags/python/" style="font-size: 17.5px;">python</a> <a href="/tags/pandas/" style="font-size: 13.75px;">pandas</a> <a href="/tags/django/" style="font-size: 10px;">django</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 12.5px;">数据结构</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2020/05/24/tech/python/structure/str-search-and-kmp.html">字符串朴素匹配算法和KMP算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/03/tech/python/structure/josephus-solve.html">约瑟夫（Josephos）问题以及解法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/03/31/tech/python/structure/link-intro.html">链表介绍及python的实现</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/09/tech/machine_learning/learn_large_datasets.html">在大数据下应用机器学习算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/08/tech/machine_learning/mini_batch_gradient_descent.html">小批量梯度下降算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/08/tech/machine_learning/stochastic_gradient_descent.html">随机梯度下降算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/08/tech/machine_learning/recommender_system.html">推荐系统和协同过滤算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/07/tech/machine_learning/anomaly_detection.html">异常检测（Anomaly Detection）</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/06/tech/machine_learning/dimensionality_reduction.html">PCA降维算法</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/02/06/tech/machine_learning/k_means_intro.html">K均值算法介绍</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="https://www.jianshu.com/u/f133ca80001f" title="爱吃鱼的夏侯莲子" target="_blank">爱吃鱼的夏侯莲子</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2020 <a href="/." rel="nofollow">DeepCode</a>&nbsp;|&nbsp;<a href="http://www.beian.miit.gov.cn/" target="_blank" rel="noopener">苏ICP备20021898号-1</a>&nbsp;|&nbsp;<img class="nofancybox" src="../images/beian/icon.png" style="margin-bottom: -4px;"/><a href="http://www.beian.gov.cn/" target="_blank" rel="noopener">苏公网安备 32059002003042号</a><div class="ss"> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><script type="text/javascript" src="/js/search.js?v=0.0.0"></script><script>var search_path = 'search.xml';
if (search_path.length == 0) {
   search_path = 'search.xml';
}
var path = '/' + search_path;
searchFunc(path, 'local-search-input', 'local-search-result');
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>